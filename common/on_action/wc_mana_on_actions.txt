wc_on_mana_regeneration = {
	effect = {
		if = {
			limit = { has_variable = wc_current_mana_variable }

			wc_change_mana_by_value_effect = {
				CHANGE = add
				VALUE = wc_mana_regeneration_value
			}
		}
		else = {
			set_variable = { name = wc_current_mana_variable value = wc_max_mana_value }
			wc_recalculate_prowess_from_mana_effect = yes
		}
		magic_buff_maintenance_effect = yes 
		trigger_event = { on_action = wc_on_mana_regeneration months = 1 }
	}
}

wc_on_health_regeneration = {
	effect = {
		if = {
			limit = { has_variable = wc_current_hp_variable }
			wc_change_hp_by_value_effect = {
				CHANGE = add
				VALUE = wc_hp_replenishment_value
			}
		}
		
		else = {
			set_variable = { name = wc_current_hp_variable value = wc_hp_capacity_value }
		}

		trigger_event = { on_action = wc_on_health_regeneration months = 1 }
	}
}

wc_on_spell_progression = {
	effect = {
		every_in_list = {
			variable = current_spells_casting
			save_scope_as = casting_spell
			root = {
				execute_scoped_spell_effect = {
					SPELL = scope:casting_spell
					EFFECT = add_spell_progression_effect
				}
			}
		}
		every_in_list = {
			variable = spells_cd
			save_scope_as = cd_spell
			root = {
				execute_scoped_spell_effect = {
					SPELL = scope:cd_spell
					EFFECT = update_spell_cooldown_effect
				}
			}
		}
		if = { # so it doesnt double count spells
			limit = {
				NOT = { exists = var:spell_loop_on }
			}
			set_variable = { name = spell_loop_on value = yes }
		}
		trigger_event = { on_action = wc_on_spell_progression days = 1 }
	}
}

## root is the caster
### before removing the mana of the spell cast and doing anything
### Variable prefix: current_
### Variables: spell_name, rank, targets_list (variable list), recipient, elemental_type (for elemental type), class (spell class), target_type
### e.g. var:current_spell_type = flag:decay
wc_on_spell_cast_started = {
	effect = {
		if = {
			limit = {
				has_variable = current_target_type
				var:current_target_type = flag:character
				has_variable = spell_recipient
			}
			var:spell_recipient = {
				save_scope_as = current_target_character
				root = {
					trigger_event = {
						on_action = wc_on_spell_cast_started_character
					}
				}
			}
		}
		else_if = {
			limit = {
				has_variable = current_target_type
				var:current_target_type = flag:character_list
				has_variable = spell_targets_list
			}

			every_in_list = {
				variable = spell_targets_list
				save_scope_as = current_target_character
				root = {
					trigger_event = {
						on_action = wc_on_spell_cast_started_character
					}
				}
			}
		}
		else_if = {
			limit = {
				has_variable = current_target_type
				var:current_target_type = flag:title
				has_variable = spell_recipient
			}
			var:spell_recipient = {
				save_scope_as = current_target_title
				root = {
					trigger_event = {
						on_action = wc_on_spell_cast_started_title
					}
				}
			}
		}
		else_if = {
			limit = {
				has_variable = current_target_type
				var:current_target_type = flag:title_list
				has_variable = spell_targets_list
			}

			every_in_list = {
				variable = spell_targets_list
				save_scope_as = current_target_title
				root = {
					trigger_event = {
						on_action = wc_on_spell_cast_started_title
					}
				}
			}
		}
		# Flame and Frost synergy
		if = {
			limit = {
				spell_is_arcane_frost = {
					SPELL = var:current_spell_name
				}
			}
			remove_character_flag = flame_synergy
			remove_variable = freeze_time_mult

			set_variable = {
				name = freeze_time_mult
				value = {
					value = 0.01
					multiply = var:current_cost
				}
			}
		}
		else_if = {
			limit = {
				spell_is_arcane_fire = {
					SPELL = var:current_spell_name
				}
			}
			remove_character_flag = frost_synergy
		}
		if = {
			limit = {
				var:current_spell_name = flag:conjure_refreshment
				var:current_spell_rank < 3
			}
			trigger_event = wc_magic_spell_events.2001
		}
	}
}

## root is the caster
### before removing the mana of the spell cast and doing anything
### Is called for every target character of a spell
### Scope current_target_character, is the current target character
### Variable prefix: current_
### Variables: spell_name, rank, targets_list (variable list), recipient, elemental_type (for elemental type), class (spell class), target_type
### e.g. var:current_spell_type = flag:decay
wc_on_spell_cast_started_character = {
	effect = {

	}
}

## root is the caster
### before removing the mana of the spell cast and doing anything
### Is called for every target title of a spell
### Scope current_target_title, is the current target title
### Variable prefix: current_
### Variables: spell_name, rank, targets_list (variable list), recipient, elemental_type (for elemental type), class (spell class), target_type
### e.g. var:current_spell_type = flag:decay
wc_on_spell_cast_started_title = {
	effect = {

	}
}

## root is the caster
### upon finishing the spell cast, before the spell is executed ###
### Setting the var should_cast to no will stop the actual execution of the spell effect
### Setting the var should_include to no on a spell target will stop it from being included in the effects
### Variable prefix: casted_
### Variables: spell, recipient, targets_list (variable list), rank, type (for elemental type), class (spell class), target_type
### e.g. var:casted_spell = flag:lava_lash
wc_on_spell_cast_before_cast = {
	effect = {
		if = {
			limit = {
				has_variable = casted_target_type
				var:casted_target_type = flag:character
				has_variable = casted_recipient
			}
			if = {
				limit = {
					spell_is_harmful_trigger = {
						SPELL = var:casted_spell
					}
					NOT = {
						var:casted_spell = flag:spellsteal
					}
					var:casted_recipient = {
						has_character_modifier = wc_counterspell_modifier
					}
				}
				var:casted_recipient = {
					remove_character_modifier = wc_counterspell_modifier
				}
				set_variable = {
					name = should_reflect
					value = yes
				}
			}
		}
		else_if = {
			limit = {
				has_variable = casted_target_type
				var:casted_target_type = flag:character_list
				has_variable = casted_targets_list
			}
			if = {
				limit = {
					spell_is_harmful_trigger = {
						SPELL = var:casted_spell
					}
					NOT = {
						var:casted_spell = flag:spellsteal
					}
				}
				every_in_list = {
					variable = casted_targets_list
					limit = {
						has_character_modifier = wc_counterspell_modifier
					}
					remove_character_modifier = wc_counterspell_modifier
					set_variable = {
						name = should_include
						value = no
					}
					root = {
						set_variable = {
							name = should_reflect
							value = yes
						}
					}
				}
			}
		}
	}
}

## root is the caster
### upon finishing the spell cast, before setting cd or anything ###
### Variable prefix: casted_
### Variables: spell, recipient, targets_list (variable list), rank, type (for elemental type), class (spell class), target_type
### e.g. var:casted_spell = flag:lava_lash
wc_on_spell_cast_finish = {
	effect = {
		# Send interface message to caster
		send_interface_message = {
			title = spell_cast_complete_title
			custom_tooltip = spell_cast_complete_desc
		}

		if = { # automatically used
			limit = {
				has_character_modifier = wc_backdraft_proc
			}
			remove_character_modifier = wc_backdraft_proc
		}

		if = {
			limit = {
				has_variable = casted_target_type
				var:casted_target_type = flag:character
				has_variable = casted_recipient
			}
			var:casted_recipient = {
				save_scope_as = current_target_character
				root = {
					trigger_event = {
						on_action = wc_on_spell_cast_finish_character
					}
				}
			}
		}
		else_if = {
			limit = {
				has_variable = casted_target_type
				var:casted_target_type = flag:character_list
				has_variable = casted_targets_list
			}

			every_in_list = {
				variable = casted_targets_list
				save_scope_as = current_target_character
				root = {
					trigger_event = {
						on_action = wc_on_spell_cast_finish_character
					}
				}
			}
		}
		else_if = {
			limit = {
				has_variable = casted_target_type
				var:casted_target_type = flag:title
				has_variable = casted_recipient
			}
			var:casted_recipient = {
				save_scope_as = current_target_title
				root = {
					trigger_event = {
						on_action = wc_on_spell_cast_finish_title
					}
				}
			}
		}
		else_if = {
			limit = {
				has_variable = casted_target_type
				var:casted_target_type = flag:title_list
				has_variable = casted_targets_list
			}

			every_in_list = {
				variable = casted_targets_list
				save_scope_as = current_target_title
				root = {
					trigger_event = {
						on_action = wc_on_spell_cast_finish_title
					}
				}
			}
		}

		# Send interface message to target 
		if = {
			limit = { 
				exists = var:casted_recipient
				OR = {
					var:casted_target_type = flag:army
					var:casted_target_type = flag:friendly_army
					var:casted_target_type = flag:enemy_army
				}
				NOT = { var:casted_recipient.army_owner = root }
			}
			var:casted_recipient.army_owner = {
				save_temporary_scope_as = castee
			}
			scope:castee = {
				root = {
					save_temporary_scope_as = caster
				}
				set_variable = {
					name = on_casted_spell
					value = root.var:casted_spell
				}
				send_interface_message = {
					title = spell_cast_on_you_title
					custom_tooltip = spell_cast_on_you_desc
				}
			}
		}

		## PYROMANIA
		if = {
			limit = {
				has_perk = elemental_fire_magic_tree_1_perk_2
			}
			if = {
				limit = {
					var:casted_class = flag:elemental_fire
				}
				random_list = {
					75 = {}
					25 = {
						send_interface_message = {
							title = wc_pyromania_title
							add_character_modifier = {
								modifier = wc_pyromania_modifier
								days = 365
							}
						}
					}
				}
			}
			else_if = {
				limit = {
					has_character_modifier = wc_pyromania_modifier
				}
				# Remove modifier
				send_interface_message = {
					title = wc_pyromania_title_lost
					remove_all_character_modifier_instances = wc_pyromania_modifier
				}
			}
		}

		## BURNOUT
		clear_burnout_effect = yes

		# Burn caster when target has Fire Shield
		if = {
			limit = {
				exists = var:casted_recipient
				OR = {
					var:casted_target_type = flag:army
					var:casted_target_type = flag:friendly_army
					var:casted_target_type = flag:enemy_army
				}
				NOT = { var:casted_recipient.army_owner = root }
				NOT = { var:casted_recipient.army_commander = root }
				var:casted_recipient.army_commander = {
					has_character_modifier = wc_fire_shield_modifier
					has_perk = order_magic_tree_4_perk_6
				}
				spell_is_harmful_trigger = {
					SPELL = var:casted_spell
				}
			}

			root = {
				add_or_increase_burned_effect = yes

				send_interface_toast = {
					title = wc_spell_reflected
					left_icon = root
					right_icon = var:casted_recipient
					custom_tooltip = wc_fire_shield_reflect_tt
				}
			}
		}

		# Frost Synergy and Icy Veins
		if = {
			limit = {
				spell_is_arcane_frost = {
					SPELL = var:casted_spell
				}
			}

			if = {
				limit = {
					has_perk = order_magic_tree_4_perk_5
				}
				add_character_flag = frost_synergy
			}

			if = {
				limit = {
					has_perk = order_magic_tree_5_perk_4
					NOT = {
						var:casted_spell = flag:frostbolt
					}
				}
				add_character_flag = icy_veins
			}
			else = {
				remove_character_flag = icy_veins
			}
		}
		else_if = {
			limit = {
				has_perk = order_magic_tree_5_perk_6
				spell_is_arcane_fire = {
					SPELL = var:casted_spell
				}
			}

			add_character_flag = flame_synergy
		}

		# Twin Flame
		if = {
			limit = {
				has_perk = order_magic_tree_4_perk_7
				var:casted_spell = flag:fire_shield
			}
			trigger_event = wc_magic_spell_events.1001
		}

		# Freeze time
		if = {
			limit = {
				spell_is_arcane_chronomancy_trigger = { SPELL = var:current_spell }
				has_variable = freeze_time_mult
			}
			remove_variable = freeze_time_mult
		}
	}
}

## root is the caster
### Is called for every target character of a spell
### Scope current_target_character, is the current target character
### upon finishing the spell cast, before setting cd or anything ###
### Variable prefix: casted_
### Variables: spell, recipient, targets_list (variable list), rank, type (for elemental type), class (spell class), target_type
### e.g. var:casted_spell = flag:lava_lash
wc_on_spell_cast_finish_character = {
	effect = {
		# Send interface message to target
		if = {
			limit = {
				NOT = { scope:current_target_character = root }
			}
			scope:current_target_character = {
				save_temporary_scope_as = castee
			}
			scope:castee = {
				root = {
					save_temporary_scope_as = caster
				}
				set_variable = {
					name = on_casted_spell
					value = root.var:casted_spell
				}
				send_interface_message = {
					title = spell_cast_on_you_title
					custom_tooltip = spell_cast_on_you_desc
				}
			}
		}

		# Clear Scorch cooldown when hit with elemental or fel hostile magic
		if = {
			limit = {
				NOT = { scope:current_target_character = root }
				OR = {
					var:casted_class = flag:elemental_fire
					var:casted_class = flag:elemental_earth
					var:casted_class = flag:elemental_water
					var:casted_class = flag:elemental_air
					var:casted_class = flag:disorder
				}
				spell_is_harmful_trigger = {
					SPELL = var:casted_spell
				}
			}

			scope:current_target_character = {
				remove_spell_cooldown_effect = { SPELL = scorch }
			}
		}

		# Burn caster when target has Fire Shield
		if = {
			limit = {
				scope:current_target_character = {
					has_character_modifier = wc_fire_shield_modifier
				}
				spell_is_harmful_trigger = {
					SPELL = var:casted_spell
				}
			}

			# TODO: Maybe remove Fire Shield modifier?

			root = {
				add_or_increase_burned_effect = yes

				send_interface_toast = {
					title = wc_spell_reflected
					left_icon = root
					right_icon = scope:current_target_character
					custom_tooltip = wc_fire_shield_reflect_tt
				}
			}
		}

		# Netherburn
		if = {
			limit = {
				NOT = {
					has_character_flag = netherburn_triggered
				}
				var:casted_class = flag:order
				has_perk = order_magic_tree_4_perk_2
				spell_is_harmful_trigger = {
					SPELL = var:casted_spell
				}
			}
			scope:current_target_character = {
				save_scope_value_as = {
					name = spell_dodge_chance
					value = wc_order_magic_resistance_dodge_value
				}
			}
			random_list = {
				25 = {
					burned_target_frostbite_modifier = { TARGET = var:casted_recipient CHANGE = add }
					scope:current_target_character = {
						add_or_increase_burned_effect = yes
						add_opinion = {
							modifier = wc_burned_me
							target = scope:current_target_character
						}
					}

					send_interface_toast = {
						title = wc_netherburn_triggered
						left_icon = root
						right_icon = scope:current_target_character
						custom_tooltip = wc_netherburn_tt
					}

					add_character_flag = {
						flag = netherburn_triggered
						years = 1
					}
				}
				75 = {
					modifier = {
						is_alive = yes
						add = scope:spell_dodge_chance
					}
					burned_target_frostbite_modifier = { TARGET = var:casted_recipient CHANGE = subtract }
				}
			}
		}
	}
}

## root is the caster
### Is called for every target title of a spell
### Scope current_target_title, is the current target title
### upon finishing the spell cast, before setting cd or anything ###
### Variable prefix: casted_
### Variables: spell, recipient, targets_list (variable list), rank, type (for elemental type), class (spell class), target_type
### e.g. var:casted_spell = flag:lava_lash
wc_on_spell_cast_finish_title = {
	effect = {
		# Send interface message to target
		if = {
			limit = {
				NOT = { scope:current_target_title.holder = root }
			}
			scope:current_target_title.holder = {
				save_temporary_scope_as = castee
			}
			scope:castee = {
				root = {
					save_temporary_scope_as = caster
				}
				set_variable = {
					name = on_casted_spell
					value = root.var:casted_spell
				}
				send_interface_message = {
					title = spell_cast_on_you_title
					custom_tooltip = spell_cast_on_you_desc
				}
			}
		}

		## BACKDRAFT
		if = {
			limit = {
				OR = { # is it the required spell type
					var:casted_class = flag:elemental_fire
					var:casted_class = flag:elemental_earth
					var:casted_class = flag:elemental_water
					var:casted_class = flag:elemental_air
					var:casted_class = flag:disorder
					var:casted_class = flag:order
				}
				# The spell is not backdraft itself
				NOT = { var:casted_spell = flag:backdraft }
			}

			if = {
				limit = {
					scope:current_target_title = {
						has_variable = backdraft_monitor
					}
				}
				scope:current_target_title = {
					var:backdraft_monitor = {
						execute_scoped_spell_effect = {
							SPELL = root.var:casted_spell
							EFFECT = backdraft_proc_effect
						}
					}
					remove_variable = backdraft_monitor
				}
			}
			else_if = {
				limit = {
					scope:current_target_title = {
						tier <= tier_county
					}
					scope:current_target_title.title_province = {
						has_variable = backdraft_monitor
					}
				}
				scope:current_target_title.title_province = {
					var:backdraft_monitor = {
						execute_scoped_spell_effect = {
							SPELL = root.var:casted_spell
							EFFECT = backdraft_proc_effect
						}
					}
					remove_variable = backdraft_monitor
				}
			}
			else_if = {
				limit = {
					scope:current_target_title = {
						tier = tier_county
						any_county_province = {
							has_variable = backdraft_monitor
						}
					}
				}
				scope:current_target_title = {
					every_county_province = {
						limit = {
							has_variable = backdraft_monitor
						}
						var:backdraft_monitor = {
							execute_scoped_spell_effect = {
								SPELL = root.var:casted_spell
								EFFECT = backdraft_proc_effect
							}
						}
						remove_variable = backdraft_monitor
					}
				}
			}
			else_if = {
				limit = {
					scope:current_target_title = {
						tier > tier_county
						any_de_jure_county = {
							OR = {
								has_variable = backdraft_monitor
								any_county_province = {
									has_variable = backdraft_monitor
								}
							}
						}
					}
				}
				scope:current_target_title = {
					every_de_jure_county = {
						limit = {
							OR = {
								has_variable = backdraft_monitor
								any_county_province = {
									has_variable = backdraft_monitor
								}
							}
						}
						if = {
							limit = {
								has_variable = backdraft_monitor
							}
							var:backdraft_monitor = {
								execute_scoped_spell_effect = {
									SPELL = root.var:casted_spell
									EFFECT = backdraft_proc_effect
								}
							}
							remove_variable = backdraft_monitor
						}
						else = {
							every_county_province = {
								limit = {
									has_variable = backdraft_monitor
								}
								var:backdraft_monitor = {
									execute_scoped_spell_effect = {
										SPELL = root.var:casted_spell
										EFFECT = backdraft_proc_effect
									}
								}
								remove_variable = backdraft_monitor
							}
						}
					}
				}
			}
		}
	}
}