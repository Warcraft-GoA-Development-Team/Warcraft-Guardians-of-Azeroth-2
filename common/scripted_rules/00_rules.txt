# Determines who can command troops; filters who shows up in the list
# Root is the potential commander
# scope:army_owner is who owns the army to command
can_command_troops = {
	can_be_commander_basic_trigger = { ARMY_OWNER = scope:army_owner }
}

# Determines who can command troops; will still show up in the list, with a breakdown explaining why they can't command
# Root is the potential commander
# scope:army_owner is who owns the army to command
can_command_troops_now = {
	can_be_commander_now_trigger = { ARMY_OWNER = scope:army_owner }
}

# Determines if a barony should be handed to a GHW beneficiary, or instead have a baron generated. If true, goes to a beneficiary
# Root is barony province
# scope:faith is the faith controlling the GHW
ghw_give_barony_to_beneficiary = {
	has_holding_type = castle_holding
}

# Determines if a faith can be created, on top of the piety requirement, and the doctrine requirements
# Also handles reforming a faith, check for the unreformed doctrine to enable those additional checks
# Root is the faith creator
faith_creation = {
	trigger_if = {
		limit = {
			highest_held_title_tier = tier_county
			is_independent_ruler = no
		}
		custom_description = {
			text = "faith_creation_duchy_or_higher"
			highest_held_title_tier >= tier_duchy
		}
	}

	is_adult = yes
	is_at_war = no
	custom_description = {
		text = "character_is_not_real_head"
		NOT = { faith.religious_head = root }
	}

	custom_description = {
		text = "character_can_only_create_one_faith"
		NOT = { exists = var:has_created_a_faith }
	}

	trigger_if = {
		limit = {
			faith = { has_doctrine_parameter = unreformed }
		}
		
		NOT = {
			custom_description = {
				text = faith_has_been_reformed
				object = faith
				exists = faith.var:has_been_reformed
			}
		}
		
		faith = {
			num_realm_holy_sites_faithful_holders = {
				CHARACTER = root
				COUNT = 3
			}
		}
		# Warcraft - remove custom tooltip
	}
}

# Determines if a character can convert faith via the convert faith UI, on top of the piety requirement
# Root is the faith creator
# scope:new_faith is the faith they want to convert to
faith_conversion = {
	is_adult = yes
	NOT = { faith.religious_head = root }
	is_in_ongoing_great_holy_war = no
	
	# Warcraft
	trigger_if = {
		limit = { has_title = title:e_scourge }
		scope:new_faith = { has_doctrine_parameter = death_magic_openly_learnable }
	}
}

# Determines if the mother of a character should spread the house to a bastard.
# Requirements: One of both parents should exists. One of both parents should have a house.
# Root is the bastard
should_mother_give_house_to_bastard = {
	should_mother_give_house_to_bastard_trigger = yes
}

# Determines if a character may be appointed as a knight. Checked during automatic knight assignment
# Root is the potential knight
can_be_knight = {
	trigger_if = {
		limit = {
			OR = {
				is_playable_character = no
				root = root.court_owner 
			}
			NOT = { exists = liege } 
		}
		can_be_knight_trigger = { ARMY_OWNER = root.court_owner }
	}
	trigger_else = {
		can_be_knight_trigger = { ARMY_OWNER = liege }
	}
}

# Determines if a character is allowed to be granted specific title by another character
# Root is the target character
# scope:liege is the granter
# scope:landed_title is the title in question
allowed_to_be_granted_titles_by = {
	trigger_if = {
		limit = {
			scope:landed_title = {
				tier <= tier_county
				title_province = { has_holding_type = church_holding }
			}
			scope:liege.faith = {
				NOT = { has_doctrine_parameter = lay_clergy }
			}
		}
		custom_tooltip = {
			text = grant_title_clerical_gender_tt
			can_be_granted_theocratic_titles_by = { RULER = scope:liege }
		}
	}
	trigger_else = {
		can_be_granted_titles_by = { RULER = scope:liege }
	}
}

is_character_allowed_to_be_player = {
	trigger_if = {
		limit = {
			scope:will_override_government = no
		}
	# Warcraft - let players play theocracy and republic
		custom_description = {
			text = "GAME_OVER_CANNOT_PLAY_MERCENARY"
			NOT = { government_has_flag = government_is_mercenary }
		}
		
		custom_description = {
			text = "GAME_OVER_CANNOT_PLAY_HOLY_ORDER"
			NOT = { government_has_flag = government_is_holy_order }
		}

		trigger_if = {
			limit = {
				NOT = { has_dlc_feature = admin_gov }
			}
			custom_description = {
				text = "GAME_OVER_CANNOT_PLAY_ADMIN"
				NOT = { government_has_flag = government_is_administrative }
			}
		}

		# We cannot become landless adventurers
		trigger_if = {
			limit = {
				NOT = { has_dlc_feature = landless_playable }
			}
			custom_description = {
				text = "GAME_OVER_CANNOT_PLAY_ADVENTURER"
				NOT = { government_has_flag = government_is_landless_adventurer }
			}
			custom_description = {
				text = "GAME_OVER_CANNOT_PLAY_BARON"
				NOT = { highest_held_title_tier = tier_barony }
			}

			# This is a generic "catch all", we should have caught it before this
			is_playable_character = yes
		}
		# We can become landless adventurers
		trigger_else = {
			# This is a generic "catch all", we should have caught it before this
			OR = {
				is_ruler = no # We're not a ruler, but we can become a landless adventurer
				is_playable_character = yes # General catch-all, we can continue playing
			}
			NOT = { has_character_flag = declined_become_laamp }
		}
	}
}

# Determines if a secret is considered available for blackmail for use in the GUI (icon/tooltip listing a secret you know as usable for blackmail)
# Scopes the same as a secret_type's is_valid, plus:
# root -> the secret
# scope:target -> the target character
# scope:blackmailer -> the blackmailing character
# The GUI only checks secrets the character is a participant in, that you know of, that have not been spent by you, and that are not revealed
is_secret_available_for_blackmail = {
	is_blackmailable_secret_trigger = {
	 	PARTICIPANT = scope:target
	 	BLACKMAILER = scope:blackmailer
	}
}

# Is this character allowed to join factions in general. See also passes_faction_soft_block.
# Root: Character being evaluated
# scope:target: the target character of the faction
passes_faction_hard_block = {
	custom_description = {
		text = "FACTION_CANT_JOIN_IF_TARGET"
		NOT = { root = scope:target }
	}

	custom_description = {
		text = "FACTION_CANT_JOIN_CREATE_ADULT"
		is_adult = yes
	}
	
	custom_description = {
		text = "FACTION_CANT_JOIN_CREATE_ALLIED"
		trigger_if = {
			limit = { exists = scope:target }
			NOT = { is_allied_to = scope:target }
		}
	}

	custom_description = {
		text = "FACTION_CANT_JOIN_CREATE_HOOK"
		trigger_if = {
			limit = { exists = scope:target }
			scope:target = {
				NOT = { has_strong_hook = root }
			}		
		}
	}

	custom_description = {
		text = "FACTION_CANT_JOIN_CREATE_IMPRISONED"
		trigger_if = {
			limit = {
				exists = joined_faction
				joined_faction = {
					faction_is_at_war = yes
				}
			}
		}
		trigger_else = {
			is_imprisoned = no		
		}
	}	

	custom_description = {
		text = "FACTION_CANT_JOIN_CREATE_INCAPABLE"
		NOT = { is_incapable_trigger = yes }
	}

	custom_description = {
		text = "character_blocked_from_joining"
		NOT = { has_character_flag = joining_faction_block }
	}

	custom_description = {
		text = "faction_relation_blocks_joining_friend"
		trigger_if = {
			limit = { exists = scope:target }
			NOT = {
				root = { has_relation_friend = scope:target }
			}
		}
	}

	custom_description = {
		text = "faction_relation_blocks_joining_lover"
		trigger_if = {
			limit = { exists = scope:target }
			NOR = {
				root = { has_relation_lover = scope:target }
				root = { has_secret_relation_lover = scope:target }
			}
		}
	}
}

# Is this character allowed to join factions. It is a soft block because factions can set a toggle to ignore this block on the faction type.
# Root: Character being evaluated
passes_faction_soft_block = {
	custom_description = {
		text = "FACTION_SOFT_BLOCK_IS_NOT_COURT_CHAPLAIN"
		NOT = { has_council_position = councillor_court_chaplain }
	}
}

# Is this faction dangerous
# Root = Faction being evaluated
is_dangerous_faction = {
	is_dangerous_faction_trigger = yes
}

# Is the alliance reason still valid
# Root = First character of alliance reason
# scope:second = Second character of alliance reason
is_alliance_valid = {
	OR = {
		any_spouse = {
			this = scope:second
		}
		betrothed = scope:second
		is_parent_of = scope:second
		is_child_of = scope:second
		is_sibling_of = scope:second
		is_grandparent_of = scope:second
		is_great_grandparent_of = scope:second
		is_grandchild_of = scope:second
		is_great_grandchild_of = scope:second
		is_uncle_or_aunt_of = scope:second
		is_nibling_of = scope:second
		scope:second = {
			OR = {
				has_opinion_modifier = {
					modifier = perk_negotiated_alliance_opinion
					target = root
				}
				has_opinion_modifier = {
					modifier = event_negotiated_alliance_opinion
					target = root
				}
			}
		}
		#childhood friendship with hostage event, where they swear to be friends forever
		AND = {
			OR = {
				has_relation_friend = scope:second
				has_relation_best_friend = scope:second
			}
			OR = {
				any_memory = {
					has_memory_type = hostage_oath_of_friendship
					has_memory_participant = scope:second
				}
				scope:second = {
					any_memory = {
						has_memory_type = hostage_oath_of_friendship
						has_memory_participant = root
					}
				}
			}
		}
		# Warcraft
		# # FP3 struggle case
		# has_character_flag = fp3_is_a_loyalist_puppet
		# scope:second = { has_character_flag = fp3_is_a_loyalist_puppet }
		
		is_in_same_union_trigger = { TARGET = scope:second } # Warcraft
	}
}

# Can the character designate an heir? Used for the Realm screen
can_designate_heir = {
	can_designate_heir_trigger = yes
}


# Does the character care about having a council position? Used for powerful vassals that have no council position for whether they should get the opinion penalty
cares_about_powerful_vassal_council_position = {
	can_be_councillor_basics_trigger = yes
	NOT = { this = liege.diarch }
	is_designated_diarch = no
}

# Does the character approve of succession law changes? Used for the succession law change GUI to designate oppose vs. approve for powerful vassals
approves_of_succession_law_change = {
	opposes_succession_law_change_trigger = no
}

# Does the character get a second chance when rolling a natural death
has_natural_death_second_chance = {
	OR = {
		AND = {
			has_perk = know_thyself_perk
			NOT = { has_character_flag = know_thyself_has_triggered_delay }
		}
		has_character_flag = know_thyself_perk_delay_period
	}
}

# Can the character refund their perks? Scope is the character
can_refund_perks = {
	perk_points_assigned >= 1
	custom_description = {
		text = already_reset_perks
		NOT = {
			has_character_flag = has_refunded_perks
		}
	}
}

# Can the character join the defender in a holy war? Only characters' of the defender's faith are considered. Player characters are not considered.
# Scope is the potential joiner
# scope:attacker is the attacker
# scope:defender is the defender
can_defensively_join_holy_war = {
	is_playable_character = yes
	exists = scope:defender.capital_province
	exists = capital_province
	gold >= ai_war_chest_defender_holy_war_gold_value
	is_at_war = no
	NOR = {
		is_vassal_or_below_of = scope:defender
		is_allied_to = scope:attacker
		has_relation_friend = scope:attacker
		has_relation_lover = scope:attacker
		has_trait = craven
		has_relation_rival = scope:defender
	}
	OR = {
		primary_title.tier >= tier_duchy # Of significant size
		current_military_strength >= scope:defender.current_military_strength # Avoid having too many small counts join in
	}
	OR = {
		character_is_realm_neighbor = scope:defender # Needs to be an independent realm neighbour
		AND = { # Unless very zealous or friendly, within a reasonable distance
			OR = {
				ai_zeal >= 75
				has_relation_friend = scope:defender
				has_relation_lover = scope:defender
				is_close_family_of = scope:defender
			}
			capital_province = {
				squared_distance = {
					target = scope:defender.capital_province
					value <= squared_distance_medium #250 map-pixels. Roughly one Ireland away (top to bottom).
				}
			}
		}
	}
}

# Can a character be fire from being a councillor
# root = council owner
# scope:councillor = councillor attempting to be fired
can_fire_councillor = {
	custom_description = {
		text = blocked_from_remove_councillor
  		subject = root
  		object = scope:councillor
		OR = {
			NOT = { exists = scope:councillor }
			NOT = {
				scope:councillor = {
					is_blocked_from_being_fired_from_council_trigger = { COURT_OWNER = root }
				}
			}	
		}
	}
}

# Can this character go on raids?
# root: the potential raider
can_raid = {
	#Scripted trigger used so that we can call on the same conditions in script.
	can_raid_trigger = yes
}

# Can this character start a new raid right now? (can_raid will always get checked first)
# root: the potential raider
can_start_raid = {
	is_at_war = no
}

# Can this character cross water (sea, rivers) while on raid?
# root: the potential raider
can_raid_across_water = { can_raid_across_water_trigger = yes }

# Can this character traverse rivers using boats?
# root: the owner of the army
can_traverse_river = {
	OR = {
		culture = {
			OR = {
				has_innovation = innovation_longboats
				#has_innovation = innovation_african_canoes # Warcraft
				has_cultural_parameter = can_travel_along_rivers
			}
		}
		AND = {
			exists = dynasty
			dynasty = { has_dynasty_modifier = fp1_legacy_of_piracy_modifier }
		}
	}
}

#Is this character hard blocked from backing a scheme?
#Scope it to potential backer
is_hard_blocked_from_schemes = {
	is_incapable = yes
}

# Will AI for this character try to arrange matrilineal marriages?
# Note that the AI can still arrange patrilineal marriages based on the SPOUSE_SCORE_LINEALITY_MISMATCH_SCORE AI define
# root: the arranging AI character
# scope:secondary_actor: the character to be married
ai_wants_matrilineal_marriage = {
	scope:secondary_actor = {
		is_female = yes
	}
	trigger_if = { # AI's always want to matrilineally marry their Dynasty members
		limit = {
			has_game_rule = matrilineal_marriages_always
		}
		scope:secondary_actor.dynasty = root.dynasty
	}
	trigger_else_if = { # AI's want matrilineal marriages if female dominated or equal, but not otherwise
		limit = {
			has_game_rule = matrilineal_marriages_female_and_equal
		}
		OR = { # Either Matrilineal Marriages are the norm
			has_realm_law = female_only_law
			has_realm_law = female_preference_law
			faith = {
				has_doctrine_parameter = female_dominated_law
			}
			AND = {
				exists = dynasty
				scope:secondary_actor.dynasty = root.dynasty
				root = {
					has_realm_law = equal_law
				}
				OR = {
					scope:secondary_actor = root # Either I am a woman
					OR = {
						root.primary_title = { # Or it's my first three heirs
							place_in_line_of_succession = {
								target = scope:secondary_actor
								value <= 3
							}
						}
						scope:secondary_actor = {
							any_parent = { # Or my first heir's oldest child
								root.primary_title = {
									place_in_line_of_succession = {
										target = scope:secondary_actor
										value <= 1
									}
								}
							}
							NOT = {
								any_sibling = {
									# Warcraft
									age_in_relation_to_humans_more_than_trigger = { age = scope:secondary_actor.age }
								}
							}
						}
					}
				}
			}
		}
	}
	trigger_else_if = { # Only Female Dominated realms want matrilineal marriages
		limit = {
			has_game_rule = matrilineal_marriages_never
		}
		OR = { # Matrilineal Marriages are the norm
			has_realm_law = female_only_law
			has_realm_law = female_preference_law
			faith = {
				has_doctrine_parameter = female_dominated_law
			}
		}
	}
	trigger_else_if = { # Default, but no player exception
		limit = {
			has_game_rule = matrilineal_marriages_no_player_exception
		}
		OR = { # Either Matrilineal Marriages are the norm
			has_realm_law = female_only_law
			has_realm_law = female_preference_law
			faith = {
				has_doctrine_parameter = female_dominated_law
			}
			AND = { # Or there's a good reason to pursue them, such as being of a Reputable dynasty or ruling a Duchy
				exists = dynasty
				scope:secondary_actor.dynasty = root.dynasty
				OR = {
					scope:secondary_actor = root # Either I am a woman
					root.primary_title = { # It's my primary heir
						place_in_line_of_succession = {
							target = scope:secondary_actor
							value <= 1
						}
					}
					AND = { # Or I'm under Equal, and it's my first three heirs
						has_realm_law = equal_law
						OR = {
							root.primary_title = {
								place_in_line_of_succession = {
									target = scope:secondary_actor
									value <= 3
								}
							}
							scope:secondary_actor = {
								any_parent = { # Or my first heir's oldest child
									root.primary_title = {
										place_in_line_of_succession = {
											target = scope:secondary_actor
											value <= 1
										}
									}
								}
								NOT = {
									any_sibling = {
										# Warcraft
										age_in_relation_to_humans_more_than_trigger = { age = scope:secondary_actor.age }
									}
								}
							}
						}
					}
				}
				root = {
					OR = {
						highest_held_title_tier >= tier_duchy
						dynasty = { dynasty_prestige_level >= 4 }
						has_realm_law = equal_law
					}
				}
			}
		}
	}
	trigger_else = { # Default rules	
		OR = { # Either Matrilineal Marriages are the norm
			has_realm_law = female_only_law
			has_realm_law = female_preference_law
			faith = {
				has_doctrine_parameter = female_dominated_law
			}
			AND = { # Or there's a good reason to pursue them, such as being of a Reputable dynasty or ruling a Duchy
				exists = dynasty
				scope:secondary_actor.dynasty = root.dynasty
				OR = {
					scope:secondary_actor = root # Either I am a woman
					root.primary_title = { # It's my primary heir
						place_in_line_of_succession = {
							target = scope:secondary_actor
							value <= 1
						}
					}
					AND = { # Or I'm under Equal, and it's my first three heirs
						has_realm_law = equal_law
						OR = {
							root.primary_title = {
								place_in_line_of_succession = {
									target = scope:secondary_actor
									value <= 3
								}
							}
							scope:secondary_actor = {
								any_parent = { # Or my first heir's oldest child
									root.primary_title = {
										place_in_line_of_succession = {
											target = scope:secondary_actor
											value <= 1
										}
									}
								}
								NOT = {
									any_sibling = {
										# Warcraft
										age_in_relation_to_humans_more_than_trigger = { age = scope:secondary_actor.age }
									}
								}
							}
						}
					}
				}
				root = {
					OR = {
						highest_held_title_tier >= tier_duchy
						dynasty = { dynasty_prestige_level >= 4 }
						has_realm_law = equal_law
						any_player = { # Very close to a player
							exists = dynasty
							dynasty = scope:secondary_actor.dynasty
							is_close_family_of = scope:secondary_actor
						}
					}
				}
			}
		}
	}
}

# Does the AI want to have a grand wedding instead of an instant marriage
# root: the arranging AI character
# scope:actor: the arranging AI character
# scope:secondary_actor: character being married that AI can control
# scope:recipient: the character who can accept the marriage proposal
# scope:secondary_recipient: the character to be married
ai_wants_grand_wedding_promise = {
	OR = {
		# Propose grand wedding to the player, the players primary heir, and their oldest child (both sexes)
		scope:recipient = {
			is_ai = no
			scope:secondary_recipient = {
				OR = {
					this = scope:recipient
					is_primary_heir_of = scope:recipient
					AND = {
						is_child_of = scope:recipient
						NOT = {
							any_sibling = {
								sex_same_as = scope:secondary_recipient
								age > scope:secondary_recipient.age
							}
						}
					}
				}
			}
		}
		# An unmarried ruler wants it for their primary wedding
		scope:actor = {
			this = scope:secondary_actor
			is_married = no
			is_ruler = yes
		}
		# A ruler wants it for their primary heir's primary wedding
		AND = {
			scope:actor.primary_title = {
				place_in_line_of_succession = {
					target = scope:secondary_actor
					value <= 1
				}
			}
			scope:secondary_actor = {
				is_married = no
			}
		}
		# Very prestigious rulers just want to show off
		AND = {
			scope:actor = {
				highest_held_title_tier >= tier_kingdom
				has_personality_extroverted_trigger = yes
				ai_greed <= -50
			}
			OR = {
				scope:actor.dynasty = { dynasty_prestige_level >= 4 }
				scope:actor = { prestige_level >= 4 }
			}
		}
		# Swimming in money and not greedy
		AND = {
			scope:actor.ai_greed <= 0
			scope:actor.gold >= 7000
		}
	}
	# Let's try to prevent the AI from going bankrupt
	scope:actor = { gold >= ai_wedding_promise_gold_actor }
	scope:actor = {
		OR = {
			# You're getting at least an alliance out of it 
			yields_alliance = {
				candidate = scope:secondary_actor
				target = scope:recipient
				target_candidate = scope:secondary_recipient
			}
			# Or it's an ally you want to strengthen the bonds with
			is_allied_to = scope:recipient
			# Or you just have the perfect personality for it!
			AND = {
				has_personality_extroverted_trigger = yes
				ai_greed <= -50
				ai_rationality <= -25
				exists = scope:secondary_actor.dynasty
			}
		}
		is_at_war = no
	}
	# Only do Grand Weddings for rulers of your tier or above
	exists = scope:recipient.primary_title
	OR = {
		scope:recipient.primary_title.tier >= primary_title.tier
		scope:recipient.primary_title.tier >= tier_kingdom
	}
}

# Is this character blocked from having buildings enabled?
#Scope it to potential backer
buildings_enabled = {
	custom_description = {
		text = vastly_over_domain_limit_trigger
		trigger_if = {
			limit = {
				is_ai = no
			}
			domain_size_excluding_grace_period < building_disable_inefficient_value
		}
	}
}

# Can this character potentially call its ally to war (note, war doesn't necessarily exist yet)
# Used by the AI to account for allies when determining wars to declare
# Also used in the war declaration screen to filter out allies that definitely cannot be called
# root: the potential caller
# scope:ally: the ally
can_potentially_call_ally = {
	can_potentially_call_ally_trigger = {
		WARRIOR = root
		JOINER = scope:ally
	}
}

# Is this character allowed to hybridize their culture with the target culture?
# root: Character
# scope:culture: The culture they want to hybridize with
can_hybridize_culture = {
	can_hybridize_culture_trigger = {
		CULTURE = scope:culture
		CHARACTER = root
	}
}

# Is this character allowed to diverge their culture?
# root: Character
can_diverge_culture = {
	culture = { culture_age >= culture_divergence_cooldown }
	custom_description = {
		text = culture_present_in_realm_for_divergence
		any_sub_realm_county = {
			culture = root.culture
		}
	}
}

# Is this character allowed to add a tradition to their culture?
# root: Character
can_add_tradition = {
	custom_description = {
		text = culture_has_tradition_cooldown
		culture = {
			NOT = { has_variable = tradition_cooldown }
		}
	}
}

# Is this character allowed to replace a pillar of their culture?
# root: Character
can_replace_pillar = {
}

# Can we rename a character?
# Root is the renamer (E.G., the player)
# scope:child is the person we want to rename
can_name_after_birth = {
	scope:child = { is_adult = no }
	allow_naming_on_birth_of_child_trigger = { CHILD = scope:child }
}

# Can a language be adopted as the court language
# Only used by the AI
# Native language bypasses this
# root = ruler
# scope:target = ruler to copy language from
# scope:my_language_counties = counties in the AI's realm with a culture with their native language
# scope:their_language_counties = counties in the AI's realm with a culture with the target court language
# scope:total_counties = counties in the AI's realm
# See also the court_language_ai_score value
# scope:courts_with_language = how many royal courts use the same court language? Includes the target
# scope:checking_native_language = are we scoring our own language?
can_adopt_court_language = {
	in_diplomatic_range = scope:target
}


# Should AI for this character repair the artifact
# Before getting here in code we check: if Durability <= NInventory::ARTIFACT_LOW_DURABILITY, if Artifact is equipped, if Character can afford this
# root: character (Artifact Owner)
# scope:artifact: the artifact
ai_should_repair_artifact = {
	NOR = {
		root = {
			is_at_war = yes
		}
		scope:artifact = {
			artifact_slot_type = miscellaneous
		}
	}
}

# Can this character be a guest at any activity at all held by the host, checked in the UI and in the invite to activity special interaction type
# root = character
# scope:host = the activity host
can_be_activity_guest = {
	is_available_allow_travelling = yes
	OR = {
		is_travelling = no
		# If travelling then it must be already to this activity after it has been created
		AND = {
			exists = scope:host.involved_activity
			exists = current_travel_plan.travel_plan_activity
			scope:host.involved_activity = current_travel_plan.travel_plan_activity
		}
	}
	# Diarchs with official responsibilities can't come out to play, unless within their liege's realm.
	trigger_if = {
		limit = {
			exists = liege
			OR = {
				is_diarch = yes
				is_designated_diarch = yes
			}
			#If you have promised a grand wedding, you must be able to go through with it!
			NOR = {
				has_promised_a_grand_wedding = yes
				has_been_promised_grand_wedding = yes
			}
		}
		scope:host.involved_activity.activity_location.county.holder ?= {
			OR = {
				this = root.liege
				any_liege_or_above = { this = root.liege }
			}
		}
	}
}

# Is target character displayed as loyal diarch
# If both or neither loyal and disloyal, we show unknown loyalty
# root - Diarch or potential diarch character
is_diarch_visibly_loyal = {
	diarch_loyalty >= diarch_loyalty_visibly_loyal_threshold
}

# Is target character displayed as disloyal diarch
# If both or neither loyal and disloyal, we show unknown loyalty
# root - Diarch or potential diarch character
is_diarch_visibly_disloyal = {
	diarch_loyalty <= diarch_loyalty_visibly_disloyal_threshold
}

# Can the target diarch fulfil their diarch duties
# root - the diarch whos ability is being tested
is_diarch_able = { is_diarch_able_trigger = yes }

# Can target character even be considered serving as diarch, or are they
# completely unable to fulfil their diarch duties and should be replaced
# root - the diarch whos ability is being tested
is_diarch_valid = { is_diarch_valid_trigger = yes }

# If ruler should go into diarchy
# Used in code when people become landed or receive incapacitating traits
# root - the liege who is tested for diarchy
should_have_diarchy = {
	basic_eligible_for_diarchy_trigger = yes
	regency_for_personal_reasons_trigger = yes
}

# Does target character fulfil the basic requirements to be an Acclaimed Knight
# root - Acclaimed Knight, or potential candidate
can_be_acclaimed_knight = {
	is_knight = yes
	highest_held_title_tier <= tier_barony
}

# Can target character be considered a valuable hostage
# It's checked on an already taken hostages, so regular links to warden and home court
# can be used to check the relations between these 3 people
# root - hostage being evaluated
is_hostage_valid = {
	home_court = { is_landed = yes }
	warden = { is_landed = yes }
	OR = {
		is_child_of = home_court
		is_grandchild_of = home_court
		is_sibling_of = home_court
		is_nibling_of = home_court
		AND = {
			age < 16
			OR = {
				mother = { is_hostage_of = root.warden }
				father = { is_hostage_of = root.warden }
			}
		}
	}
}

# root = the character creating a legend
can_create_legend = {
	age >= 12
}

# root = the character promoting a legend
# scope:legend = the legend to promote
can_promote_legend = {
	is_landed = yes
	age >= 12
	custom_tooltip = {
		text = legend_can_not_promote_tt
		OR = {
			root.dynasty = scope:legend.legend_owner.dynasty
			knows_language_of_culture = scope:legend.legend_owner.culture
			scope:legend.legend_owner = {
				has_friendly_relationship_with_character_trigger = { CHARACTER = root }
			}
			any_character_to_title_neighboring_county = {
				any_county_province = {
					any_province_legend = {
						this = scope:legend
					}
				}
			}
			scope:legend.legend_owner = {
				knows_language_of_culture = root.culture
			}
		}
	}
}

# If the ai character wants to create their own legend as well as just supporting another one
# root = the character creating a legend
# scope:num_legends = The number of existing legends this character could support
ai_wants_to_create_own_legend = {
	is_independent_ruler = yes
	highest_held_title_tier >= tier_kingdom
	scope:num_legends <= 5
}

# If the powerful house is dominant
# It's evaluated only for powerful families that are not the current top liege
# root = the house being evaluated
is_dominant_family = {
	house_land_share_in_realm = {
		target = root.house_head.liege
		value >= dominant_family_threshold_value
	}
}

### Brief: is_hireable_ruler_trigger
# Can the scoped character be hired by another ruler in war? Referenced
# in code. Before this trigger is evaluated, code evaluates:
#	1. Root has a government
# 	2. Root's government is not mercenary company type specifically.
#	3. Root's government has the mercenary company government rule.
#	4. This scripted trigger.
#
# Code also checks if the character is available by looking at what 
# wars they are involved in, where root only will be available if they
# are not in a war already. 
#
# Supported scopes: 
#	root ( character )
#		Hireable ruler
#
is_hireable_ruler_trigger = {
	has_government = landless_adventurer_government
	current_military_strength >= 100
}

### Brief: can_hire_hireable_ruler_trigger
# Can the scoped ruler hire the target hireable ruler? Referenced in
# code. Use of this trigger assumes the hireable ruler already has 
# passed the is_hireable_ruler_trigger and they are not already 
# involved in a war.
#
# Supported scopes: 
#	root ( character ) 
#		Prospective employer
# 	scope:candidate ( character )
#		Hireable ruler
#
can_hire_hireable_ruler_trigger = {
 	# TODO_DESIGN: Replace with something appropriate
	is_at_war = yes
	any_character_war = {
		is_war_leader = root
	}
}

# Supported scopes: 
#	root ( province )
#		Destination province
#   scope:owner = the domicile owner
#
can_move_domicile = {
	trigger_if = {
		limit = { exists = county } #This will exclude sea provinces, impassable provinces, river provinces, etc
		save_temporary_scope_as = province_temp
		scope:owner.domicile ?= {
			# Estate
			trigger_if = {
				limit = { is_domicile_type = estate }
				# Cannot move estate outside top_liege realm
				scope:province_temp.county.holder.top_liege ?= {
					custom_tooltip = {
						text = can_move_domicile_estate_realm_tt
						this = scope:owner.top_liege
					}
				}
				# Cannot move estate during war impacting location or destination
				custom_tooltip = {
					text = can_move_domicile_estate_war_tt
					scope:owner.domicile.domicile_location.county.holder ?= {
						NOR = {
							is_at_war = yes
							any_liege_or_above = { is_at_war = yes }
						}
					}
					scope:province_temp.county.holder ?= {
						NOR = {
							is_at_war = yes
							any_liege_or_above = { is_at_war = yes }
						}
					}
				}
			}
			trigger_if = {
				limit = { is_domicile_type = camp }
				# Cannot move domicile to places you've been exiled from.
				custom_tooltip = {
					text = can_move_domicile_camp_exile.tt
					NOT = {
						is_laamp_exiled_from_province_trigger = {
							PROVINCE = scope:province_temp
							LAAMP = scope:owner
						}
					}
				}
				scope:owner = { has_raised_armies = no }
			}
		}
	}
	trigger_else = { exists = county } #This will exclude sea provinces, impassable provinces, river provinces, etc
}
