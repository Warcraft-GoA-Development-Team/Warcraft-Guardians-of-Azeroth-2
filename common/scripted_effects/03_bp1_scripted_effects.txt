##### FAMILY FEUD #####

### START EFFECTS ###

# Start Feud, set variables, modifiers, relations, and stress
house_feud_start_effect = {
	# Save scopes
	$ACTOR$.house.house_head = { save_scope_as = starter_house_head }
	$TARGET$.house.house_head = { save_scope_as = house_feud_rival }
	$ATTACKER$ = { save_scope_as = house_feud_attacker }
	$VICTIM$ = { save_scope_as = house_feud_victim }
	# Save target House for reference
	$ATTACKER$ = {
		set_variable = {
			name = house_feud_house
			value = $TARGET$.house
		}
	}
	# Explanatory Tooltips
	if = {
		limit = {
			NOT = {
				$TARGET$.house.house_head = {
					any_owned_story = {
						story_type = story_cycle_house_feud
						var:house_feud_house ?= root.house
					}
				}
			}
		}
		custom_tooltip = story_cycle_house_feud_tt
	}
	else = { custom_tooltip = story_cycle_house_feud_reciprocate_tt }
	# Relations: Nemesis if already Rivals, else Rival
	if = {
		limit = {
			has_relation_rival = $TARGET$.house.house_head
			NOT = { has_relation_nemesis = $TARGET$.house.house_head }
			can_set_relation_nemesis_trigger = { CHARACTER = $TARGET$.house.house_head }
		}
		set_relation_nemesis = {
			reason = nemesis_house_feud
			copy_reason = rival
			target = $TARGET$.house.house_head
		}
	}
	else_if = {
		limit = {
			NOT = { has_relation_rival = $TARGET$.house.house_head }
		}
		set_relation_rival = {
			target = $TARGET$.house.house_head
			reason = rival_house_feud_start_of_feud
		}
	}
	# Reduce opinion of Feud target if relevant
	if = {
		limit = { is_ai = no }
		add_opinion = {
			target = $TARGET$.house.house_head
			modifier = house_feud_opinion
		}
	}
	# Add House modifier and tooltip explaining Scheme bonus
	show_as_tooltip = {
		house = {
			add_house_modifier = { modifier = house_feud_story_modifier }
		}
	}
	# Stress
	stress_impact = { vengeful = minor_stress_impact_loss }
	house_feud_forgiving_stress_effect = yes
	# Create Story Cycle
	create_story = story_cycle_house_feud
	# Save reasons for reference
	random_owned_story = {
		limit = { story_type = story_cycle_house_feud }
		set_variable = house_feud_setup
		# Save Feud target House
		set_variable = { name = house_feud_house value = scope:house_feud_rival.house }
		# Save Feud rival
		set_variable = { name = house_feud_rival value = scope:house_feud_rival }
		# Save Feud attacker
		set_variable = { name = house_feud_attacker value = scope:house_feud_attacker }
		# Save Feud attacker
		set_variable = { name = house_feud_victim value = scope:house_feud_victim }
		# Save Feud starter
		set_variable = { name = house_feud_first_owner value = scope:starter_house_head }
		# Save first Feud target House Head
		set_variable = { name = house_feud_first_rival value = scope:house_feud_rival }
		# Save feud length counter
		set_variable = { name = house_feud_length_counter value = 0 }
		# Save feud death counter
		set_variable = { name = house_feud_death_counter value = 0 }
		# Save feud kill counter
		set_variable = { name = house_feud_kill_counter value = 0 }
		# Save start reason flavor
		set_variable = { name = house_feud_reason value = flag:$REASON$ }

		# Move starting death counter if relevant
		if = {
			limit = {
				OR = {
					var:house_feud_reason = flag:head_killed
					var:house_feud_reason = flag:family_killed					
				}
			}
			change_variable = {
				name = house_feud_death_counter
				add = house_feud_medium_counter_value
			}
		}
		else_if = {
			limit = {
				OR = {
					var:house_feud_reason = flag:head_cuckolded
					var:house_feud_reason = flag:family_cuckolded
				}
			}
			change_variable = {
				name = house_feud_death_counter
				add = house_feud_small_counter_value
			}
		}
		# Save title for flavor if relevant
		else_if = {
			limit = { var:house_feud_reason = flag:competing_claim }
			if = {
				limit = {
					NOT = { exists = scope:house_feud_claim }
				}
				scope:house_feud_victim = {
					ordered_claim = {
						limit = {
							any_claimant = { this = scope:house_feud_attacker }
						}
						order_by = tier
						save_scope_as = house_feud_claim
					}
				}
			}
			set_variable = { name = house_feud_title value = scope:house_feud_claim }
		}
		# Granular torture reasons if revelant
		else_if = {
			limit = { var:house_feud_reason = flag:head_tortured }
			if = {
				limit = {
					scope:house_feud_victim = { has_character_flag = house_feud_blinding_flag }
				}
				set_variable = { name = house_feud_reason value = flag:head_blinded }
			}
			else_if = {
				limit = {
					scope:house_feud_victim = { has_character_flag = house_feud_castration_flag }
				}
				set_variable = { name = house_feud_reason value = flag:head_castrated }
			}
		}
		else_if = {
			limit = { var:house_feud_reason = flag:family_tortured }
			if = {
				limit = {
					scope:house_feud_victim = { has_character_flag = house_feud_blinding_flag }
				}
				set_variable = { name = house_feud_reason value = flag:family_blinded }
			}
			else_if = {
				limit = {
					scope:house_feud_victim = { has_character_flag = house_feud_castration_flag }
				}
				set_variable = { name = house_feud_reason value = flag:family_castrated }
			}
		}
		# Save cuckold spouse if relevant
		else_if = {
			limit = { var:house_feud_reason = flag:head_cuckolded }
			if = {
				limit = {
					NOT = { exists = scope:house_feud_spouse }
				}
				scope:house_feud_victim = {
					random_spouse = { save_scope_as = house_feud_spouse }
				}
			}
			set_variable = { name = house_feud_spouse value = scope:house_feud_spouse }
		}
		# Set house betrothal broken reason if relevant
		else_if = {
			limit = { var:house_feud_reason = flag:family_broke_gw_betrothal }
			if = {
				limit = { scope:starter_house_head = scope:house_feud_victim }
				set_variable = { name = house_feud_reason value = flag:head_broke_gw_betrothal }
			}
		}
		save_scope_as = story
		# Invalidate exit
		if = {
			limit = {
				OR = {
					NOT = { exists = var:house_feud_house }
					NOT = { exists = var:house_feud_first_owner }
					NOT = { exists = var:house_feud_first_rival }
					NOT = { exists = var:house_feud_length_counter }
					NOT = { exists = var:house_feud_death_counter }
					NOT = { exists = var:house_feud_kill_counter }
					NOT = { exists = var:house_feud_reason }
				}
			}
			# Variable is missing! Ending story prematurely.
			debug_log = "House Feud invalidated"
			debug_log_scopes = yes
			end_story = yes
		}
		house_feud_memory_effect = yes
		# Inform House Members feud has started
		story_owner.house = {
			every_house_member = {
				limit = { is_ai = no }
				send_interface_message = {
					type = house_feud_begins_message
					left_icon = scope:story.story_owner
					right_icon = scope:story.var:house_feud_rival
					show_as_tooltip = {
						house.house_head = { set_relation_rival = scope:story.var:house_feud_rival } #Show as tooltip does not require a reason
					}
				} 
				trigger_event = {
					id = bp1_house_feud.0600
					days = 5
				}
			}
		}
		story_owner = {
			add_character_flag = had_house_feud_story
			house = {
				add_house_modifier = {
					modifier = house_feud_story_modifier
					desc = house_feud_story_modifier_custom_desc
				}
			}
		}
		# Chance to inform target House Head, who can reciprocate
		story_owner = { save_scope_as = house_feud_attacker }
		var:house_feud_house.house_head = {
			trigger_event = {
				id = bp1_house_feud.0501
				months = { 1 2 }
			}
		}
		remove_variable = house_feud_setup
	}
}

### END EFFECTS ###

# End current Feud
house_feud_end_story_effect = {
	# Explanatory tooltip
	custom_tooltip = house_feud_end_tt
	# End Story Cycle
	random_owned_story = {
		limit = { story_type = story_cycle_house_feud }
		end_story = yes
	}
}

# Clear up and set modifiers based on Feud score or fallback
house_feud_end_modifier_effect = {
	if = {
		limit = {
			NOT = { exists = scope:story }
			exists = house.house_head
			house.house_head = {
				any_owned_story = { story_type = story_cycle_house_feud }
			}
		}
		house.house_head = {
			random_owned_story = {
				limit = { story_type = story_cycle_house_feud }
				save_scope_as = story
			}
		}
	}
	if = {
		limit = { exists = scope:story }
		scope:story = {
			if = {
				limit = { exists = var:house_feud_house.house_head }
				var:house_feud_house.house_head = { save_scope_as = house_feud_rival }
			}
			if = {
				limit = {
					exists = scope:house_feud_rival
					scope:house_feud_rival = { is_alive = yes }
				}
				story_owner = {
					# Remove Nemesis when ending Feud if relevant
					if = {
						limit = { has_relation_nemesis = scope:house_feud_rival }
						hidden_effect = { remove_relation_nemesis = scope:house_feud_rival }
						set_relation_rival = {
							target = scope:house_feud_rival
							reason = rival_house_feud_no_longer_nemesis
						}
					}
					# Otherwise remove Rival
					else_if = {
						limit = { has_relation_rival = scope:house_feud_rival }
						remove_relation_rival = scope:house_feud_rival
					}
					house = {
						every_house_member = {
							limit = { is_ai = yes }
							if = {
								limit = { has_relation_nemesis = scope:house_feud_rival }
								hidden_effect = { remove_relation_nemesis = scope:house_feud_rival }
								set_relation_rival = {
									target = scope:house_feud_rival
									reason = rival_house_feud_no_longer_nemesis
								}
							}
							# Otherwise remove Rival
							else_if = {
								limit = { has_relation_rival = scope:house_feud_rival }
								remove_relation_rival = scope:house_feud_rival
							}
						}
					}
				}
			}
			story_owner.house = {
				if = {
					limit = { has_house_modifier = house_feud_terrible_modifier }
					remove_house_modifier = house_feud_terrible_modifier
				}
				if = {
					limit = { has_house_modifier = house_feud_bad_modifier }
					remove_house_modifier = house_feud_bad_modifier
				}
				if = {
					limit = { has_house_modifier = house_feud_even_modifier }
					remove_house_modifier = house_feud_even_modifier
				}
				if = {
					limit = { has_house_modifier = house_feud_good_modifier }
					remove_house_modifier = house_feud_good_modifier
				}
				if = {
					limit = { has_house_modifier = house_feud_excellent_modifier }
					remove_house_modifier = house_feud_excellent_modifier
				}
			}
			if = {
				limit = {
					exists = var:house_feud_death_counter
					exists = var:house_feud_kill_counter
				}
				# Reward modifiers based on score
				# If losing badly, worst modifier
				if = {
					limit = { house_feud_balance_value <= -3 }
					story_owner.house = {
						add_house_modifier = {
							modifier = house_feud_terrible_modifier
							years = 25
							desc = house_feud_terrible_modifier_custom_desc
						}
					}
				}
				# If losing, bad modifier
				else_if = {
					limit = { house_feud_balance_value < -0.5 }
					story_owner.house = {
						add_house_modifier = {
							modifier = house_feud_bad_modifier
							years = 25
							desc = house_feud_bad_modifier_custom_desc
						}
					}
				}
				# If similar, average modifier
				else_if = {
					limit = {
						house_feud_balance_value >= -0.5
						house_feud_balance_value <= 0.5
					}
					story_owner.house = {
						add_house_modifier = {
							modifier = house_feud_even_modifier
							years = 25
							desc = house_feud_even_modifier_custom_desc
						}
					}
				}
				# If winning, decent modifier
				else_if = {
					limit = {
						house_feud_balance_value > 0.5
						house_feud_balance_value < 3
					}
					story_owner.house = {
						add_house_modifier = {
							modifier = house_feud_good_modifier
							years = 25
							desc = house_feud_good_modifier_custom_desc
						}
					}
				}
				# If winning alot, good modifier
				else = {
					limit = { house_feud_balance_value >= 3 }
					story_owner.house = {
						add_house_modifier = {
							modifier = house_feud_excellent_modifier
							years = 25
							desc = house_feud_excellent_modifier_custom_desc
						}
					}
				}
				story_owner.house = {
					custom_tooltip = house_reward_modifier_tt
				}
			}
			# Give good modifier as fallback or if Feud targets were wiped out
			else = {
				story_owner.house = {
					add_house_modifier = {
						modifier = house_feud_excellent_modifier
						years = 25
						desc = house_feud_excellent_modifier_custom_desc
					}
				}
			}
			# Remove ongoing modifier
			story_owner.house = { remove_house_modifier = house_feud_story_modifier }
		}
	}
	custom_tooltip = house_feud_cooldown_tt
}

# Shared stress effect for Vengeful characters
house_feud_vengeful_stress_effect = {
	stress_impact = {
		vengeful = major_stress_impact_gain
		arbitrary = medium_stress_impact_gain
		wrathful = minor_stress_impact_gain
		brave = minor_stress_impact_gain
		ambitious = minor_stress_impact_gain
		arrogant = minor_stress_impact_gain
	}
}

house_feud_forgiving_stress_effect = {
	stress_impact = {
		forgiving = major_stress_impact_gain
		just = medium_stress_impact_gain
		calm = minor_stress_impact_gain
		craven = minor_stress_impact_gain
		content = minor_stress_impact_gain
		humble = minor_stress_impact_gain
	}
}

### TRANSFER EFFECTS ###

# Swap Feud target to another House
house_feud_swap_feud_effect = {
	custom_tooltip = swap_feud_tt
	# Set flag to prevent swapping too often
	set_variable = {
		name = house_feud_swapped_house
		years = 15
		value = scope:house_feud_existing
	}
	# End existing Feud
	random_owned_story = {
		limit = { story_type = story_cycle_house_feud }
		end_story = yes
	}
	# Start new Feud
	house_feud_start_effect = {
		# Feuding House Head
		ACTOR = $ACTOR$
		# Target House Head
		TARGET = $TARGET$
		# Feud Reason
		REASON = $REASON$
		# House Member attacker if relevant
		ATTACKER = $ATTACKER$
		# House Member victim if relevant
		VICTIM = $VICTIM$
	}
}

# Transfer the story to another character, used on inheritance
transfer_house_feud_story_cycle_to_effect = {
	$STORY$ = {
		# Set story owner
		make_story_owner = $CHARACTER$
		# Inform player members Feud was inherited
		var:house_feud_house = {
			every_house_member = {
				limit = { is_ai = no }
				hidden_effect = {
					send_interface_message = {
						type = house_feud_continues_message
						left_icon = $CHARACTER$
						right_icon = $STORY$.var:house_feud_house.house_head
					}
				}
			}
		}
		# Save story scope for reference
		save_scope_as = house_feud_story
	}

	$CHARACTER$ = {
		# Set flag to fire event on 10th birthday if too young
		if = {
			limit = { age < 9 }
			add_character_flag = house_feud_too_young_inheritor
		}
		# Fire immediately if at least 9 and no pre-existing rivalry exists
		else_if = {
			limit = {
				NOT = { scope:old_house_head.killer.house = scope:house_feud_rival.house }
				NOT = {
					has_any_bad_relationship_with_character_trigger = { CHARACTER = scope:house_feud_rival }
				}
				can_set_relation_rival_trigger = { CHARACTER = scope:house_feud_rival }
			}
			trigger_event = {
				id = bp1_house_feud.0810
				days = 10
			}
		}
		# Fallback continuation without event
		else = { house_feud_send_continues_message_effect = yes }
	}
}

### SCOPE EFFECTS ###

# Save attacker and rival scopes for reference
house_feud_save_head_and_attacker_effect = {
	house.house_head = { save_scope_as = house_feud_rival }
	save_scope_as = house_feud_attacker
}

house_feud_memory_effect = {
	save_scope_as = story
	story_owner = {
		create_character_memory = {
	        type = house_feud_started_memory
	        participants = {
	            house_head = scope:house_feud_rival
	            attacker = scope:story.var:house_feud_attacker
	            victim = scope:story.var:house_feud_victim
	        }
	    }
		ordered_memory = {
	    	limit = {
	    		has_memory_type = house_feud_started_memory
	        	any_memory_participant = { this = scope:house_feud_rival }
	        }
	        order_by = memory_creation_date
	    	set_variable = {
				name = house_feud_reason
				value = scope:story.var:house_feud_reason
			}
			if = {
				limit = { exists = scope:story.var:house_feud_title }
				set_variable = {
					name = house_feud_title
					value = scope:story.var:house_feud_title
				}
			}
			if = {
				limit = { exists = scope:story.var:house_feud_spouse }
				set_variable = {
					name = house_feud_spouse
					value = scope:story.var:house_feud_spouse
				}
			}
	    }
	}
}

# Save targeting Feud scope for reference
save_targeting_house_feud_story_effect = {
	if = {
		limit = {
			$RIVAL$ = {
				existing_feud_against_target_trigger = { TARGET = $SELF$ }
			}
		}
		$RIVAL$.house.house_head = {
			random_owned_story = {
				limit = { story_type = story_cycle_house_feud }
				save_scope_as = other_house_feud_story
			}
		}
	}
}

# Save existing Feud for cases where Feud can optionally be swapped to another House
house_feud_existing_feud_effect = {
	if = {
		limit = {
			any_owned_story = {
				story_type = story_cycle_house_feud
				exists = var:house_feud_house
				NOT = { var:house_feud_house = scope:house_feud_attacker.house }
			}
			NOT = {
				existing_feud_against_target_trigger = { TARGET = scope:house_feud_attacker }
			}
		}
		random_owned_story = {
			limit = {
				story_type = story_cycle_house_feud
				exists = var:house_feud_house
				NOT = { var:house_feud_house = scope:house_feud_attacker.house }
			}
			var:house_feud_house = { save_scope_as = house_feud_existing }
		}
	}
}

### MESSAGE EFFECTS ###

# Send Feud continued message to player House members on inheritance
house_feud_send_continues_message_effect = {
	# Flag to block starting more than one Feud per lifetime in most cases (House Head cuckoldry and torture are exceptions)
	add_character_flag = had_house_feud_story
	house = {
		every_house_member = {
			limit = { is_ai = no }
			hidden_effect = {
				send_interface_message = {
					type = house_feud_continues_message
					left_icon = root
					right_icon = scope:house_feud_rival
					title = msg_house_feud_continues
					desc = msg_house_feud_continues_desc
				}
			}
		}
	}
}

### ACTION EFFECTS ###

# Feud cuckoldry score and event effects
house_feud_lover_exposure_effect = {
	hidden_effect = {
		if = {
			limit = {
				is_married = yes
				any_spouse = {
					house.house_head ?= {
						house_head_can_start_feud_against_trigger = { TARGET = scope:sex_partner }
					}
				}
			}
			# Save cheating spouse scope for reference
			save_scope_as = house_feud_spouse
			# Save cuckolder's scopes for reference
			scope:sex_partner = { house_feud_save_head_and_attacker_effect = yes }
			every_spouse = {
				limit = {
					house.house_head ?= {
						house_head_can_start_feud_against_trigger = { TARGET = scope:sex_partner }
					}
				}
				# Save cuckolded spouse for reference
				save_scope_as = house_feud_victim
				house.house_head = {
					# Chance for House Head to have option to start Feud
					random = {
						chance = 75
						modifier = {
							add = 25
							has_trait = vengeful
						}
						modifier = {
							add = -25
							has_trait = forgiving
						}
						modifier = {
							add = -25
							has_any_bad_relationship_with_character_trigger = { CHARACTER = scope:sex_partner }
						}
						# House Head version
						if = {
							limit = { is_spouse_of = scope:house_feud_spouse }
							trigger_event = {
								id = bp1_house_feud.0013
								days = { 5 15 }
							}
						}
						# Close family version
						else = {
							trigger_event = {
								id = bp1_house_feud.0014
								days = { 5 15 }
							}
						}
					}
				}
			}
		}
		# Cuckolded House score and message effects
		if = {
			limit = {
				exists = scope:sex_partner.house
				any_spouse = {
					existing_feud_against_target_trigger = { TARGET = scope:sex_partner }
				}
			}
			every_spouse = {
				limit = {
					existing_feud_against_target_trigger = { TARGET = scope:sex_partner }
				}
				save_temporary_scope_as = house_feud_cuckolded_temp
				house = {
					house_head = {
						random_owned_story = {
							limit = { story_type = story_cycle_house_feud }
							# Decrease score
							change_variable = {
								name = house_feud_death_counter
								add = house_feud_small_counter_value
							}
						}
					}
					# Inform House player members of score loss
					every_house_member = {
						limit = { is_ai = no }
						send_interface_message = {
							type = house_feud_cuckolded_us_message
							left_icon = scope:house_feud_cuckolded_temp
							right_icon = scope:sex_partner
							custom_tooltip = house_feud_tipped_scales_neg_small
						}
					}
				}
			}
		}
		# Cuckolding House score and message effects
		if = {
			limit = {
				exists = scope:sex_partner.house.house_head
				any_spouse = {
					save_temporary_scope_as = house_feud_cuckolded_temp
					scope:sex_partner = {
						existing_feud_against_target_trigger = { TARGET = scope:house_feud_cuckolded_temp }
					}
				}
			}
			random_spouse = {
				limit = {
					save_temporary_scope_as = house_feud_cuckolded_temp
					scope:sex_partner = {
						existing_feud_against_target_trigger = { TARGET = scope:house_feud_cuckolded_temp }
					}
				}
				# Save cuckolded scope for reference
				save_scope_as = house_feud_cuckolded
			}
			scope:sex_partner.house = {
				house_head = {
					random_owned_story = {
						limit = { story_type = story_cycle_house_feud }
						# Increase score
						change_variable = {
							name = house_feud_kill_counter
							add = house_feud_small_counter_value
						}
					}
				}
				# Inform House player members of score gain 
				every_house_member = {
					limit = { is_ai = no }
					send_interface_message = {
						type = house_feud_cuckolded_them_message
						left_icon = scope:sex_partner
						right_icon = scope:house_feud_cuckolded
						custom_tooltip = house_feud_tipped_scales_pos_small
					}
				}
				# If originial Feud reason was cuckolding, fire revenge event for House Head
				house_head = {
					if = {
						limit = {
							any_owned_story = {
								story_type = story_cycle_house_feud
								OR = {
									var:house_feud_reason = flag:head_cuckolded
									var:house_feud_reason = flag:family_cuckolded
								}
								var:house_feud_attacker = scope:house_feud_cuckolded
							}
						}
						trigger_event = { id = bp1_house_feud.7003 days = 15 }
					}
				}
			}
		}
	}
}

# Feud torture score and event effects
house_feud_torture_event_effect = {
	hidden_effect = {
		# Tortured belongs to torturer's Houses's Feud target House
		if = {
			limit = {
				scope:actor = {
					existing_feud_against_target_trigger = { TARGET = scope:recipient }
				}
			}
			scope:actor.house = {
				house_head = {
					random_owned_story = {
						limit = { story_type = story_cycle_house_feud }
						# Save Feud for reference
						save_scope_as = house_feud_story
						# Add score to torturer's feud
						change_variable = {
							name = house_feud_kill_counter
							add = house_feud_small_counter_value
						}
					}
				}
				# Informed player members score of House score increase
				every_house_member = {
					limit = { is_ai = no }
					send_interface_message = {
						type = house_feud_torture_them_message
						left_icon = scope:actor
						right_icon = scope:recipient
						title = msg_house_feud_torture_them
						desc = msg_house_feud_torture_them_desc
						show_as_tooltip = {
							scope:recipient = { 
								if = {
									limit = { has_character_flag = house_feud_castration_flag }
									add_trait = eunuch
								}
								else_if = {
									limit = { has_character_flag = house_feud_blinding_flag }
									add_trait = blind
								}
							}
						}
						custom_tooltip = house_feud_tipped_scales_pos_small
					}
				}
			}
			# If originial Feud reason was Torture, fire revenge event for House Head
			if = {
				limit = {
					scope:actor.house.house_head = {
						any_owned_story = {
							story_type = story_cycle_house_feud
							OR = {
								var:house_feud_reason = flag:head_tortured
								var:house_feud_reason = flag:family_tortured
								var:house_feud_reason = flag:head_blinded
								var:house_feud_reason = flag:family_blinded
								var:house_feud_reason = flag:head_castrated
								var:house_feud_reason = flag:family_castrated
							}
							var:house_feud_attacker = scope:recipient
						}
					}
				}
				scope:actor.house.house_head = {
					trigger_event = { id = bp1_house_feud.7002 days = 15 }
				}
			}
		}
		# Torturer belongs to tortured's House's Feud target House
		if = {
			limit = {
				scope:recipient = {
					existing_feud_against_target_trigger = { TARGET = scope:actor }
				}
			}
			scope:recipient.house = {
				house_head = {
					random_owned_story = {
						limit = { story_type = story_cycle_house_feud }
						# Save story scope for reference
						save_scope_as = house_feud_story
						# Remove score from tortured's Feud
						change_variable = {
							name = house_feud_death_counter
							add = house_feud_small_counter_value
						}
					}
				}
				# Inform player members of House score decrease
				every_house_member = {
					limit = { is_ai = no }
					send_interface_message = {
						type = house_feud_torture_us_message
						left_icon = scope:recipient
						right_icon = scope:actor
						show_as_tooltip = {
							scope:recipient = { 
								if = {
									limit = { has_character_flag = house_feud_castration_flag }
									add_trait = eunuch
								}
								else_if = {
									limit = { has_character_flag = house_feud_blinding_flag }
									add_trait = blind
								}
							}
						}
						custom_tooltip = house_feud_tipped_scales_neg_small
					}
				}
			}
		}
		# Chance for tortured House to start a Feud if eligible
		if = {
			limit = {
				scope:recipient.house.house_head ?= {
					house_head_can_start_feud_against_trigger = { TARGET = scope:actor }
				}
			}
			random_list = {
				# Give House Head option to start Feud
				25 = {
					modifier = {
						add = 25
						house.house_head = { has_trait = vengeful }
					}
					modifier = {
						add = -25
						house.house_head = { has_trait = forgiving }
					}
					scope:actor = { house_feud_save_head_and_attacker_effect = yes }
					scope:recipient = {
						save_scope_as = house_feud_victim
						house.house_head = {
							if = {
								limit = { this = scope:house_feud_victim }
								trigger_event = {
									id = bp1_house_feud.0010 # Version for tortured House Heads
									days = { 5 15 }
								}
							}
							else = {
								trigger_event = {
									id = bp1_house_feud.0011 # Version for tortured close family
									days = { 5 15 }
								}
							}
						}
					}
				}
				# Clean up tortured's flags if no Feud started
				50 = {
					if = {
						limit = { has_character_flag = house_feud_castration_flag }
						remove_character_flag = house_feud_castration_flag
					}
					else_if = {
						limit = { has_character_flag = house_feud_blinding_flag }
						remove_character_flag = house_feud_blinding_flag
					}
				}
			}
		}
	}
}

set_war_memory_casus_belli_effect = {
	save_scope_as = memory
	scope:war = {
		casus_belli = {
			if = {
				limit = {
					any_target_title = { count >= 1 }
				}
				ordered_target_title = {
					order_by = tier
					save_scope_as = war_target
				}
				scope:memory = {
					set_variable = { name = war_title value = scope:war_target }
				}
			}
			if = {
				limit = { exists = claimant }
				claimant = { save_scope_as = war_claimant }
				scope:memory = {
					set_variable = { name = war_claimant value = scope:war_claimant }
				}
			}
		}
		scope:memory = {
			set_variable = {
				name = war_attacker
				value = scope:war.primary_attacker
			}
		}
		if = { # claim
			limit = {
				OR = {
					using_cb = claim_cb
					using_cb = claimant_faction_war
				}
			}
			scope:memory = {
				set_variable = { name = war_cb value = flag:war_memory_cb_claim }
			}
		}	
		else_if = { # conquest
			limit = {
				OR = {
					using_cb = county_conquest_cb
					using_cb = duchy_conquest_cb
					using_cb = county_struggle_cb
					#using_cb = fp2_mediterranean_conquest_cb
				}
			}
			scope:memory = {
				set_variable = { name = war_cb value = flag:war_memory_cb_conquest }
			}
		}
		else_if = { # holy
			limit = {
				OR = {
					using_cb = minor_religious_war
					using_cb = religious_war
					using_cb = major_religious_war
				}
			}
			scope:memory = {
				set_variable = { name = war_cb value = flag:war_memory_cb_holy_war }
				set_variable = { name = war_faith value = scope:war.primary_defender.faith }
				set_variable = { name = war_faith_attacker value = scope:war.primary_attacker.faith }
			}
		}
		else_if = { # de jure
			limit = {
				OR = {
					using_cb = de_jure_cb
					using_cb = individual_county_de_jure_cb
					using_cb = individual_duchy_de_jure_cb
				}
			}
			scope:memory = {
				set_variable = { name = war_cb value = flag:war_memory_cb_de_jure }
				scope:war_target = {
					ordered_this_title_or_de_jure_above = {
						limit = { holder.top_liege = scope:war.primary_attacker }
						order_by = tier
						save_scope_as = war_liege
					}
				}
				if = {
					limit = { exists = scope:war_liege }
					set_variable = { name = war_liege value = scope:war_liege }
				}
			}
		}
		else_if = { # invasion
			limit = {
				OR = {
					using_cb = invasion_war
					using_cb = clan_invasion_war
					using_cb = mongol_invasion_war
					using_cb = mongol_realm_invasion_war
				}
			}
			scope:memory = {
				set_variable = { name = war_cb value = flag:war_memory_cb_invasion }
			}
		}
		else_if = { # ghw
			limit = {
				OR = {
					using_cb = undirected_great_holy_war
					using_cb = directed_great_holy_war
				}
			}
			scope:memory = {
				set_variable = { name = war_cb value = flag:war_memory_cb_ghw }
				set_variable = { name = war_faith value = scope:war.primary_defender.faith }
				set_variable = { name = war_faith_attacker value = scope:war.primary_attacker.faith }
			}
		}
		else_if = { # independence
			limit = {
				OR = {
					using_cb = independence_war
					using_cb = independence_faction_war
				}
			}
			scope:memory = {
				set_variable = { name = war_cb value = flag:war_memory_cb_independence }
			}
		}
		else_if = {
			limit = {
				OR = {
					using_cb = artifact_war
					using_cb = reclaim_relic_artifact_war
				}
			}
			scope:memory = {
				set_variable = { name = war_cb value = flag:war_memory_cb_artifact }
			}
		}
		else_if = {
			limit = { using_cb = populist_war }
			scope:memory = {
				set_variable = { name = war_cb value = flag:war_memory_cb_populist }
				set_variable = { name = war_faith value = scope:war.primary_defender.faith }
				set_variable = { name = war_culture value = scope:war.primary_defender.culture }
			}
		}
		else = {
			switch = {
				trigger = using_cb
				liberty_faction_war = { # liberty
					scope:memory = {
						set_variable = { name = war_cb value = flag:war_memory_cb_liberty }
					}
				}
				depose_war = { # depose
					scope:memory = {
						set_variable = { name = war_cb value = flag:war_memory_cb_depose }
					}
				}
				refused_liege_demand_war = { # tyranny
					scope:memory = {
						set_variable = { name = war_cb value = flag:war_memory_cb_tyranny }
					}
				}
				nation_fracturing_faction_war = { # fracture
					scope:memory = {
						set_variable = { name = war_cb value = flag:war_memory_cb_fracture }
					}
				}
				ducal_conquest_cb = { # ducal conquest
					scope:memory = {
						set_variable = { name = war_cb value = flag:war_memory_cb_ducal_conquest }
					}
				}
				# Warcraft 
				#imperial_reconquest_cb = { # imperial reconquest
				#	scope:memory = {
				#		set_variable = { name = war_cb value = flag:war_memory_cb_imperial_reconquest }
				#	}
				#}
				#dismantle_holy_pretender_cb = { # holy pretender
				#	scope:memory = {
				#		set_variable = { name = war_cb value = flag:war_memory_cb_holy_pretender }
				#	}
				#}
				#dismantle_byz_pretender_cb = { # byz pretender
				#	scope:memory = {
				#		set_variable = { name = war_cb value = flag:war_memory_cb_byz_pretender }
				#	}
				#}
				excommunication_war = { # excommunicate
					scope:memory = {
						set_variable = { name = war_cb value = flag:war_memory_cb_excommunicate }
					}
				}
				flowery_war_cb = { # flower
					scope:memory = {
						set_variable = { name = war_cb value = flag:war_memory_cb_flower }
					}
				}
				tribal_subjugation_cb = {
					scope:memory = {
						set_variable = { name = war_cb value = flag:war_memory_cb_subjugation }
					}
				}
				vassalization_cb = {
					scope:memory = {
						set_variable = { name = war_cb value = flag:war_memory_cb_vassalization }
					}
				}				
				fp1_varangian_adventurer_conquest = {
					scope:memory = {
						set_variable = { name = war_cb value = flag:war_memory_cb_varangian }
					}
				}
				fp1_scandi_adventurer_conquest = {
					scope:memory = {
						set_variable = { name = war_cb value = flag:war_memory_cb_varangian }
					}
				}
				# Warcraft 
				#fp2_border_raid = {
				#	scope:memory = {
				#		set_variable = { name = war_cb value = flag:war_memory_cb_border }
				#	}
				#}
				#fp2_expel_interloper = {
				#	scope:memory = {
				#		set_variable = { name = war_cb value = flag:war_memory_cb_expel }
				#	}
				#}
				diarch_vassalisation_cb = {
					scope:memory = {
						set_variable = { name = war_cb value = flag:war_memory_cb_vassalization }
					}
				}
				remove_regent_cb = {
					scope:memory = {
						set_variable = { name = war_cb value = flag:war_memory_cb_regent }
					}
				}
				# Warcraft 
				#norman_conquest_cb = {
				#	scope:memory = {
				#		set_variable = { name = war_cb value = flag:war_memory_cb_claim }
				#	}
				#}
				#norwegian_invasion_cb = {
				#	scope:memory = {
				#		set_variable = { name = war_cb value = flag:war_memory_cb_claim }
				#	}
				#}
				#hungarian_migration_cb = {
				#	scope:memory = {
				#		set_variable = { name = war_cb value = flag:war_memory_cb_invasion }
				#	}
				#}
				#sons_of_lothbrok_invasion_cb = {
				#	scope:memory = {
				#		set_variable = { name = war_cb value = flag:war_memory_cb_invasion }
				#	}
				#}
				peasant_war = {
					scope:memory = {
						set_variable = { name = war_cb value = flag:war_memory_cb_peasant }
					}
				}
				fallback = {
					scope:memory = {
						set_variable = { name = war_cb value = flag:war_memory_cb_fallback }
					}
				}
			}
		}
	}
	if = { # Error culler
		limit = {
			exists = scope:memory.var:war_cb
			OR = {
				# Warcraft - remove some irrelevant flags
				scope:memory.var:war_cb = flag:war_memory_cb_fallback
				scope:memory.var:war_cb = flag:war_memory_cb_holy_war
				#scope:memory.var:war_cb = flag:war_memory_cb_imperial_reconquest
				scope:memory.var:war_cb = flag:war_memory_cb_conquest
				scope:memory.var:war_cb = flag:war_memory_cb_claim
				scope:memory.var:war_cb = flag:war_memory_cb_de_jure
				scope:memory.var:war_cb = flag:war_memory_cb_ducal_conquest
				#scope:memory.var:war_cb = flag:war_memory_cb_holy_pretender
				#scope:memory.var:war_cb = flag:war_memory_cb_byz_pretender
				scope:memory.var:war_cb = flag:war_memory_cb_invasion
				scope:memory.var:war_cb = flag:war_memory_cb_independence
				scope:memory.var:war_cb = flag:war_memory_cb_liberty
				scope:memory.var:war_cb = flag:war_memory_cb_depose
				scope:memory.var:war_cb = flag:war_memory_cb_fracture
				scope:memory.var:war_cb = flag:war_memory_cb_excommunicate
				scope:memory.var:war_cb = flag:war_memory_cb_flower
				scope:memory.var:war_cb = flag:war_memory_cb_ghw
				scope:memory.var:war_cb = flag:war_memory_cb_artifact
				scope:memory.var:war_cb = flag:war_memory_cb_subjugation
				scope:memory.var:war_cb = flag:war_memory_cb_vassalization
				scope:memory.var:war_cb = flag:war_memory_cb_varangian
				#scope:memory.var:war_cb = flag:war_memory_cb_border
				#scope:memory.var:war_cb = flag:war_memory_cb_expel
				scope:memory.var:war_cb = flag:war_memory_cb_regent
				scope:memory.var:war_cb = flag:war_memory_cb_tyranny
			}
		}
	}
}

copy_war_memory_casus_belli_effect = {
	if = {
		limit = { exists = $MEMORY$.var:war_cb }
		set_variable = {
			name = war_cb
			value = $MEMORY$.var:war_cb
		}
		if = {
			limit = { exists = $MEMORY$.var:war_attacker }
			set_variable = {
				name = war_attacker
				value = $MEMORY$.var:war_attacker
			}
		}
		if = {
			limit = { exists = $MEMORY$.var:war_title }
			set_variable = {
				name = war_title
				value = $MEMORY$.var:war_title
			}
		}
		if = {
			limit = { exists = $MEMORY$.var:war_claimant }
			set_variable = {
				name = war_claimant
				value = $MEMORY$.var:war_claimant
			}
		}
		if = {
			limit = { exists = $MEMORY$.var:war_faith }
			set_variable = {
				name = war_faith
				value = $MEMORY$.var:war_faith
			}
		}
		if = {
			limit = { exists = $MEMORY$.var:war_culture }
			set_variable = {
				name = war_culture
				value = $MEMORY$.var:war_culture
			}
		}
		if = {
			limit = { exists = $MEMORY$.var:war_faith_attacker }
			set_variable = {
				name = war_faith_attacker
				value = $MEMORY$.var:war_faith_attacker
			}
		}
		if = {
			limit = { exists = $MEMORY$.var:war_liege }
			set_variable = {
				name = war_liege
				value = $MEMORY$.var:war_liege
			}
		}
	}
	else = {
		set_variable = {
			name = war_cb
			value = flag:war_memory_cb_fallback
		}
	}
}

set_war_over_memory_casus_belli_effect = {
	ordered_memory = {
		limit = {
			has_memory_type = $STANCE$_war
			any_memory_participant = { this = scope:$OTHER$ }
		}
		order_by = memory_creation_date 
		save_scope_as = war_memory
	}
	ordered_memory = {
		limit = {
			has_memory_type = war_$OUTCOME$
			any_memory_participant = { this = scope:$SELF$ }
			any_memory_participant = { this = scope:$OTHER$ }		
		}
		order_by = memory_creation_date 
		copy_war_memory_casus_belli_effect = { MEMORY = scope:war_memory }
	}
}

house_feud_murder_effect = {
	if = {
		limit = {
			has_bp1_dlc_trigger = yes
			exists = $VICTIM$.house.house_head
			exists = $MURDERER$.house.house_head
		}
		# Notifications
		# Inform victim house that they have lost score
		if = {
			limit = {
				# Victim's House is targeted by killer's House
				$VICTIM$ = {
					existing_feud_against_target_trigger = { TARGET = $MURDERER$ }
				}
			}
			$VICTIM$.house = {
				house_head = {
					random_owned_story = {
						limit = { story_type = story_cycle_house_feud }
						save_scope_as = house_feud_story
						change_variable = {
							name = house_feud_death_counter
							add = house_feud_medium_counter_value
						}
                        if = {
                            limit = {
                                NOT = { has_variable = house_feud_recent_death }
                            }
                            set_variable = {
                                name = house_feud_recent_death
                                value = $VICTIM$
                                months = 6
                            }
                        }
					}
				}
				every_house_member = {
					limit = { is_ai = no }
					send_interface_message = {
						type = house_feud_kill_us_message
						left_icon = $VICTIM$
						right_icon = $MURDERER$
						custom_tooltip = house_feud_tipped_scales_neg_medium
					}
				}
			}
		}
		if = {
			limit = {
				# Victim's House is targeted by killer's House
				$MURDERER$ = {
					existing_feud_against_target_trigger = { TARGET = $VICTIM$ }
				}
			}
			# Inform killer house that they have gained score
			$MURDERER$.house = {
				house_head = {
					random_owned_story = {
						limit = { story_type = story_cycle_house_feud }
						save_scope_as = house_feud_story
						change_variable = {
							name = house_feud_kill_counter
							add = house_feud_medium_counter_value
						}
                        if = {
                            limit = {
                                NOT = { has_variable = house_feud_recent_kill }
                            }
                            set_variable = {
                                name = house_feud_recent_kill
                                value = $VICTIM$
                                months = 6
                            }
                        }
					}
				}
				every_house_member = {
					limit = { is_ai = no }
					send_interface_message = {
						type = house_feud_kill_them_message
						left_icon = scope:killer
						right_icon = root
						custom_tooltip = house_feud_tipped_scales_pos_medium
					}
				}
			}
		}
		# Events
		# Fire Feud start event for victim house
		if = {
			limit = {
				$VICTIM$ = {
					NOT = {
						has_any_bad_relationship_with_character_trigger = { CHARACTER = $VICTIM$.house.house_head }
					}
					house.house_head ?= {
						house_head_can_start_feud_against_trigger = { TARGET = $MURDERER$ }
					}
				}
			}
			$VICTIM$ = { save_scope_as = house_feud_victim }
			house_feud_save_head_and_attacker_effect = yes
			$VICTIM$.house.house_head = {
				random = {
					chance = 25
					modifier = {
						add = 25
						has_trait = vengeful
					}
					modifier = {
						add = -25
						has_trait = forgiving
					}
					modifier = {
						add = 25
						has_any_bad_relationship_with_character_trigger = { CHARACTER = $MURDERER$ }
					}
					trigger_event = {
						id = bp1_house_feud.0005
						days = { 5 15 }
					}
				}
			}
		}
		# Fire Feud revenge event for killer house
		$MURDERER$.house.house_head = {
			if = {
				limit = {
					any_owned_story = {
						story_type = story_cycle_house_feud
						OR = {
							var:house_feud_reason = flag:head_killed
							var:house_feud_reason = flag:family_killed
						}
						var:house_feud_attacker = $VICTIM$
					}
				}
				trigger_event = { id = bp1_house_feud.7001 days = 15 }
			}
		}
	}
}
