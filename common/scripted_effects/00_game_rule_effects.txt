######################
# GENERATED FAMILIES #
######################

game_rule_create_spouse_and_children = {
	$CHARACTER$ = {
		#If not married, create spouse
		if = {
			limit = {
				is_married = no
			}
			create_character = {
				location = $CHARACTER$.location
				culture = $CHARACTER$.culture
				faith = $CHARACTER$.faith
				gender_female_chance = $CHARACTER$.marriage_gender_adjusted_female_chance
				age = $CHARACTER$.age
				save_scope_as = spouse
			}

			# Warcraft
			scope:spouse = {
				# Warcraft
				save_scope_value_as = { name = no_age_scaling value = flag:yes }
				trigger_race_giving_no_gene_effect = yes			#Assigns race trait
			}

			if = {
				limit = { is_male = yes }
				marry = scope:spouse
			}
			else = {
				marry_matrilineal = scope:spouse
			}
		}
		else = {
			primary_spouse = { save_scope_as = spouse }
		}

		if = {
			limit = { is_male = yes }
			save_scope_as = father
			scope:spouse = {
				if = {
					limit = {
						is_female = yes
					}
					save_scope_as = mother
				}
			}
		}
		else = {
			save_scope_as = mother
			scope:spouse = {
				if = {
					limit = {
						is_male = yes
					}
					save_scope_as = father
				}
			}
		}

		#Create child 1 (mother age 17+)
		if = {
			limit = {
				exists = scope:mother
				scope:mother.age >= age_17_value
			}
			if = { #Do we have a father saved?
				limit = {
					exists = scope:father
				}
				create_character = {
					location = $CHARACTER$.location
					culture = $CHARACTER$.culture
					faith = $CHARACTER$.faith
					gender_female_chance = {
						if = {
							limit = {
								is_ruler = yes
								$CHARACTER$ = { has_realm_law = male_only_law }
							}
							value = 0
						}
						else = {
							limit = {
								is_ruler = yes
								$CHARACTER$ = { has_realm_law = female_only_law }
							}
							value = 100
						}
						else = {
							value = 50
						}
					}
					age = {
						value = scope:mother.age

						# Warcraft
						subtract = {
							value = 17
							multiply = scope:mother.racial_age_multiplier_value
						}
						min = adulthood_start_age
						max = age_max_value
					}
					father = scope:father
					mother = scope:mother
					dynasty = inherit
					save_scope_as = child_1
				}
			}
			else = { #If we don't have a father we generate a child without
				create_character = {
					location = $CHARACTER$.location
					culture = $CHARACTER$.culture
					faith = $CHARACTER$.faith
					gender_female_chance = {
						if = {
							limit = {
								is_ruler = yes
								$CHARACTER$ = { has_realm_law = male_only_law }
							}
							value = 0
						}
						else = {
							limit = {
								is_ruler = yes
								$CHARACTER$ = { has_realm_law = female_only_law }
							}
							value = 100
						}
						else = {
							value = 50
						}
					}
					age = {
						value = scope:mother.age

						# Warcraft
						subtract = {
							value = 17
							multiply = scope:mother.racial_age_multiplier_value
						}
						min = adulthood_start_age
						max = age_max_value
					}
					mother = scope:mother
					dynasty = inherit
					save_scope_as = child_1
				}
			}

			# Warcraft
			scope:child_1 ?= {
				# Warcraft
				trigger_race_giving_no_gene_effect = yes			#Assigns race trait
			}
		}
		#Create child 1 (no mother)
		else_if = {
			limit = {
				NOT = { exists = scope:mother }
			}
			create_character = {
				location = $CHARACTER$.location
				culture = $CHARACTER$.culture
				faith = $CHARACTER$.faith
				gender_female_chance = {
					if = {
						limit = {
							is_ruler = yes
							$CHARACTER$ = { has_realm_law = male_only_law }
						}
						value = 0
					}
					else = {
						limit = {
							is_ruler = yes
							$CHARACTER$ = { has_realm_law = female_only_law }
						}
						value = 100
					}
					else = {
						value = 50
					}
				}
				age = {
					value = scope:mother.age
					
					# Warcraft
					subtract = {
						value = 17
						multiply = scope:mother.racial_age_multiplier_value
					}
					min = adulthood_start_age
					max = age_max_value
				}
				father = scope:father
				dynasty = inherit
				save_scope_as = child_1
			}

			# Warcraft
			scope:child_1 = {
				# Warcraft
				trigger_race_giving_no_gene_effect = yes			#Assigns race trait
			}
		}

		#Create child 2 (mother age 25+)
		if = {
			limit = {
				exists = scope:mother
				scope:mother.age >= age_25_value
			}

			if = { #Do we have a father saved?
				limit = {
					exists = scope:father
				}
				create_character = {
					location = $CHARACTER$.location
					culture = $CHARACTER$.culture
					faith = $CHARACTER$.faith
					gender_female_chance = {
						value = 50
					}
					age = {
						value = scope:mother.age
						
						# Warcraft
						subtract = {
							value = 25
							multiply = scope:mother.racial_age_multiplier_value
						}
						min = adulthood_start_age
						max = age_max_value
					}
					father = scope:father
					mother = scope:mother
					dynasty = inherit
					save_scope_as = child_2
				}
			}
			else = { #If we don't have a father we generate a child without
				create_character = {
					location = $CHARACTER$.location
					culture = $CHARACTER$.culture
					faith = $CHARACTER$.faith
					gender_female_chance = {
						value = 50
					}
					age = {
						value = scope:mother.age
						
						# Warcraft
						subtract = {
							value = 25
							multiply = scope:mother.racial_age_multiplier_value
						}
						min = adulthood_start_age
						max = age_max_value
					}
					mother = scope:mother
					dynasty = inherit
					save_scope_as = child_2
				}
			}

			# Warcraft
			scope:child_2 = {
				# Warcraft
				trigger_race_giving_no_gene_effect = yes			#Assigns race trait
			}
		}

		#Create child 3 (mother age 33+)
		if = {
			limit = {
				exists = scope:mother
				scope:mother.age >= age_33_value
			}

			if = { #Do we have a father saved?
				limit = {
					exists = scope:father
				}
				create_character = {
					location = $CHARACTER$.location
					culture = $CHARACTER$.culture
					faith = $CHARACTER$.faith
					gender_female_chance = {
						value = 50
					}
					age = {
						value = scope:mother.age
						
						# Warcraft
						subtract = {
							value = 33
							multiply = scope:mother.racial_age_multiplier_value
						}
						min = adulthood_start_age
						max = age_max_value
					}
					father = scope:father
					mother = scope:mother
					dynasty = inherit
					save_scope_as = child_3
				}
			}
			else = { #If we don't have a father we generate a child without
				create_character = {
					location = $CHARACTER$.location
					culture = $CHARACTER$.culture
					faith = $CHARACTER$.faith
					gender_female_chance = {
						value = 50
					}
					age = {
						value = scope:mother.age
						
						# Warcraft
						subtract = {
							value = 33
							multiply = scope:mother.racial_age_multiplier_value
						}
						min = adulthood_start_age
						max = age_max_value
					}
					mother = scope:mother
					dynasty = inherit
					save_scope_as = child_3
				}
			}

			# Warcraft
			scope:child_3 = {
				# Warcraft
				trigger_race_giving_no_gene_effect = yes			#Assigns race trait
			}
		}
	}
}


###################
# GENDER EQUALITY #
###################

#Full equality
game_rule_full_gender_equality_effect = {
	every_religion_global = {
		every_faith = {
			## DOCTRINE_GENDER
			if = {
				limit = { has_doctrine = doctrine_gender_male_dominated }
				remove_doctrine = doctrine_gender_male_dominated
			}
			else_if = {
				limit = { has_doctrine = doctrine_gender_female_dominated }
				remove_doctrine = doctrine_gender_female_dominated
			}

			if = {
				limit = { NOT = { has_doctrine = doctrine_gender_equal } }
				add_doctrine = doctrine_gender_equal
			}

			## DOCTRINE_CLERICAL_GENDER
			if = {
				limit = { has_doctrine = doctrine_clerical_gender_male_only }
				remove_doctrine = doctrine_clerical_gender_male_only
			}
			else_if = {
				limit = { has_doctrine = doctrine_clerical_gender_female_only }
				remove_doctrine = doctrine_clerical_gender_female_only
			}

			if = {
				limit = { NOT = { has_doctrine = doctrine_clerical_gender_either } }
				add_doctrine = doctrine_clerical_gender_either
			}


			## DOCTRINE_ADULTERY_MEN & DOCTRINE_ADULTERY_WOMEN
			#Makes the adultery doctrine same for both genders (picks lesser version)

			#Any of them accepted? Both should be accepted
			if = {
				limit = {
					OR = {
						has_doctrine = doctrine_adultery_men_accepted
						has_doctrine = doctrine_adultery_women_accepted
					}
				}

				#Is male wrong?
				if = {
					limit = { NOT = { has_doctrine = doctrine_adultery_men_accepted } }

					if = {
						limit = { has_doctrine = doctrine_adultery_men_crime }
						remove_doctrine = doctrine_adultery_men_crime
					}
					else_if = {
						limit = { has_doctrine = doctrine_adultery_men_shunned }
						remove_doctrine = doctrine_adultery_men_shunned
					}
					add_doctrine = doctrine_adultery_men_accepted
				}

				#Is female wrong?
				if = {
					limit = { NOT = { has_doctrine = doctrine_adultery_women_accepted } }

					if = {
						limit = { has_doctrine = doctrine_adultery_women_crime }
						remove_doctrine = doctrine_adultery_women_crime
					}
					else_if = {
						limit = { has_doctrine = doctrine_adultery_women_shunned }
						remove_doctrine = doctrine_adultery_women_shunned
					}
					add_doctrine = doctrine_adultery_women_accepted
				}
			}
			##Any of them shunned? Both should be shunned
			else_if = {
				limit = {
					OR = {
						has_doctrine = doctrine_adultery_men_shunned
						has_doctrine = doctrine_adultery_women_shunned
					}
				}

				#Is male wrong?
				if = {
					limit = { NOT = { has_doctrine = doctrine_adultery_men_shunned } }
					remove_doctrine = doctrine_adultery_men_crime
					add_doctrine = doctrine_adultery_men_shunned
				}

				#Is female wrong?
				if = {
					limit = { NOT = { has_doctrine = doctrine_adultery_women_shunned } }
					remove_doctrine = doctrine_adultery_women_crime
					add_doctrine = doctrine_adultery_women_shunned
				}
			}
			##Else: they're both criminal, nothing to do here
		}
	}

	## REALM LAW
	every_ruler = {
		if = {
			limit = {
				OR = {
					has_realm_law = male_preference_law
					has_realm_law = female_preference_law
					has_realm_law = female_only_law
					has_realm_law = male_only_law
				}
			}
			add_realm_law = equal_law
		}
	}
	
	## CULTURES - MARTIAL CUSTOM
	every_culture_global = {
		if = {
			limit = {
				OR = {
					has_cultural_pillar = martial_custom_male_only
					has_cultural_pillar = martial_custom_female_only
				}
			}
			set_culture_pillar = martial_custom_equal
		}
	}

	#Specific titles' law
}



game_rule_inversed_gender_equality_effect = {
	every_religion_global = {
		every_faith = {

			## DOCTRINE_GENDER
			if = {
				limit = { has_doctrine = doctrine_gender_male_dominated }
				remove_doctrine = doctrine_gender_male_dominated
				add_doctrine = doctrine_gender_female_dominated
			}
			else_if = {
				limit = { has_doctrine = doctrine_gender_female_dominated }
				remove_doctrine = doctrine_gender_female_dominated
				add_doctrine = doctrine_gender_male_dominated
			}
			#Else: equal, do nothing

			## DOCTRINE_CLERICAL_GENDER
			if = {
				limit = { has_doctrine = doctrine_clerical_gender_male_only }
				remove_doctrine = doctrine_clerical_gender_male_only
				add_doctrine = doctrine_clerical_gender_female_only
			}
			else_if = {
				limit = { has_doctrine = doctrine_clerical_gender_female_only }
				remove_doctrine = doctrine_clerical_gender_female_only
				add_doctrine = doctrine_clerical_gender_male_only
			}
			#Else: either, do nothing

			## DOCTRINE_ADULTERY_MEN & DOCTRINE_ADULTERY_WOMEN
			# Men and women swap doctrine
			if = {
				limit = {
					NOR = {
						AND = {
							has_doctrine = doctrine_adultery_women_accepted
							has_doctrine = doctrine_adultery_men_accepted
						}
						AND = {
							has_doctrine = doctrine_adultery_women_shunned
							has_doctrine = doctrine_adultery_men_shunned
						}
						AND = {
							has_doctrine = doctrine_adultery_women_crime
							has_doctrine = doctrine_adultery_men_crime
						}
					}
				}
				# Save women's doctrine
				if = {
					limit = { has_doctrine = doctrine_adultery_women_accepted }
					save_scope_value_as = {
						name = doctrine_adultery_women
						value = flag:doctrine_adultery_women_accepted
					}
				}
				else_if = {
					limit = {  has_doctrine = doctrine_adultery_women_shunned }
					save_scope_value_as = {
						name = doctrine_adultery_women
						value = flag:doctrine_adultery_women_shunned
					}
				}
				else_if = {
					limit = {  has_doctrine = doctrine_adultery_women_crime }
					save_scope_value_as = {
						name = doctrine_adultery_women
						value = flag:doctrine_adultery_women_crime
					}
				}

				# Give women mens' doctrine
				if = {
					limit = { has_doctrine = doctrine_adultery_men_accepted }
					if = {
						limit = { has_doctrine = doctrine_adultery_women_shunned }
						remove_doctrine = doctrine_adultery_women_shunned
					}
					else_if = {
						limit = { has_doctrine = doctrine_adultery_women_crime }
						remove_doctrine = doctrine_adultery_women_crime
					}
					add_doctrine = doctrine_adultery_women_accepted
				}
				else_if = {
					limit = { has_doctrine = doctrine_adultery_men_shunned }
					if = {
						limit = { has_doctrine = doctrine_adultery_women_accepted }
						remove_doctrine = doctrine_adultery_women_accepted
					}
					else_if = {
						limit = { has_doctrine = doctrine_adultery_women_crime }
						remove_doctrine = doctrine_adultery_women_crime
					}
					add_doctrine = doctrine_adultery_women_shunned
				}
				else_if = {
					limit = { has_doctrine = doctrine_adultery_men_crime }
					if = {
						limit = { has_doctrine = doctrine_adultery_women_accepted }
						remove_doctrine = doctrine_adultery_women_accepted
					}
					else_if = {
						limit = { has_doctrine = doctrine_adultery_women_shunned }
						remove_doctrine = doctrine_adultery_women_shunned
					}
					add_doctrine = doctrine_adultery_women_crime
				}

				# Give men women' doctrine
				if = {
					limit = { scope:doctrine_adultery_women = flag:doctrine_adultery_women_accepted }
					if = {
						limit = { has_doctrine = doctrine_adultery_men_shunned }
						remove_doctrine = doctrine_adultery_men_shunned
					}
					else_if = {
						limit = { has_doctrine = doctrine_adultery_men_crime }
						remove_doctrine = doctrine_adultery_men_crime
					}
					add_doctrine = doctrine_adultery_men_accepted
				}
				else_if = {
					limit = { scope:doctrine_adultery_women = flag:doctrine_adultery_women_shunned }
					if = {
						limit = { has_doctrine = doctrine_adultery_men_accepted }
						remove_doctrine = doctrine_adultery_men_accepted
					}
					else_if = {
						limit = { has_doctrine = doctrine_adultery_men_crime }
						remove_doctrine = doctrine_adultery_men_crime
					}
					add_doctrine = doctrine_adultery_men_shunned
				}
				else_if = {
					limit = { scope:doctrine_adultery_women = flag:doctrine_adultery_women_crime }
					if = {
						limit = { has_doctrine = doctrine_adultery_men_accepted }
						remove_doctrine = doctrine_adultery_men_accepted
					}
					else_if = {
						limit = { has_doctrine = doctrine_adultery_men_shunned }
						remove_doctrine = doctrine_adultery_men_shunned
					}
					add_doctrine = doctrine_adultery_men_crime
				}
			}
		}
	}

	## REALM LAW
	every_ruler = {
		# Take care of any titles with their own title laws.
		every_held_title = {
			limit = { can_title_have_law_general_trigger = yes }
			# Invert male-only.
			if = {
				limit = { has_title_law = male_only_law }
				remove_title_law = male_only_law
				add_title_law = female_only_law
			}
			# Invert female-only.
			else_if = {
				limit = { has_title_law = female_only_law }
				remove_title_law = female_only_law
				add_title_law = male_only_law
			}
		}
		# Now realm law.
		if = {
			limit = { has_realm_law = male_only_law }
			add_realm_law = female_only_law
			if = {
				limit = {
					highest_held_title_tier >= tier_county
					is_male = yes
					is_ai = yes
					any_heir = { is_female = yes }
				}
				depose = yes
			}
		}
		else_if = {
			limit = { has_realm_law = male_preference_law }
			add_realm_law = female_preference_law
			if = {
				limit = {
					highest_held_title_tier >= tier_county
					is_male = yes
					is_ai = yes
					any_heir = { is_female = yes }
				}
				depose = yes
			}
		}
		else_if = {
			limit = { has_realm_law = female_preference_law }
			add_realm_law = male_preference_law
			if = {
				limit = {
					highest_held_title_tier >= tier_county
					is_female = yes
					is_ai = yes
					any_heir = { is_male = yes }
				}
				depose = yes
			}
		}
		else_if = {
			limit = { has_realm_law = female_only_law }
			add_realm_law = male_only_law
			if = {
				limit = {
					highest_held_title_tier >= tier_county
					is_female = yes
					is_ai = yes
					any_heir = { is_male = yes }
				}
				depose = yes
			}
		}
		#Else: equal, nothing changes
	}

	# We handle religious titles here because title law overlaps with faith law in weird ways otherwise.
	## Take care of first-generation HoFs.
	every_religion_global = {
		every_faith = {
			if = {
				limit = {
					has_doctrine = doctrine_clerical_gender_male_only
					religious_head ?= { is_female = yes }
				}
				religious_head = { depose = yes }
			}
			else_if = {
				limit = {
					has_doctrine = doctrine_clerical_gender_female_only
					religious_head ?= { is_male = yes }
				}
				religious_head = { depose = yes }
			}
		}
	}
	
	## CULTURES - MARTIAL CUSTOM
	every_culture_global = {
		if = {
			limit = { has_cultural_pillar = martial_custom_male_only }
			set_culture_pillar = martial_custom_female_only
		}
		else_if = {
			limit = { has_cultural_pillar = martial_custom_female_only }
			set_culture_pillar = martial_custom_male_only
		}
	}
}

game_rule_accepted_same_sex_relations_effect = {
	every_religion_global = {
		every_faith = {
			if = {
				limit = { has_doctrine = doctrine_homosexuality_crime }
				remove_doctrine = doctrine_homosexuality_crime
			}
			else_if = {
				limit = { has_doctrine = doctrine_homosexuality_shunned }
				remove_doctrine = doctrine_homosexuality_shunned
			}

			if = {
				limit = { NOT = { has_doctrine = doctrine_homosexuality_accepted } }
				add_doctrine = doctrine_homosexuality_accepted
			}
			#Else: equal, do nothing
		}
	}
}


##########################
# RANDOM RULER PLACEMENT #
##########################

game_rule_random_ruler_placement_shuffle_list_effect = {
	random_in_list = {
		list = $LIST_NAME$
		save_scope_as = previous_ruler
		remove_from_list = $LIST_NAME$
	} #First ruler will get stuff and not give away anything, lucky them

	while = {
		limit = {
			any_in_list = {
				list = $LIST_NAME$
				NOT = { has_character_flag = already_swapped }
			}
		}
		random_in_list = {
			limit = { NOT = { has_character_flag = already_swapped } }
			list = $LIST_NAME$

			#Create change
			create_title_and_vassal_change = {
				type = granted
				save_scope_as = change
				add_claim_on_loss = no
			}
			every_held_title = {
				limit = { tier >= tier_county is_head_of_faith = no }
				change_title_holder_include_vassals = {
					holder = scope:previous_ruler
					change = scope:change
				}
			}
			resolve_title_and_vassal_change = scope:change
			scope:previous_ruler = {
				if = {
					limit = {
						OR = {
							is_independent_ruler = yes
							highest_held_title_tier >= tier_kingdom
							any_held_title = {
								is_head_of_faith = yes
							}
						}
					}
					every_held_title = {
						limit = { tier = tier_county }
						set_county_culture = prev.culture
						set_county_faith = prev.faith
					}
				}
				else = {
					set_character_faith = top_liege.faith
					every_held_title = {
						limit = { tier = tier_county }
						set_county_culture = prev.culture
						set_county_faith = prev.top_liege.faith
					}
				}
			}

			#Convert if needed
			#if = {
			#	limit = { has_game_rule = random_ruler_placement_on_conversion }
			#	set_character_faith_with_conversion = scope:previous_ruler.faith
			#}

			#Saved to take titles next + blocked from being stolen from again
			save_scope_as = previous_ruler
			add_character_flag = {
				flag = already_swapped
				days = 3
			}
		}
	}
}
game_rule_random_ruler_placement_shuffle_list_with_weight_effect = {
	random_in_list = {
		list = $LIST_NAME$
		save_scope_as = previous_ruler
		remove_from_list = $LIST_NAME$
	} #First ruler will get stuff and not give away anything, lucky them

	while = {
		limit = {
			any_in_list = {
				list = $LIST_NAME$
				NOT = { has_character_flag = already_swapped }
			}
		}
		random_in_list = {
			limit = { NOT = { has_character_flag = already_swapped } }
			list = $LIST_NAME$
			weight = {
				base = 1
				modifier = {
					add = 500
					exists = top_liege
					scope:previous_ruler.culture = { has_same_culture_heritage = prev.top_liege.culture }
				}
			}

			#Create change
			create_title_and_vassal_change = {
				type = granted
				save_scope_as = change
				add_claim_on_loss = no
			}
			every_held_title = {
				limit = { tier >= tier_county is_head_of_faith = no }
				change_title_holder_include_vassals = {
					holder = scope:previous_ruler
					change = scope:change
				}
			}
			resolve_title_and_vassal_change = scope:change
			scope:previous_ruler = {
				if = {
					limit = {
						OR = {
							is_independent_ruler = yes
							highest_held_title_tier >= tier_kingdom
							any_held_title = {
								is_head_of_faith = yes
							}
						}
					}
					every_held_title = {
						limit = { tier = tier_county }
						set_county_culture = prev.culture
						set_county_faith = prev.faith
					}
				}
				else = {
					set_character_faith = top_liege.faith
					if = {
						limit = { NOT = { has_same_culture_as = top_liege } }
						random = {
							chance = 20
							set_culture_same_as = top_liege
						}
					}
					every_held_title = {
						limit = { tier = tier_county }
						set_county_culture = prev.culture
						set_county_faith = prev.top_liege.faith
					}
				}
			}

			#Convert if needed
			#if = {
			#	limit = { has_game_rule = random_ruler_placement_on_conversion }
			#	set_character_faith_with_conversion = scope:previous_ruler.faith
			#}

			#Saved to take titles next + blocked from being stolen from again
			save_scope_as = previous_ruler
			add_character_flag = {
				flag = already_swapped
				days = 3
			}
		}
	}
}

game_rule_random_ruler_placement_effect = {
	every_ruler = {
		limit = {
			save_temporary_scope_as = ruler_for_list
			NOR = {
				is_ai = no
				any_liege_or_above = {
					is_ai = no
					dynasty = scope:ruler_for_list.dynasty
				}
			}
		}

		if = {
			limit = { highest_held_title_tier = tier_barony }
			add_to_list = random_placement_barons
		}
		else_if = {
			limit = { highest_held_title_tier = tier_county }
			add_to_list = random_placement_counts
		}
		else_if = {
			limit = { highest_held_title_tier = tier_duchy }
			add_to_list = random_placement_dukes
		}
		else = {
			add_to_list = random_placement_emperors_kings
		}
	}


	### EMPERORS AND KINGS SHUFFLE ###
	game_rule_random_ruler_placement_shuffle_list_effect = { LIST_NAME = random_placement_emperors_kings }
	
	### DUKES SHUFFLE ###
	game_rule_random_ruler_placement_shuffle_list_with_weight_effect = { LIST_NAME = random_placement_dukes }
	
	### COUNTS SHUFFLE ###
	game_rule_random_ruler_placement_shuffle_list_with_weight_effect = { LIST_NAME = random_placement_counts }
	
	### BARONS SHUFFLE ###
	#game_rule_random_ruler_placement_shuffle_list_effect = { LIST_NAME = random_placement_barons }


	### MAKE EXCLAVES INDEPENDENT ###
	every_ruler = {
		limit = {
			is_independent_ruler = no
			save_temporary_scope_as = exclave_check
			NOT = {
				any_held_title = {
					tier = tier_county
					any_neighboring_county = {
						holder = {
							NOR = {
								this = scope:exclave_check
								target_is_liege_or_above = scope:exclave_check
							}
							top_liege = scope:exclave_check.top_liege
						}
					}
				}
			}
		}

		create_title_and_vassal_change = {
			type = independency
			save_scope_as = change
			add_claim_on_loss = no
		}
		becomes_independent = {
			change = scope:change
		}

		resolve_title_and_vassal_change = scope:change
	}
}

####################
# FAITH ACCEPTANCE #
####################

game_rule_randomize_faith_randomization_effect = {
	if = {
		limit = {
			trigger_if = {
				limit = { is_independent_ruler = no }
				NOT = { faith = liege.faith } #We don't want to override faiths which "trickled down" via conversion effect
			}
			trigger_else = {
				always = yes
			}
		}



		#Randomize faith
		random_in_list = {
			list = faiths_list
			save_temporary_scope_as = randomized_faith
		}

		#Covert all courtiers, guests, pool characters of same faith
		if = {
			limit = {
				exists = capital_province
			}
			save_temporary_scope_as = this_ruler
			every_pool_character = {
				province = scope:this_ruler.capital_province
				limit = { faith = scope:this_ruler.faith }
				set_character_faith = scope:randomized_faith
			}
		}
		every_courtier_or_guest = {
			limit = {  faith = prev.faith }
			set_character_faith = scope:randomized_faith
		}

		#Change faith with conversion for chance of trickling down to vassals
		set_character_faith_with_conversion = scope:randomized_faith

		#Convert every held county
		every_held_title = {
			limit = { tier = tier_county }
			set_county_faith = scope:randomized_faith
		}
	}
}

game_rule_randomize_faith_effect = {
	#Build faith list
	every_religion_global = {
		every_faith = {
			add_to_list = faiths_list
		}
	}

	#Save all rulers in tiered lists
	every_ruler = {
		if = {
			limit = { highest_held_title_tier = tier_barony }
			add_to_list = random_faith_barony_list
		}
		else_if = {
			limit = { highest_held_title_tier = tier_county }
			add_to_list = random_faith_county_list
		}
		else_if = {
			limit = { highest_held_title_tier = tier_duchy }
			add_to_list = random_faith_duchy_list
		}
		else_if = {
			limit = { highest_held_title_tier = tier_kingdom }
			add_to_list = random_faith_kingdom_list
		}
		else_if = {
			limit = { highest_held_title_tier = tier_empire }
			add_to_list = random_faith_empire_list
		}
	}

	#Apply random faiths top-down (for conversion trickle down)
	every_in_list = {
		list = random_faith_empire_list
		game_rule_randomize_faith_randomization_effect = yes
	}
	every_in_list = {
		list = random_faith_kingdom_list
		game_rule_randomize_faith_randomization_effect = yes
	}
	every_in_list = {
		list = random_faith_duchy_list
		game_rule_randomize_faith_randomization_effect = yes
	}
	every_in_list = {
		list = random_faith_county_list
		game_rule_randomize_faith_randomization_effect = yes
	}
	every_in_list = {
		list = random_faith_barony_list
		set_character_faith = scope:liege.faith
	}
}

####################
# FAITH ACCEPTANCE #
####################

game_rule_faith_acceptance_effect = {
	every_religion_global = {
		every_faith = {
			#Set to pluralist, not because it matters but because it looks good
			if = {
				limit = { has_doctrine = doctrine_pluralism_fundamentalist }
				remove_doctrine = doctrine_pluralism_fundamentalist
				add_doctrine = doctrine_pluralism_pluralistic
			}
			else_if = {
				limit = { has_doctrine = doctrine_pluralism_righteous }
				remove_doctrine = doctrine_pluralism_righteous
				add_doctrine = doctrine_pluralism_pluralistic
			}

			#Add special doctrine
			add_doctrine = special_doctrine_full_tolerance
		}
	}
}


##########################
# SEXUALITY DISTRIBUTION #
##########################

game_rule_sexuality_distribution_reroll_effect = {
	if = {
		# Warcraft
		limit = { age >= age_10_value }

		random_list = {
			0 = {
				modifier = { add = heterosexuality_chance }
				set_sexuality = heterosexual
			}
			0 = {
				modifier = { add = bisexuality_chance }
				set_sexuality = bisexual
			}
			0 = {
				modifier = { add = homosexuality_chance }
				set_sexuality = homosexual
			}
			0 = {
				modifier = { add = asexuality_chance }
				set_sexuality = asexual
			}
		}
	}
}

game_rule_sexuality_distribution_effect = {
	every_ruler = {
		game_rule_sexuality_distribution_reroll_effect = yes

		every_courtier_or_guest = {
			game_rule_sexuality_distribution_reroll_effect = yes
		}

		every_held_title = {
			limit = {
				tier = tier_county
			}
			title_province = { save_scope_as = pool_province }
			every_pool_character = {
				limit = { NOT = { is_in_list = pool_characters } }
				province = scope:pool_province
				add_to_list = pool_characters
			}
		}
	}

	every_in_list = {
		list = pool_characters
		game_rule_sexuality_distribution_reroll_effect = yes
	}

	# Sets the values for future generated characters
	set_generated_homosexuality_chance = homosexuality_chance
	set_generated_bisexuality_chance = bisexuality_chance
	set_generated_asexuality_chance = asexuality_chance
}

child_sexuality_distribution_effect = {
	every_ruler = {
		if = {
			limit = {
				is_adult = no
				age >= 10
			}
			game_rule_sexuality_distribution_reroll_effect = yes
		}

		every_courtier_or_guest = {
			if = {
				limit = {
					is_adult = no
					age >= 10
				}
				game_rule_sexuality_distribution_reroll_effect = yes
			}
		}

		every_held_title = {
			limit = {
				tier = tier_county
			}
			title_province = { save_scope_as = pool_province }
			every_pool_character = {
				limit = { NOT = { is_in_list = pool_characters } }
				province = scope:pool_province
				add_to_list = pool_characters
			}
		}
	}

	every_in_list = {
		list = pool_characters
		if = {
			limit = {
				is_adult = no
				age >= 10
			}
			game_rule_sexuality_distribution_reroll_effect = yes
		}
	}
}

########################
# EXCLAVE INDEPENDENCE #
########################

game_rule_exclave_independence_effect = {
	if = { # Limited, AI only
		limit = {
			has_game_rule = ai_limited_exclave_independence
			is_ai = yes
			NOT = {
				any_vassal_or_below = {
					is_ai = no
				}
			}
		}
		
		remove_character_flag = delayed_cleanse
	
		root.capital_province.county = {
			every_connected_county = { # Start off by making a list of all disconnected Counties
				invert = yes
				max_naval_distance = 2000
				allow_one_county_land_gap = yes
				add_to_list = disconnected_counties
			}
		}
		
		every_in_list = {
			list = disconnected_counties
			
			limit = {
				any_connected_county = {
					NOT = { is_in_list = disconnected_counties }
					max_naval_distance = 2000
				}
			}
			add_to_list = cull_naval_connection_counties
		}
		
		while = {
			limit = {
				any_in_list = {
					list = cull_naval_connection_counties
				}
			}
			random_in_list = {
				list = cull_naval_connection_counties
				
				save_scope_as = cull_origin_county
				
				every_connected_county = {
					remove_from_list = cull_naval_connection_counties
					remove_from_list = disconnected_counties
				}
				remove_from_list = cull_naval_connection_counties
				remove_from_list = disconnected_counties
			}
		}
		
		every_in_list = {
			list = disconnected_counties
			
			limit = {
				target_is_de_jure_liege_or_above = root.primary_title
			}
			add_to_list = cull_de_jure_connection_counties
		}
		
		while = {
			limit = {
				any_in_list = {
					list = cull_de_jure_connection_counties
				}
			}
			random_in_list = {
				list = cull_de_jure_connection_counties
				
				save_scope_as = cull_origin_county
				
				every_connected_county = {
					remove_from_list = cull_de_jure_connection_counties
					remove_from_list = disconnected_counties
				}
				remove_from_list = cull_de_jure_connection_counties
				remove_from_list = disconnected_counties
			}
		}
		
		every_in_list = { # Release Kings first
			list = disconnected_counties
			
			limit = {
				holder.primary_title.tier = tier_kingdom
				NOR = {
					holder = root
					holder = {
						any_sub_realm_title = {
							tier = tier_county
							NOT = { is_in_list = disconnected_counties }
						}
					}
				}
			}
			holder = {
				create_title_and_vassal_change = {
					type = independency
					save_scope_as = change
					add_claim_on_loss = yes
				}
				becomes_independent = {
					change = scope:change
				}
				resolve_title_and_vassal_change = scope:change
			}
		}
		
		every_in_list = { # Release Dukes second
			list = disconnected_counties
			
			limit = {
				holder.primary_title.tier = tier_duchy
				NOR = {
					holder = root
					holder = {
						any_sub_realm_title = {
							tier = tier_county
							NOT = { is_in_list = disconnected_counties }
						}
					}
				}
			}
			holder = {
				create_title_and_vassal_change = {
					type = independency
					save_scope_as = change
					add_claim_on_loss = yes
				}
				becomes_independent = {
					change = scope:change
				}
				resolve_title_and_vassal_change = scope:change
			}
		}
		
		every_in_list = { # Release Counts last
			list = disconnected_counties
			
			limit = {
				holder.primary_title.tier = tier_county
				NOR = {
					holder = root
					holder = {
						any_sub_realm_title = {
							tier = tier_county
							NOT = { is_in_list = disconnected_counties }
						}
					}
				}
			}
			holder = {
				create_title_and_vassal_change = {
					type = independency
					save_scope_as = change
					add_claim_on_loss = yes
				}
				becomes_independent = {
					change = scope:change
				}
				resolve_title_and_vassal_change = scope:change
			}
		}
		
		every_in_list = { # Finally, release contiguous areas under someone from the pool
			list = disconnected_counties
			
			limit = {
				OR = {
					holder.top_liege = root
					holder = root
				}
			}
			
			save_scope_as = county_of_origin
			
			every_pool_character = {
				province = scope:county_of_origin.title_province
				limit = {
					is_available_adult = yes
				}
				add_to_list = potential_holders
			}
			
			every_pool_character = {
				province = scope:county_of_origin.holder.capital_province
				limit = {
					is_available_adult = yes
				}
				add_to_list = potential_holders
			}
			
			if = {
				limit = {
					NOT = {
						any_in_list = {
							list = potential_holders
							is_available_adult = yes
						}
					}
				}
				create_character = {
					location = scope:county_of_origin.title_province
					culture = scope:county_of_origin.culture
					faith = scope:county_of_origin.faith
					gender_female_chance = 50

					#Warcraft
					#age = age_32_value
					age = 32 #TODO: Add scaling back

					save_scope_as = backup_character
				}
				scope:backup_character = {
					# Warcraft
					trigger_race_giving_no_gene_effect = yes			#Assigns race trait
					
					add_to_list = potential_holders
				}
			}
			
			random_in_list = {
				list = potential_holders
				limit = {
					is_available_adult = yes
					has_claim_on = scope:county_of_origin
					faith = {
						has_dominant_ruling_gender = prev
					}
				}
				alternative_limit = {
					is_available_adult = yes
					culture = scope:county_of_origin.culture
					faith = scope:county_of_origin.faith
					faith = {
						has_dominant_ruling_gender = prev
					}
				}
				alternative_limit = {
					is_available_adult = yes
					culture = scope:county_of_origin.culture
					faith = {
						has_dominant_ruling_gender = prev
					}
				}
				alternative_limit = {
					is_available_adult = yes
					faith = scope:county_of_origin.faith
					faith = {
						has_dominant_ruling_gender = prev
					}
				}
				alternative_limit = {
					is_available_adult = yes
					faith = {
						has_dominant_ruling_gender = prev
					}
				}
				alternative_limit = {
					is_available_adult = yes
					has_claim_on = scope:county_of_origin
				}
				alternative_limit = {
					is_available_adult = yes
					culture = scope:county_of_origin.culture
					faith = scope:county_of_origin.faith
				}
				alternative_limit = {
					is_available_adult = yes
					culture = scope:county_of_origin.culture
				}
				alternative_limit = {
					is_available_adult = yes
					faith = scope:county_of_origin.faith
				}
				alternative_limit = {
					is_available_adult = yes
				}
				
				save_scope_as = new_county_holder
				#get_title = scope:county_of_origin
				
				create_title_and_vassal_change = {
					type = independency
					save_scope_as = change
					add_claim_on_loss = yes
				}
				every_in_list = {
					list = disconnected_counties
					limit = {
						OR = {
							holder.top_liege = root
							holder = root
						}
						is_connected_to = {
							target = scope:county_of_origin
						}
						NOT ={
							is_connected_to = {
								target = root.capital_province.county
							}
						}
					}
					change_title_holder = {
						holder = scope:new_county_holder
						change = scope:change
					}
					#scope:new_county_holder = { get_title = prev }
				}
				becomes_independent = {
					change = scope:change
				}
				resolve_title_and_vassal_change = scope:change
				if = { # Just in case they need to create a duchy
					limit = {
						gold < 500
					}
					add_gold = 500
				}
			}
		}
	}
	else_if = { # Significant, AI Only
		limit = {
			has_game_rule = ai_significant_exclave_independence
			is_ai = yes
			NOT = {
				any_vassal_or_below = {
					is_ai = no
				}
			}
		}
		
		remove_character_flag = delayed_cleanse
		
		root.capital_province.county = {
			every_connected_county = { # Start off by making a list of all disconnected Counties
				invert = yes
				max_naval_distance = 2000
				add_to_list = disconnected_counties
			}
		}
		
		every_in_list = {
			list = disconnected_counties
			
			limit = {
				target_is_de_jure_liege_or_above = root.primary_title
			}
			add_to_list = cull_de_jure_connection_counties
		}
		
		while = {
			limit = {
				any_in_list = {
					list = cull_de_jure_connection_counties
				}
			}
			random_in_list = {
				list = cull_de_jure_connection_counties
				
				save_scope_as = cull_origin_county
				
				every_connected_county = {
					remove_from_list = cull_de_jure_connection_counties
					remove_from_list = disconnected_counties
				}
				remove_from_list = cull_de_jure_connection_counties
				remove_from_list = disconnected_counties
			}
		}
		
		every_in_list = {
			list = disconnected_counties
			
			limit = {
				any_connected_county = {
					NOT = { is_in_list = disconnected_counties }
					max_naval_distance = 2000
				}
			}
			add_to_list = cull_naval_connection_counties
		}
		
		while = {
			limit = {
				any_in_list = {
					list = cull_naval_connection_counties
				}
			}
			random_in_list = {
				list = cull_naval_connection_counties
				
				save_scope_as = cull_origin_county
				
				every_connected_county = {
					remove_from_list = cull_naval_connection_counties
					remove_from_list = disconnected_counties
				}
				remove_from_list = cull_naval_connection_counties
				remove_from_list = disconnected_counties
			}
		}
		
		every_in_list = { # Release Kings first
			list = disconnected_counties
			
			limit = {
				holder.primary_title.tier = tier_kingdom
				NOR = {
					holder = root
					holder = {
						any_sub_realm_title = {
							tier = tier_county
							NOT = { is_in_list = disconnected_counties }
						}
					}
				}
			}
			holder = {
				create_title_and_vassal_change = {
					type = independency
					save_scope_as = change
					add_claim_on_loss = yes
				}
				becomes_independent = {
					change = scope:change
				}
				resolve_title_and_vassal_change = scope:change
			}
		}
		
		every_in_list = { # Release Dukes second
			list = disconnected_counties
			
			limit = {
				holder.primary_title.tier = tier_duchy
				NOR = {
					holder = root
					holder = {
						any_sub_realm_title = {
							tier = tier_county
							NOT = { is_in_list = disconnected_counties }
						}
					}
				}
			}
			holder = {
				create_title_and_vassal_change = {
					type = independency
					save_scope_as = change
					add_claim_on_loss = yes
				}
				becomes_independent = {
					change = scope:change
				}
				resolve_title_and_vassal_change = scope:change
			}
		}
		
		every_in_list = { # Release Counts last
			list = disconnected_counties
			
			limit = {
				holder.primary_title.tier = tier_county
				NOR = {
					holder = root
					holder = {
						any_sub_realm_title = {
							tier = tier_county
							NOT = { is_in_list = disconnected_counties }
						}
					}
				}
			}
			holder = {
				create_title_and_vassal_change = {
					type = independency
					save_scope_as = change
					add_claim_on_loss = yes
				}
				becomes_independent = {
					change = scope:change
				}
				resolve_title_and_vassal_change = scope:change
			}
		}
		
		every_in_list = { # Finally, release contiguous areas under someone from the pool
			list = disconnected_counties
			
			limit = {
				OR = {
					holder.top_liege = root
					holder = root
				}
			}
			
			save_scope_as = county_of_origin
			
			every_pool_character = {
				province = scope:county_of_origin.title_province
				limit = {
					is_available_adult = yes
				}
				add_to_list = potential_holders
			}
			
			every_pool_character = {
				province = scope:county_of_origin.holder.capital_province
				limit = {
					is_available_adult = yes
				}
				add_to_list = potential_holders
			}
			
			if = {
				limit = {
					NOT = {
						any_in_list = {
							list = potential_holders
							is_available_adult = yes
						}
					}
				}
				create_character = {
					location = scope:county_of_origin.title_province
					culture = scope:county_of_origin.culture
					faith = scope:county_of_origin.faith
					gender_female_chance = 50

					#Warcraft
					#age = age_32_value
					age = 32 #TODO: Add scaling back

					save_scope_as = backup_character
				}
				scope:backup_character = {
					# Warcraft
					trigger_race_giving_no_gene_effect = yes			#Assigns race trait
					
					add_to_list = potential_holders
				}
			}
			
			random_in_list = {
				list = potential_holders
				limit = {
					is_available_adult = yes
					has_claim_on = scope:county_of_origin
					faith = {
						has_dominant_ruling_gender = prev
					}
				}
				alternative_limit = {
					is_available_adult = yes
					culture = scope:county_of_origin.culture
					faith = scope:county_of_origin.faith
					faith = {
						has_dominant_ruling_gender = prev
					}
				}
				alternative_limit = {
					is_available_adult = yes
					culture = scope:county_of_origin.culture
					faith = {
						has_dominant_ruling_gender = prev
					}
				}
				alternative_limit = {
					is_available_adult = yes
					faith = scope:county_of_origin.faith
					faith = {
						has_dominant_ruling_gender = prev
					}
				}
				alternative_limit = {
					is_available_adult = yes
					faith = {
						has_dominant_ruling_gender = prev
					}
				}
				alternative_limit = {
					is_available_adult = yes
					has_claim_on = scope:county_of_origin
				}
				alternative_limit = {
					is_available_adult = yes
					culture = scope:county_of_origin.culture
					faith = scope:county_of_origin.faith
				}
				alternative_limit = {
					is_available_adult = yes
					culture = scope:county_of_origin.culture
				}
				alternative_limit = {
					is_available_adult = yes
					faith = scope:county_of_origin.faith
				}
				alternative_limit = {
					is_available_adult = yes
				}
				
				save_scope_as = new_county_holder
				#get_title = scope:county_of_origin
				
				create_title_and_vassal_change = {
					type = independency
					save_scope_as = change
					add_claim_on_loss = yes
				}
				every_in_list = {
					list = disconnected_counties
					limit = {
						OR = {
							holder.top_liege = root
							holder = root
						}
						is_connected_to = {
							target = scope:county_of_origin
						}
						NOT ={
							is_connected_to = {
								target = root.capital_province.county
							}
						}
					}
					change_title_holder = {
						holder = scope:new_county_holder
						change = scope:change
					}
					#scope:new_county_holder = { get_title = prev }
				}
				becomes_independent = {
					change = scope:change
				}
				resolve_title_and_vassal_change = scope:change
				if = { # Just in case they need to create a duchy
					limit = {
						gold < 500
					}
					add_gold = 500
				}
			}
		}
	}
	else_if = { # Total, AI only
		limit = {
			has_game_rule = ai_total_exclave_independence
			is_ai = yes
			NOT = {
				any_vassal_or_below = {
					is_ai = no
				}
			}
		}
		
		remove_character_flag = delayed_cleanse
	
		root.capital_province.county = {
			every_connected_county = { # Start off by making a list of all disconnected Counties
				invert = yes
				max_naval_distance = 2000
				add_to_list = disconnected_counties
			}
		}
		
		every_in_list = {
			list = disconnected_counties
			
			limit = {
				any_connected_county = {
					NOT = { is_in_list = disconnected_counties }
					max_naval_distance = 2000
				}
			}
			add_to_list = cull_naval_connection_counties
		}
		
		while = {
			limit = {
				any_in_list = {
					list = cull_naval_connection_counties
				}
			}
			random_in_list = {
				list = cull_naval_connection_counties
				
				save_scope_as = cull_origin_county
				
				every_connected_county = {
					remove_from_list = cull_naval_connection_counties
					remove_from_list = disconnected_counties
				}
				remove_from_list = cull_naval_connection_counties
				remove_from_list = disconnected_counties
			}
		}
		
		every_in_list = { # Release Kings first
			list = disconnected_counties
			
			limit = {
				holder.primary_title.tier = tier_kingdom
				NOR = {
					holder = root
					holder = {
						any_sub_realm_title = {
							tier = tier_county
							NOT = { is_in_list = disconnected_counties }
						}
					}
				}
			}
			holder = {
				create_title_and_vassal_change = {
					type = independency
					save_scope_as = change
					add_claim_on_loss = yes
				}
				becomes_independent = {
					change = scope:change
				}
				resolve_title_and_vassal_change = scope:change
			}
		}
		
		every_in_list = { # Release Dukes second
			list = disconnected_counties
			
			limit = {
				holder.primary_title.tier = tier_duchy
				NOR = {
					holder = root
					holder = {
						any_sub_realm_title = {
							tier = tier_county
							NOT = { is_in_list = disconnected_counties }
						}
					}
				}
			}
			holder = {
				create_title_and_vassal_change = {
					type = independency
					save_scope_as = change
					add_claim_on_loss = yes
				}
				becomes_independent = {
					change = scope:change
				}
				resolve_title_and_vassal_change = scope:change
			}
		}
		
		every_in_list = { # Release Counts last
			list = disconnected_counties
			
			limit = {
				holder.primary_title.tier = tier_county
				NOR = {
					holder = root
					holder = {
						any_sub_realm_title = {
							tier = tier_county
							NOT = { is_in_list = disconnected_counties }
						}
					}
				}
			}
			holder = {
				create_title_and_vassal_change = {
					type = independency
					save_scope_as = change
					add_claim_on_loss = yes
				}
				becomes_independent = {
					change = scope:change
				}
				resolve_title_and_vassal_change = scope:change
			}
		}
		
		every_in_list = { # Finally, release contiguous areas under someone from the pool
			list = disconnected_counties
			
			limit = {
				OR = {
					holder.top_liege = root
					holder = root
				}
			}
			
			save_scope_as = county_of_origin
			
			every_pool_character = {
				province = scope:county_of_origin.title_province
				limit = {
					is_available_adult = yes
				}
				add_to_list = potential_holders
			}
			
			every_pool_character = {
				province = scope:county_of_origin.holder.capital_province
				limit = {
					is_available_adult = yes
				}
				add_to_list = potential_holders
			}
			
			if = {
				limit = {
					NOT = {
						any_in_list = {
							list = potential_holders
							is_available_adult = yes
						}
					}
				}
				create_character = {
					location = scope:county_of_origin.title_province
					culture = scope:county_of_origin.culture
					faith = scope:county_of_origin.faith
					gender_female_chance = 50

					#Warcraft
					#age = age_32_value
					age = 32 #TODO: Add scaling back

					save_scope_as = backup_character
				}
				scope:backup_character = {
					# Warcraft
					trigger_race_giving_no_gene_effect = yes			#Assigns race trait
					
					add_to_list = potential_holders
				}
			}		
			
			random_in_list = {
				list = potential_holders
				limit = {
					is_available_adult = yes
					has_claim_on = scope:county_of_origin
					faith = {
						has_dominant_ruling_gender = prev
					}
				}
				alternative_limit = {
					is_available_adult = yes
					culture = scope:county_of_origin.culture
					faith = scope:county_of_origin.faith
					faith = {
						has_dominant_ruling_gender = prev
					}
				}
				alternative_limit = {
					is_available_adult = yes
					culture = scope:county_of_origin.culture
					faith = {
						has_dominant_ruling_gender = prev
					}
				}
				alternative_limit = {
					is_available_adult = yes
					faith = scope:county_of_origin.faith
					faith = {
						has_dominant_ruling_gender = prev
					}
				}
				alternative_limit = {
					is_available_adult = yes
					faith = {
						has_dominant_ruling_gender = prev
					}
				}
				alternative_limit = {
					is_available_adult = yes
					has_claim_on = scope:county_of_origin
				}
				alternative_limit = {
					is_available_adult = yes
					culture = scope:county_of_origin.culture
					faith = scope:county_of_origin.faith
				}
				alternative_limit = {
					is_available_adult = yes
					culture = scope:county_of_origin.culture
				}
				alternative_limit = {
					is_available_adult = yes
					faith = scope:county_of_origin.faith
				}
				alternative_limit = {
					is_available_adult = yes
				}
				
				save_scope_as = new_county_holder
				#get_title = scope:county_of_origin
				
				create_title_and_vassal_change = {
					type = independency
					save_scope_as = change
					add_claim_on_loss = yes
				}
				every_in_list = {
					list = disconnected_counties
					limit = {
						OR = {
							holder.top_liege = root
							holder = root
						}
						is_connected_to = {
							target = scope:county_of_origin
						}
						NOT ={
							is_connected_to = {
								target = root.capital_province.county
							}
						}
					}
					change_title_holder = {
						holder = scope:new_county_holder
						change = scope:change
					}
					#scope:new_county_holder = { get_title = prev }
				}
				becomes_independent = {
					change = scope:change
				}
				resolve_title_and_vassal_change = scope:change
				if = { # Just in case they need to create a duchy
					limit = {
						gold < 500
					}
					add_gold = 500
				}
			}
		}
	}
	else_if = { # Limited: Land connected to Capital, De Jure of Primary Title, or one gap away, as well as coastal
		limit = {
			has_game_rule = limited_exclave_independence
		}
		
		remove_character_flag = delayed_cleanse
	
		root.capital_province.county = {
			every_connected_county = { # Start off by making a list of all disconnected Counties
				invert = yes
				max_naval_distance = 2000
				allow_one_county_land_gap = yes
				add_to_list = disconnected_counties
			}
		}
		
		every_in_list = {
			list = disconnected_counties
			
			limit = {
				any_connected_county = {
					NOT = { is_in_list = disconnected_counties }
					max_naval_distance = 2000
				}
			}
			add_to_list = cull_naval_connection_counties
		}
		
		while = {
			limit = {
				any_in_list = {
					list = cull_naval_connection_counties
				}
			}
			random_in_list = {
				list = cull_naval_connection_counties
				
				save_scope_as = cull_origin_county
				
				every_connected_county = {
					remove_from_list = cull_naval_connection_counties
					remove_from_list = disconnected_counties
				}
				remove_from_list = cull_naval_connection_counties
				remove_from_list = disconnected_counties
			}
		}
		
		every_in_list = {
			list = disconnected_counties
			
			limit = {
				target_is_de_jure_liege_or_above = root.primary_title
			}
			add_to_list = cull_de_jure_connection_counties
		}
		
		while = {
			limit = {
				any_in_list = {
					list = cull_de_jure_connection_counties
				}
			}
			random_in_list = {
				list = cull_de_jure_connection_counties
				
				save_scope_as = cull_origin_county
				
				every_connected_county = {
					remove_from_list = cull_de_jure_connection_counties
					remove_from_list = disconnected_counties
				}
				remove_from_list = cull_de_jure_connection_counties
				remove_from_list = disconnected_counties
			}
		}
		
		every_in_list = { # Release Kings first
			list = disconnected_counties
			
			limit = {
				holder.primary_title.tier = tier_kingdom
				NOR = {
					holder = root
					holder = {
						any_sub_realm_title = {
							tier = tier_county
							NOT = { is_in_list = disconnected_counties }
						}
					}
				}
			}
			holder = {
				create_title_and_vassal_change = {
					type = independency
					save_scope_as = change
					add_claim_on_loss = yes
				}
				becomes_independent = {
					change = scope:change
				}
				resolve_title_and_vassal_change = scope:change
			}
		}
		
		every_in_list = { # Release Dukes second
			list = disconnected_counties
			
			limit = {
				holder.primary_title.tier = tier_duchy
				NOR = {
					holder = root
					holder = {
						any_sub_realm_title = {
							tier = tier_county
							NOT = { is_in_list = disconnected_counties }
						}
					}
				}
			}
			holder = {
				create_title_and_vassal_change = {
					type = independency
					save_scope_as = change
					add_claim_on_loss = yes
				}
				becomes_independent = {
					change = scope:change
				}
				resolve_title_and_vassal_change = scope:change
			}
		}
		
		every_in_list = { # Release Counts last
			list = disconnected_counties
			
			limit = {
				holder.primary_title.tier = tier_county
				NOR = {
					holder = root
					holder = {
						any_sub_realm_title = {
							tier = tier_county
							NOT = { is_in_list = disconnected_counties }
						}
					}
				}
			}
			holder = {
				create_title_and_vassal_change = {
					type = independency
					save_scope_as = change
					add_claim_on_loss = yes
				}
				becomes_independent = {
					change = scope:change
				}
				resolve_title_and_vassal_change = scope:change
			}
		}
		
		every_in_list = { # Finally, release contiguous areas under someone from the pool
			list = disconnected_counties
			
			limit = {
				OR = {
					holder.top_liege = root
					holder = root
				}
			}
			
			save_scope_as = county_of_origin
			
			every_pool_character = {
				province = scope:county_of_origin.title_province
				limit = {
					is_available_adult = yes
				}
				add_to_list = potential_holders
			}
			
			every_pool_character = {
				province = scope:county_of_origin.holder.capital_province
				limit = {
					is_available_adult = yes
				}
				add_to_list = potential_holders
			}
			
			if = {
				limit = {
					NOT = {
						any_in_list = {
							list = potential_holders
							is_available_adult = yes
						}
					}
				}
				create_character = {
					location = scope:county_of_origin.title_province
					culture = scope:county_of_origin.culture
					faith = scope:county_of_origin.faith
					gender_female_chance = 50

					#Warcraft
					#age = age_32_value
					age = 32 #TODO: Add scaling back

					save_scope_as = backup_character
				}
				scope:backup_character = {
					# Warcraft
					trigger_race_giving_no_gene_effect = yes			#Assigns race trait
					
					add_to_list = potential_holders
				}
			}
			
			random_in_list = {
				list = potential_holders
				limit = {
					is_available_adult = yes
					has_claim_on = scope:county_of_origin
					faith = {
						has_dominant_ruling_gender = prev
					}
				}
				alternative_limit = {
					is_available_adult = yes
					culture = scope:county_of_origin.culture
					faith = scope:county_of_origin.faith
					faith = {
						has_dominant_ruling_gender = prev
					}
				}
				alternative_limit = {
					is_available_adult = yes
					culture = scope:county_of_origin.culture
					faith = {
						has_dominant_ruling_gender = prev
					}
				}
				alternative_limit = {
					is_available_adult = yes
					faith = scope:county_of_origin.faith
					faith = {
						has_dominant_ruling_gender = prev
					}
				}
				alternative_limit = {
					is_available_adult = yes
					faith = {
						has_dominant_ruling_gender = prev
					}
				}
				alternative_limit = {
					is_available_adult = yes
					has_claim_on = scope:county_of_origin
				}
				alternative_limit = {
					is_available_adult = yes
					culture = scope:county_of_origin.culture
					faith = scope:county_of_origin.faith
				}
				alternative_limit = {
					is_available_adult = yes
					culture = scope:county_of_origin.culture
				}
				alternative_limit = {
					is_available_adult = yes
					faith = scope:county_of_origin.faith
				}
				alternative_limit = {
					is_available_adult = yes
				}
				
				save_scope_as = new_county_holder
				#get_title = scope:county_of_origin
				
				create_title_and_vassal_change = {
					type = independency
					save_scope_as = change
					add_claim_on_loss = yes
				}
				every_in_list = {
					list = disconnected_counties
					limit = {
						OR = {
							holder.top_liege = root
							holder = root
						}
						is_connected_to = {
							target = scope:county_of_origin
						}
						NOT ={
							is_connected_to = {
								target = root.capital_province.county
							}
						}
					}
					change_title_holder = {
						holder = scope:new_county_holder
						change = scope:change
					}
					#scope:new_county_holder = { get_title = prev }
				}
				becomes_independent = {
					change = scope:change
				}
				resolve_title_and_vassal_change = scope:change
				if = { # Just in case they need to create a duchy
					limit = {
						gold < 500
					}
					add_gold = 500
				}
			}
		}
	}
	else_if = { # Significant: Land connected to Capital or De Jure of Primary Title, and coastal
		limit = {
			has_game_rule = significant_exclave_independence
		}
		
		remove_character_flag = delayed_cleanse
	
		root.capital_province.county = {
			every_connected_county = { # Start off by making a list of all disconnected Counties
				invert = yes
				max_naval_distance = 2000
				add_to_list = disconnected_counties
			}
		}
		
		every_in_list = {
			list = disconnected_counties
			
			limit = {
				target_is_de_jure_liege_or_above = root.primary_title
			}
			add_to_list = cull_de_jure_connection_counties
		}
		
		while = {
			limit = {
				any_in_list = {
					list = cull_de_jure_connection_counties
				}
			}
			random_in_list = {
				list = cull_de_jure_connection_counties
				
				save_scope_as = cull_origin_county
				
				every_connected_county = {
					remove_from_list = cull_de_jure_connection_counties
					remove_from_list = disconnected_counties
				}
				remove_from_list = cull_de_jure_connection_counties
				remove_from_list = disconnected_counties
			}
		}
		
		while = {
			limit = {
				any_in_list = {
					list = disconnected_counties
					
					any_connected_county = {
						NOT = { is_in_list = disconnected_counties }
						max_naval_distance = 2000
					}
				}
			}
			random_in_list = {
				list = disconnected_counties
				
				limit = {
					any_connected_county = {
						NOT = { is_in_list = disconnected_counties }
						max_naval_distance = 2000
					}
				}
				
				remove_from_list = disconnected_counties
			}
		}
		
		every_in_list = { # Release Kings first
			list = disconnected_counties
			
			limit = {
				holder.primary_title.tier = tier_kingdom
				NOR = {
					holder = root
					holder = {
						any_sub_realm_title = {
							tier = tier_county
							NOT = { is_in_list = disconnected_counties }
						}
					}
				}
			}
			holder = {
				create_title_and_vassal_change = {
					type = independency
					save_scope_as = change
					add_claim_on_loss = yes
				}
				becomes_independent = {
					change = scope:change
				}
				resolve_title_and_vassal_change = scope:change
			}
		}
		
		every_in_list = { # Release Dukes second
			list = disconnected_counties
			
			limit = {
				holder.primary_title.tier = tier_duchy
				NOR = {
					holder = root
					holder = {
						any_sub_realm_title = {
							tier = tier_county
							NOT = { is_in_list = disconnected_counties }
						}
					}
				}
			}
			holder = {
				create_title_and_vassal_change = {
					type = independency
					save_scope_as = change
					add_claim_on_loss = yes
				}
				becomes_independent = {
					change = scope:change
				}
				resolve_title_and_vassal_change = scope:change
			}
		}
		
		every_in_list = { # Release Counts last
			list = disconnected_counties
			
			limit = {
				holder.primary_title.tier = tier_county
				NOR = {
					holder = root
					holder = {
						any_sub_realm_title = {
							tier = tier_county
							NOT = { is_in_list = disconnected_counties }
						}
					}
				}
			}
			holder = {
				create_title_and_vassal_change = {
					type = independency
					save_scope_as = change
					add_claim_on_loss = yes
				}
				becomes_independent = {
					change = scope:change
				}
				resolve_title_and_vassal_change = scope:change
			}
		}
		
		every_in_list = { # Finally, release contiguous areas under someone from the pool
			list = disconnected_counties
			
			limit = {
				OR = {
					holder.top_liege = root
					holder = root
				}
			}
			
			save_scope_as = county_of_origin
			
			every_pool_character = {
				province = scope:county_of_origin.title_province
				limit = {
					is_available_adult = yes
				}
				add_to_list = potential_holders
			}
			
			every_pool_character = {
				province = scope:county_of_origin.holder.capital_province
				limit = {
					is_available_adult = yes
				}
				add_to_list = potential_holders
			}
			
			if = {
				limit = {
					NOT = {
						any_in_list = {
							list = potential_holders
							is_available_adult = yes
						}
					}
				}
				create_character = {
					location = scope:county_of_origin.title_province
					culture = scope:county_of_origin.culture
					faith = scope:county_of_origin.faith
					gender_female_chance = 50

					#Warcraft
					#age = age_32_value
					age = 32 #TODO: Add scaling back

					save_scope_as = backup_character
				}
				scope:backup_character = {
					# Warcraft
					trigger_race_giving_no_gene_effect = yes			#Assigns race trait
					
					add_to_list = potential_holders
				}
			}
			
			random_in_list = {
				list = potential_holders
				limit = {
					is_available_adult = yes
					has_claim_on = scope:county_of_origin
					faith = {
						has_dominant_ruling_gender = prev
					}
				}
				alternative_limit = {
					is_available_adult = yes
					culture = scope:county_of_origin.culture
					faith = scope:county_of_origin.faith
					faith = {
						has_dominant_ruling_gender = prev
					}
				}
				alternative_limit = {
					is_available_adult = yes
					culture = scope:county_of_origin.culture
					faith = {
						has_dominant_ruling_gender = prev
					}
				}
				alternative_limit = {
					is_available_adult = yes
					faith = scope:county_of_origin.faith
					faith = {
						has_dominant_ruling_gender = prev
					}
				}
				alternative_limit = {
					is_available_adult = yes
					faith = {
						has_dominant_ruling_gender = prev
					}
				}
				alternative_limit = {
					is_available_adult = yes
					has_claim_on = scope:county_of_origin
				}
				alternative_limit = {
					is_available_adult = yes
					culture = scope:county_of_origin.culture
					faith = scope:county_of_origin.faith
				}
				alternative_limit = {
					is_available_adult = yes
					culture = scope:county_of_origin.culture
				}
				alternative_limit = {
					is_available_adult = yes
					faith = scope:county_of_origin.faith
				}
				alternative_limit = {
					is_available_adult = yes
				}
				
				save_scope_as = new_county_holder
				#get_title = scope:county_of_origin
				
				create_title_and_vassal_change = {
					type = independency
					save_scope_as = change
					add_claim_on_loss = yes
				}
				every_in_list = {
					list = disconnected_counties
					limit = {
						OR = {
							holder.top_liege = root
							holder = root
						}
						is_connected_to = {
							target = scope:county_of_origin
						}
						NOT ={
							is_connected_to = {
								target = root.capital_province.county
							}
						}
					}
					change_title_holder = {
						holder = scope:new_county_holder
						change = scope:change
					}
					#scope:new_county_holder = { get_title = prev }
				}
				becomes_independent = {
					change = scope:change
				}
				resolve_title_and_vassal_change = scope:change
				if = { # Just in case they need to create a duchy
					limit = {
						gold < 500
					}
					add_gold = 500
				}
			}
		}
	}
	else_if = { # Total: Only keep things connected to your capital, or coastal
		limit = {
			has_game_rule = total_exclave_independence
		}
		
		remove_character_flag = delayed_cleanse
	
		root.capital_province.county = {
			every_connected_county = { # Start off by making a list of all disconnected Counties
				invert = yes
				max_naval_distance = 2000
				add_to_list = disconnected_counties
			}
		}
		
		every_in_list = {
			list = disconnected_counties
			
			limit = {
				any_connected_county = {
					NOT = { is_in_list = disconnected_counties }
					max_naval_distance = 2000
				}
			}
			add_to_list = cull_naval_connection_counties
		}
		
		while = {
			limit = {
				any_in_list = {
					list = cull_naval_connection_counties
				}
			}
			random_in_list = {
				list = cull_naval_connection_counties
				
				save_scope_as = cull_origin_county
				
				every_connected_county = {
					remove_from_list = cull_naval_connection_counties
					remove_from_list = disconnected_counties
				}
				remove_from_list = cull_naval_connection_counties
				remove_from_list = disconnected_counties
			}
		}
		
		every_in_list = { # Release Kings first
			list = disconnected_counties
			
			limit = {
				holder.primary_title.tier = tier_kingdom
				NOR = {
					holder = root
					holder = {
						any_sub_realm_title = {
							tier = tier_county
							NOT = { is_in_list = disconnected_counties }
						}
					}
				}
			}
			holder = {
				create_title_and_vassal_change = {
					type = independency
					save_scope_as = change
					add_claim_on_loss = yes
				}
				becomes_independent = {
					change = scope:change
				}
				resolve_title_and_vassal_change = scope:change
			}
		}
		
		every_in_list = { # Release Dukes second
			list = disconnected_counties
			
			limit = {
				holder.primary_title.tier = tier_duchy
				NOR = {
					holder = root
					holder = {
						any_sub_realm_title = {
							tier = tier_county
							NOT = { is_in_list = disconnected_counties }
						}
					}
				}
			}
			holder = {
				create_title_and_vassal_change = {
					type = independency
					save_scope_as = change
					add_claim_on_loss = yes
				}
				becomes_independent = {
					change = scope:change
				}
				resolve_title_and_vassal_change = scope:change
			}
		}
		
		every_in_list = { # Release Counts last
			list = disconnected_counties
			
			limit = {
				holder.primary_title.tier = tier_county
				NOR = {
					holder = root
					holder = {
						any_sub_realm_title = {
							tier = tier_county
							NOT = { is_in_list = disconnected_counties }
						}
					}
				}
			}
			holder = {
				create_title_and_vassal_change = {
					type = independency
					save_scope_as = change
					add_claim_on_loss = yes
				}
				becomes_independent = {
					change = scope:change
				}
				resolve_title_and_vassal_change = scope:change
			}
		}
		
		every_in_list = { # Finally, release contiguous areas under someone from the pool
			list = disconnected_counties
			
			limit = {
				OR = {
					holder.top_liege = root
					holder = root
				}
			}
			
			save_scope_as = county_of_origin
			
			every_pool_character = {
				province = scope:county_of_origin.title_province
				limit = {
					is_available_adult = yes
				}
				add_to_list = potential_holders
			}
			
			every_pool_character = {
				province = scope:county_of_origin.holder.capital_province
				limit = {
					is_available_adult = yes
				}
				add_to_list = potential_holders
			}
			
			if = {
				limit = {
					NOT = {
						any_in_list = {
							list = potential_holders
							is_available_adult = yes
						}
					}
				}
				create_character = {
					location = scope:county_of_origin.title_province
					culture = scope:county_of_origin.culture
					faith = scope:county_of_origin.faith
					gender_female_chance = 50

					#Warcraft
					#age = age_32_value
					age = 32 #TODO: Add scaling back

					save_scope_as = backup_character
				}
				scope:backup_character = {
					# Warcraft
					trigger_race_giving_no_gene_effect = yes			#Assigns race trait
					
					add_to_list = potential_holders
				}
			}
			
			random_in_list = {
				list = potential_holders
				limit = {
					is_available_adult = yes
					has_claim_on = scope:county_of_origin
					faith = {
						has_dominant_ruling_gender = prev
					}
				}
				alternative_limit = {
					is_available_adult = yes
					culture = scope:county_of_origin.culture
					faith = scope:county_of_origin.faith
					faith = {
						has_dominant_ruling_gender = prev
					}
				}
				alternative_limit = {
					is_available_adult = yes
					culture = scope:county_of_origin.culture
					faith = {
						has_dominant_ruling_gender = prev
					}
				}
				alternative_limit = {
					is_available_adult = yes
					faith = scope:county_of_origin.faith
					faith = {
						has_dominant_ruling_gender = prev
					}
				}
				alternative_limit = {
					is_available_adult = yes
					faith = {
						has_dominant_ruling_gender = prev
					}
				}
				alternative_limit = {
					is_available_adult = yes
					has_claim_on = scope:county_of_origin
				}
				alternative_limit = {
					is_available_adult = yes
					culture = scope:county_of_origin.culture
					faith = scope:county_of_origin.faith
				}
				alternative_limit = {
					is_available_adult = yes
					culture = scope:county_of_origin.culture
				}
				alternative_limit = {
					is_available_adult = yes
					faith = scope:county_of_origin.faith
				}
				alternative_limit = {
					is_available_adult = yes
				}
				
				save_scope_as = new_county_holder
				#get_title = scope:county_of_origin
				
				create_title_and_vassal_change = {
					type = independency
					save_scope_as = change
					add_claim_on_loss = yes
				}
				every_in_list = {
					list = disconnected_counties
					limit = {
						OR = {
							holder.top_liege = root
							holder = root
						}
						is_connected_to = {
							target = scope:county_of_origin
						}
						NOT ={
							is_connected_to = {
								target = root.capital_province.county
							}
						}
					}
					change_title_holder = {
						holder = scope:new_county_holder
						change = scope:change
					}
					#scope:new_county_holder = { get_title = prev }
				}
				becomes_independent = {
					change = scope:change
				}
				resolve_title_and_vassal_change = scope:change
				if = { # Just in case they need to create a duchy
					limit = {
						gold < 500
					}
					add_gold = 500
				}
			}
		}
	}
}

###############
# HARM EVENTS #
###############

# Controls logging for harm events where the character is killed.
## Unless you're specifically looking to gather easy death metrics whilst run testing, this should always be toggled off.
log_harm_event_death_as_variable_effect = {
	if = {
		limit = { always = no }
		if = {
			# Only track noteworthy characters.
			limit = { harm_game_rule_valid_for_logging_trigger = yes }
			add_to_global_variable_list = {
				name = harm_deaths_list
				target = root
			}
		}
	}
	# And, for error suppression.
	if = {
		limit = { always = no }
		if = {
			limit = {
				global_variable_list_size = {
					name = harm_deaths_list
					value >= 1
				}
			}
		}
	}
}

# Controls logging for harm events where the character is rendered incapable.
## Unless you're specifically looking to gather easy death metrics whilst run testing, this should always be toggled off.
log_harm_event_incapability_as_variable_effect = {
	if = {
		limit = { always = no }
		if = {
			# Only track noteworthy characters.
			limit = { harm_game_rule_valid_for_logging_trigger = yes }
			add_to_global_variable_list = {
				name = harm_incapables_list
				target = root
			}
		}
	}
	# And, for error suppression.
	if = {
		limit = { always = no }
		if = {
			limit = {
				global_variable_list_size = {
					name = harm_incapables_list
					value >= 1
				}
			}
		}
	}
}

# Controls logging for harm events where the character survives.
## Unless you're specifically looking to gather easy death metrics whilst run testing, this should always be toggled off.
log_harm_event_spared_as_variable_effect = {
	if = {
		limit = { always = no }
		if = {
			# Only track noteworthy characters.
			limit = { harm_game_rule_valid_for_logging_trigger = yes }
			add_to_global_variable_list = {
				name = harm_spared_list
				target = root
			}
		}
	}
	# And, for error suppression.
	if = {
		limit = { always = no }
		if = {
			limit = {
				global_variable_list_size = {
					name = harm_spared_list
					value >= 1
				}
			}
		}
	}
}
