wc_on_mana_regeneration = {
	effect = {
		if = {
			limit = { has_variable = wc_current_mana_variable }

			wc_change_mana_by_value_effect = {
				CHANGE = add
				VALUE = wc_mana_regeneration_value
			}
		}
		else = {
			set_variable = { name = wc_current_mana_variable value = wc_max_mana_value }
			wc_recalculate_prowess_from_mana_effect = yes
		}
		magic_buff_maintenance_effect = yes 
		trigger_event = { on_action = wc_on_mana_regeneration months = 1 }
	}
}

wc_on_health_regeneration = {
	effect = {
		if = {
			limit = { has_variable = wc_current_hp_variable }
			wc_change_hp_by_value_effect = {
				CHANGE = add
				VALUE = wc_hp_replenishment_value
			}
		}
		
		else = {
			set_variable = { name = wc_current_hp_variable value = wc_hp_capacity_value }
		}

		trigger_event = { on_action = wc_on_health_regeneration months = 1 }
	}
}

wc_on_spell_progression = {
	effect = {
		every_in_list = {
			variable = current_spells_casting
			save_scope_as = casting_spell
			root = {
				execute_scoped_spell_effect = {
					SPELL = scope:casting_spell
					EFFECT = add_spell_progression_effect
				}
			}
		}
		every_in_list = {
			variable = spells_cd
			save_scope_as = cd_spell
			root = {
				execute_scoped_spell_effect = {
					SPELL = scope:cd_spell
					EFFECT = update_spell_cooldown_effect
				}
			}
		}
		if = { # so it doesnt double count spells
			limit = {
				NOT = { exists = var:spell_loop_on }
			}
			set_variable = { name = spell_loop_on value = yes }
		}
		trigger_event = { on_action = wc_on_spell_progression days = 1 }
	}
}

## root is the caster
### before removing the mana of the spell cast and doing anything
### Variable prefix: current_
### Variables: spell_name, rank, targets_list (variable list), recipient, elemental_type (for elemental type), class (spell class), target_type
### e.g. var:current_spell_type = flag:decay
wc_on_spell_cast_started = {

}

## root is the caster
### upon finishing the spell cast, before setting cd or anything ###
### Variable prefix: casted_
### Variables: spell, recipient, targets_list (variable list), rank, type (for elemental type), class (spell class), target_type
### e.g. var:casted_spell = flag:lava_lash
wc_on_spell_cast_finish = {
	effect = {
		# Send interface message to caster
		send_interface_message = {
			title = spell_cast_complete_title
			custom_tooltip = spell_cast_complete_desc
		}

		if = { # automatically used
			limit = {
				has_character_modifier = wc_backdraft_proc
			}
			remove_character_modifier = wc_backdraft_proc
		}

		# Send interface message to target 
		if = {
			limit = { 
				exists = var:casted_recipient
				var:casted_target_type = flag:character
				NOT = { var:casted_recipient = root }
			}
			var:casted_recipient = {
				save_temporary_scope_as = castee
			}
			scope:castee = {
				root = {
					save_temporary_scope_as = caster
				}
				set_variable = {
					name = on_casted_spell
					value = root.var:casted_spell
				}
				send_interface_message = {
					title = spell_cast_on_you_title
					custom_tooltip = spell_cast_on_you_desc
				}
			}
		}
		else_if = {
			limit = { 
				exists = var:casted_recipient
				var:casted_target_type = flag:title
				NOT = { var:casted_recipient.holder = root }
			}
			var:casted_recipient.holder = {
				save_temporary_scope_as = castee
			}
			scope:castee = {
				root = {
					save_temporary_scope_as = caster
				}
				set_variable = {
					name = on_casted_spell
					value = root.var:casted_spell
				}
				send_interface_message = {
					title = spell_cast_on_you_title
					custom_tooltip = spell_cast_on_you_desc
				}
			}
		}
		else_if = {
			limit = { 
				has_variable_list = casted_targets_list
				var:casted_target_type = flag:character_list
			}
			every_in_list = {
				variable = spell_targets_list
				save_scope_as = new_target
				if = {
					limit = {
						NOT = { scope:new_target = root }
					}
					scope:new_target = {
						set_variable = {
							name = on_casted_spell
							value = root.var:casted_spell
						}
						send_interface_message = {
							title = spell_cast_on_you_title
							custom_tooltip = spell_cast_on_you_desc
						}
					}
				}
			}
		}
		else_if = {
			limit = { 
				has_variable_list = casted_targets_list
				var:casted_target_type = flag:title_list
			}
			every_in_list = {
				variable = spell_targets_list
				save_scope_as = new_target
				if = {
					limit = {
						NOT = { scope:new_target.holder = root }
					}
					scope:new_target.holder = {
						set_variable = {
							name = on_casted_spell
							value = root.var:casted_spell
						}
						send_interface_message = {
							title = spell_cast_on_you_title
							custom_tooltip = spell_cast_on_you_desc
						}
					}
				}
			}
		}
		else_if = {
			limit = { 
				exists = var:casted_recipient
				OR = {
					var:casted_target_type = flag:army
					var:casted_target_type = flag:friendly_army
					var:casted_target_type = flag:enemy_army
				}
				NOT = { var:casted_recipient.army_owner = root }
			}
			var:casted_recipient.army_owner = {
				save_temporary_scope_as = castee
			}
			scope:castee = {
				root = {
					save_temporary_scope_as = caster
				}
				set_variable = {
					name = on_casted_spell
					value = root.var:casted_spell
				}
				send_interface_message = {
					title = spell_cast_on_you_title
					custom_tooltip = spell_cast_on_you_desc
				}
			}
		}

		## BACKDRAFT
		if = {
			limit = {
				exists = var:casted_recipient # Is it on a title
				var:casted_target_type = flag:title
				OR = { # is it the required spell type
					var:casted_class = flag:elemental_fire
					var:casted_class = flag:elemental_earth
					var:casted_class = flag:elemental_water
					var:casted_class = flag:elemental_air
					var:casted_class = flag:disorder
					var:casted_class = flag:order
				}
				# The spell is not backdraft itself
				NOT = { var:casted_spell = flag:backdraft }
			}
			
			if = {
				limit = {
					var:casted_recipient = {
						title_province = {
							has_variable = backdraft_monitor
						}
					}
				}
				var:casted_recipient = {
					title_province = {
						save_scope_as = recipient
					}
				}
				scope:recipient = {
					var:backdraft_monitor = {
						save_scope_as = monitor
					}
				}
				scope:monitor = {
					execute_scoped_spell_effect = {
						SPELL = root.var:casted_spell
						EFFECT = backdraft_proc_effect
					}
				}
				scope:recipient = {
					remove_variable = backdraft_monitor
				}
			}
			
			
		}
		else_if = {
			limit = {
				var:casted_target_type = flag:title_list
				OR = { # is it the required spell type
					var:casted_class = flag:elemental_fire
					var:casted_class = flag:elemental_earth
					var:casted_class = flag:elemental_water
					var:casted_class = flag:elemental_air
					var:casted_class = flag:disorder
					var:casted_class = flag:order
				}
				# The spell is not backdraft itself
				NOT = { var:casted_spell = flag:backdraft }
			}
			every_in_list = {
				variable = current_targets_list
				limit = {
					title_province = { has_variable = backdraft_monitor }
				}
				save_scope_as = provin
				title_province = {
					var:backdraft_monitor = {
						save_Scope_as = monitor
					}
				}
				scope:monitor = {
					scope:provin = {
						save_scope_as = current_province
					}
					execute_scoped_spell_effect = {
						SPELL = root.var:current_spell_name
						EFFECT = backdraft_proc_effect
					}
				}
			}
		}

		## PYROMANIA
		if = {
			limit = {
				has_perk = elemental_fire_magic_tree_1_perk_2
			}
			if = {
				limit = {
					var:casted_class = flag:elemental_fire
				}
				random_list = {
					75 = {}
					25 = {
						send_interface_message = {
							title = wc_pyromania_title
							add_character_modifier = {
								modifier = wc_pyromania_modifier
								days = 365
							}
						}
					}
				}
			}
			else_if = {
				limit = {
					has_character_modifier = wc_pyromania_modifier
				}
				# Remove modifier
				send_interface_message = {
					title = wc_pyromania_title_lost
					remove_character_modifier = wc_pyromania_modifier
				}
				# this actually removes all the stacks
				while = {
					limit = {
						has_character_modifier = wc_pyromania_modifier
					}
					remove_character_modifier = wc_pyromania_modifier
				}
			}
		}

		## BURNOUT
		clear_burnout_effect = yes

		# Clear Scorch cooldown when hit with elemental or fel hostile magic
		if = {
			limit = {
				exists = var:casted_recipient
				var:casted_target_type = flag:character
				NOT = { var:casted_recipient = root }
				OR = {
					var:casted_class = flag:elemental_fire
					var:casted_class = flag:elemental_earth
					var:casted_class = flag:elemental_water
					var:casted_class = flag:elemental_air
					var:casted_class = flag:disorder
				}
				spell_is_harmful_trigger = {
					SPELL = var:casted_spell
				}
			}

			var:casted_recipient = {
				remove_spell_cooldown_effect = { SPELL = scorch }
			}
		}

		# Burn caster when target has Fire Shield
		if = {
			limit = {
				exists = var:casted_recipient
				var:casted_target_type = flag:character
				var:casted_recipient = {
					has_character_modifier = wc_fire_shield_modifier
				}
				spell_is_harmful_trigger = {
					SPELL = var:casted_spell
				}
			}

			# TODO: Maybe remove Fire Shield modifier?

			root = {
				add_or_increase_burned_effect = yes

				send_interface_toast = {
					title = wc_spell_reflected
					left_icon = root
					right_icon = scope:this_recipient.holder
					custom_tooltip = wc_fire_shield_reflect_tt # TODO
				}
			}
		}
	}
}