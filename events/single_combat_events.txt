namespace = single_combat

##################################################
# # SINGLE COMBAT EVENTS
# 0001 - 0020	Participant Events
# 0021 - 0030	Round End Events
# 0031 - 0050	Results Events
# 1001 - 1020	Debug Events
#
##################################################




##################################################
# MISC SCRIPTED TRIGGERS

# If scope:fatality = flag:default, then will a character die when the duel is concluded?
scripted_trigger fatality_default_will_die_trigger = {
	scope:sc_attacker = {
		OR = {
			#scope:sc_attacker is tribal.
			AND = {
				is_ruler = yes
				government_has_flag = government_is_tribal
			}
			#scope:sc_attacker has a tribal court_owner.
			AND = {
				is_ruler = no
				exists = court_owner
				scope:sc_attacker.court_owner = { government_has_flag = government_is_tribal}
			}
			#scope:sc_attacker has a tribal host.
			AND = {
				is_ruler = no
				exists = host
				scope:sc_attacker.host = { government_has_flag = government_is_tribal }
			}
			#scope:sc_attacker is isolated & landless, in which case we check scope:sc_defender.
			AND = {
				is_ruler = no
				NOR = {
					exists = court_owner
					exists = host
				}
				scope:sc_defender = {
					OR = {
						#scope:sc_defender is tribal.
						AND = {
							is_ruler = yes
							government_has_flag = government_is_tribal
						}
						#scope:sc_defender has a tribal court_owner.
						AND = {
							is_ruler = no
							exists = court_owner
							scope:sc_defender.court_owner = { government_has_flag = government_is_tribal}
						}
						#scope:sc_defender has a tribal host.
						AND = {
							is_ruler = no
							exists = host
							scope:sc_defender.host = { government_has_flag = government_is_tribal }
						}
					}
				}
			}
		}
	}
}

# Will the duel end in the death of your opponent for any reason? 
scripted_trigger duel_will_end_in_opponent_death_trigger = {
	# Hard disable if fatality has been disabled.
	NOT = { scope:fatality = flag:no }
	OR = {
		# The duel has default fatality enabled & validated.
		fatality_default_will_die_trigger = yes
		# The duel has fatality possible & your opponent is already critically wounded.
		OR = {
			AND = {
				this = scope:sc_attacker
				scope:fatality = flag:possible
				scope:sc_defender = { has_trait = wounded_3 }
			}
			AND = {
				this = scope:sc_defender
				scope:fatality = flag:possible
				scope:sc_attacker = { has_trait = wounded_3 }
			}
		}
		# Fatality has been force-enabled.
		scope:fatality = flag:always
	}
}

scripted_trigger duel_will_end_in_my_death_trigger = {
	# Hard disable if fatality has been disabled.
	NOT = { scope:fatality = flag:no }
	OR = {
		# The duel has default fatality enabled & validated.
		fatality_default_will_die_trigger = yes
		# The duel has fatality possible & you are already critically wounded.
		AND = {
			scope:fatality = flag:possible
			has_trait = wounded_3
		}
		# Fatality has been force-enabled.
		scope:fatality = flag:always
	}
}

scripted_trigger house_not_allowed_to_yell_motto_trigger = {
	# Warcraft
	always = no
}

scripted_trigger rocky_locale_trigger = {
	OR = {
		terrain = hills
		terrain = mountains
		terrain = desert_mountains
	}
}

##################################################
# GENERAL SCRIPTED EFFECTS

# Grab a single special move from the list for this character to use this round.
scripted_effect select_special_tier_move_effect = {
	#First, we flag that the character now has a special move option.
	set_local_variable = {
		name = combat_move_special_slot_used_flag
		value = yes
	}
	#Then, we pick which move they get.
	random_list = {
		# High Secondary Skill moves
		## Reason You Suck Speech
		1000 = {
			trigger = {
				NOT = { exists = local_var:combat_move_reason_you_suck_speech_flag }
				diplomacy >= very_high_skill_rating
				# Block special moves twice in a row.
				NOR = {
					AND = {
						exists = scope:sc_defender_last_move
						this = scope:sc_defender
						scope:sc_defender_last_move = flag:reason_you_suck_speech
					}
					AND = {
						exists = scope:sc_attacker_last_move
						this = scope:sc_attacker
						scope:sc_attacker_last_move = flag:reason_you_suck_speech
					}
				}
			}
			set_local_variable = {
				name = combat_move_reason_you_suck_speech_flag
				value = yes
			}
		}
		## Technique from Legend
		1000 = {
			trigger = {
				NOT = { exists = local_var:combat_move_technique_from_legend_flag }
				learning >= very_high_skill_rating
				# Block special moves twice in a row.
				NOR = {
					AND = {
						exists = scope:sc_defender_last_move
						this = scope:sc_defender
						scope:sc_defender_last_move = flag:technique_from_legend
					}
					AND = {
						exists = scope:sc_attacker_last_move
						this = scope:sc_attacker
						scope:sc_attacker_last_move = flag:technique_from_legend
					}
				}
			}
			set_local_variable = {
				name = combat_move_technique_from_legend_flag
				value = yes
			}
		}
		## Like a Viper
		1000 = {
			trigger = {
				NOT = { exists = local_var:combat_move_like_a_viper_flag }
				intrigue >= very_high_skill_rating
				# Block special moves twice in a row.
				NOR = {
					AND = {
						exists = scope:sc_defender_last_move
						this = scope:sc_defender
						scope:sc_defender_last_move = flag:like_a_viper
					}
					AND = {
						exists = scope:sc_attacker_last_move
						this = scope:sc_attacker
						scope:sc_attacker_last_move = flag:like_a_viper
					}
				}
			}
			set_local_variable = {
				name = combat_move_like_a_viper_flag
				value = yes
			}
		}
		## Pocket Silver
		1000 = {
			trigger = {
				NOT = { exists = local_var:combat_move_pocket_silver_flag }
				stewardship >= very_high_skill_rating
				short_term_gold >= combat_move_pocket_silver_value
				# Move essentially requires two arms, I'm afraid.
				NOT = { has_trait = maimed }
				# Block special moves twice in a row.
				NOR = {
					AND = {
						exists = scope:sc_defender_last_move
						this = scope:sc_defender
						scope:sc_defender_last_move = flag:pocket_silver
					}
					AND = {
						exists = scope:sc_attacker_last_move
						this = scope:sc_attacker
						scope:sc_attacker_last_move = flag:pocket_silver
					}
				}
			}
			set_local_variable = {
				name = combat_move_pocket_silver_flag
				value = yes
			}
		}
		## Martial Voice
		1000 = {
			trigger = {
				NOT = { exists = local_var:combat_move_martial_voice_flag }
				martial >= very_high_skill_rating
				# For now, the loc relies on your opponent being noble, so you ironically can't use your peasant-commanding voice on actual peasants.
				OR = {
					AND = {
						this = scope:sc_defender
						scope:sc_attacker = {
							exists = house
							NOR = {
								has_trait = peasant_leader
								government_has_flag = government_is_republic
							}
						}
					}
					AND = {
						this = scope:sc_attacker
						scope:sc_defender = {
							exists = house
							NOR = {
								has_trait = peasant_leader
								government_has_flag = government_is_republic
							}
						}
					}
				}
				# Block special moves twice in a row.
				NOR = {
					AND = {
						exists = scope:sc_defender_last_move
						this = scope:sc_defender
						scope:sc_defender_last_move = flag:martial_voice
					}
					AND = {
						exists = scope:sc_attacker_last_move
						this = scope:sc_attacker
						scope:sc_attacker_last_move = flag:martial_voice
					}
				}
			}
			set_local_variable = {
				name = combat_move_martial_voice_flag
				value = yes
			}
		}
		## Mocking Boast
		1000 = {
			trigger = {
				NOT = { exists = local_var:combat_move_mocking_boast_flag }
				OR = {
					AND = {
						this = scope:sc_attacker
						scope:sc_attacker.prestige_level > scope:sc_defender.prestige_level
						# A humble opponent doesn't give two shits.
						scope:sc_defender = {
							NOT = { has_trait = humble }
						}
					}
					AND = {
						this = scope:sc_defender
						scope:sc_defender.prestige_level > scope:sc_attacker.prestige_level
						# A humble opponent doesn't give two shits.
						scope:sc_attacker = {
							NOT = { has_trait = humble }
						}
					}
				}
				# Block special moves twice in a row.
				NOR = {
					AND = {
						exists = scope:sc_defender_last_move
						this = scope:sc_defender
						scope:sc_defender_last_move = flag:mocking_boast
					}
					AND = {
						exists = scope:sc_attacker_last_move
						this = scope:sc_attacker
						scope:sc_attacker_last_move = flag:mocking_boast
					}
				}
			}
			set_local_variable = {
				name = combat_move_mocking_boast_flag
				value = yes
			}
		}
		# Location-Specific moves
		## Is that a Crocodile?!
		1 = {	#Super-rare, pretty much an instant kill.
			trigger = {
				NOT = { exists = local_var:combat_move_is_that_a_crocodile_flag }
				# Must be happening in a wild environment.
				scope:locale = flag:terrain_scope
				# Can't have already had a crocodile used by either party this duel.
				NOT = { exists = scope:had_crocodile }
				# Must be in a place that has crocodiles.
				single_combat_location_has_crocodilians_trigger = yes
				# Duel must be one that would end in fatality.
				duel_will_end_in_opponent_death_trigger = yes
			}
			set_local_variable = {
				name = combat_move_is_that_a_crocodile_flag
				value = yes
			}
			# No down-weight for something that's already 0.001%.
		}
		## Desert Warrior
		1000 = {
			trigger = {
				NOT = { exists = local_var:combat_move_desert_warrior_flag }
				has_trait = desert_warrior
				# Must be happening in a wild environment.
				scope:locale = flag:terrain_scope
				#Both characters being experts cancel each other out.
				NAND = {
					scope:sc_attacker = { has_trait = desert_warrior }
					scope:sc_defender = { has_trait = desert_warrior }
				}
				scope:sc_defender.location = {
					OR = {
						terrain = desert
						terrain = drylands
						terrain = oasis
					}
				}
				# Block special moves twice in a row.
				NOR = {
					AND = {
						exists = scope:sc_defender_last_move
						this = scope:sc_defender
						scope:sc_defender_last_move = flag:desert_warrior
					}
					AND = {
						exists = scope:sc_attacker_last_move
						this = scope:sc_attacker
						scope:sc_attacker_last_move = flag:desert_warrior
					}
				}
			}
			set_local_variable = {
				name = combat_move_desert_warrior_flag
				value = yes
			}
		}
		## Jungle Stalker
		1000 = {
			trigger = {
				NOT = { exists = local_var:combat_move_jungle_stalker_flag }
				has_trait = jungle_stalker
				# Must be happening in a wild environment.
				scope:locale = flag:terrain_scope
				#Both characters being experts cancel each other out.
				NAND = {
					scope:sc_attacker = { has_trait = jungle_stalker }
					scope:sc_defender = { has_trait = jungle_stalker }
				}
				scope:sc_defender.location = {
					terrain = jungle
				}
				# Block special moves twice in a row.
				NOR = {
					AND = {
						exists = scope:sc_defender_last_move
						this = scope:sc_defender
						scope:sc_defender_last_move = flag:jungle_stalker
					}
					AND = {
						exists = scope:sc_attacker_last_move
						this = scope:sc_attacker
						scope:sc_attacker_last_move = flag:jungle_stalker
					}
				}
			}
			set_local_variable = {
				name = combat_move_jungle_stalker_flag
				value = yes
			}
		}
		## Open Terrain Expert
		1000 = {
			trigger = {
				NOT = { exists = local_var:combat_move_open_terrain_expert_flag }
				has_trait = open_terrain_expert
				# Must be happening in a wild environment.
				scope:locale = flag:terrain_scope
				#Both characters being experts cancel each other out.
				NAND = {
					scope:sc_attacker = { has_trait = open_terrain_expert }
					scope:sc_defender = { has_trait = open_terrain_expert }
				}
				scope:sc_defender.location = {
					OR = {
						terrain = farmlands
						terrain = plains
						terrain = steppe
					}
				}
				# Block special moves twice in a row.
				NOR = {
					AND = {
						exists = scope:sc_defender_last_move
						this = scope:sc_defender
						scope:sc_defender_last_move = flag:open_terrain_expert
					}
					AND = {
						exists = scope:sc_attacker_last_move
						this = scope:sc_attacker
						scope:sc_attacker_last_move = flag:open_terrain_expert
					}
				}
			}
			set_local_variable = {
				name = combat_move_open_terrain_expert_flag
				value = yes
			}
		}
		## Rough Terrain Expert
		1000 = {
			trigger = {
				NOT = { exists = local_var:combat_move_rough_terrain_expert_flag }
				has_trait = rough_terrain_expert
				# Must be happening in a wild environment.
				scope:locale = flag:terrain_scope
				#Both characters being experts cancel each other out.
				NAND = {
					scope:sc_attacker = { has_trait = rough_terrain_expert }
					scope:sc_defender = { has_trait = rough_terrain_expert }
				}
				scope:sc_defender.location = {
					OR = {
						terrain = hills
						terrain = mountains
						terrain = desert_mountains	#Technically a desert, but not for single combat purposes.
						terrain = wetlands
					}
				}
				# Block special moves twice in a row.
				NOR = {
					AND = {
						exists = scope:sc_defender_last_move
						this = scope:sc_defender
						scope:sc_defender_last_move = flag:rough_terrain_expert
					}
					AND = {
						exists = scope:sc_attacker_last_move
						this = scope:sc_attacker
						scope:sc_attacker_last_move = flag:rough_terrain_expert
					}
				}
			}
			set_local_variable = {
				name = combat_move_rough_terrain_expert_flag
				value = yes
			}
		}
		## Forest Fighter
		1000 = {
			trigger = {
				NOT = { exists = local_var:combat_move_forest_fighter_flag }
				has_trait = forest_fighter
				# Must be happening in a wild environment.
				scope:locale = flag:terrain_scope
				#Both characters being experts cancel each other out.
				NAND = {
					scope:sc_attacker = { has_trait = forest_fighter }
					scope:sc_defender = { has_trait = forest_fighter }
				}
				scope:sc_defender.location = {
					OR = {
						terrain = forest
						terrain = taiga
					}
				}
				# Block special moves twice in a row.
				NOR = {
					AND = {
						exists = scope:sc_defender_last_move
						this = scope:sc_defender
						scope:sc_defender_last_move = flag:forest_fighter
					}
					AND = {
						exists = scope:sc_attacker_last_move
						this = scope:sc_attacker
						scope:sc_attacker_last_move = flag:forest_fighter
					}
				}
			}
			set_local_variable = {
				name = combat_move_forest_fighter_flag
				value = yes
			}
		}
		# Trait-Specific moves
		## RAAARGH!
		5000 = {
			trigger = {
				NOT = { exists = local_var:combat_move_raaargh_flag }
				has_trait = berserker
				# Block special moves twice in a row.
				NOR = {
					AND = {
						exists = scope:sc_defender_last_move
						this = scope:sc_defender
						scope:sc_defender_last_move = flag:raaargh
					}
					AND = {
						exists = scope:sc_attacker_last_move
						this = scope:sc_attacker
						scope:sc_attacker_last_move = flag:raaargh
					}
				}
			}
			set_local_variable = {
				name = combat_move_raaargh_flag
				value = yes
			}
		}
		## Hard Grit
		2000 = {
			trigger = {
				NOT = { exists = local_var:combat_move_hard_grit_flag }
				has_trait = shieldmaiden
				# Block special moves twice in a row.
				NOR = {
					AND = {
						exists = scope:sc_defender_last_move
						this = scope:sc_defender
						scope:sc_defender_last_move = flag:hard_grit
					}
					AND = {
						exists = scope:sc_attacker_last_move
						this = scope:sc_attacker
						scope:sc_attacker_last_move = flag:hard_grit
					}
				}
			}
			set_local_variable = {
				name = combat_move_hard_grit_flag
				value = yes
			}
		}
		## Feint & Stab
		2000 = {
			trigger = {
				NOT = { exists = local_var:combat_move_feint_and_stab_flag }
				has_trait = lifestyle_hunter
				# Move specifically requires two arms, I'm afraid.
				NOT = { has_trait = maimed }
				# Block special moves twice in a row.
				NOR = {
					AND = {
						exists = scope:sc_defender_last_move
						this = scope:sc_defender
						scope:sc_defender_last_move = flag:feint_and_stab
					}
					AND = {
						exists = scope:sc_attacker_last_move
						this = scope:sc_attacker
						scope:sc_attacker_last_move = flag:feint_and_stab
					}
				}
			}
			set_local_variable = {
				name = combat_move_feint_and_stab_flag
				value = yes
			}
		}
		## Butchery
		2000 = {
			trigger = {
				NOT = { exists = local_var:combat_move_butchery_flag }
				has_trait = viking
				# Block special moves twice in a row.
				NOR = {
					AND = {
						exists = scope:sc_defender_last_move
						this = scope:sc_defender
						scope:sc_defender_last_move = flag:butchery
					}
					AND = {
						exists = scope:sc_attacker_last_move
						this = scope:sc_attacker
						scope:sc_attacker_last_move = flag:butchery
					}
				}
			}
			set_local_variable = {
				name = combat_move_butchery_flag
				value = yes
			}
		}
		
		# Warcraft
		# ## Stoic Veteran
		# 2000 = {
			# trigger = {
				# NOT = { exists = local_var:combat_move_stoic_veteran_flag }
				# has_trait = varangian
				# # Can't use the Varangian trait against the Eastern Roman Emperor, as that's just not cricket.
				# NOR = {
					# AND = {
						# this = scope:sc_defender
						# scope:sc_attacker = { has_title = title:e_byzantium }
					# }
					# AND = {
						# this = scope:sc_attacker
						# scope:sc_defender = { has_title = title:e_byzantium }
					# }
				# }
				# # Block special moves twice in a row.
				# NOR = {
					# AND = {
						# exists = scope:sc_defender_last_move
						# this = scope:sc_defender
						# scope:sc_defender_last_move = flag:stoic_veteran
					# }
					# AND = {
						# exists = scope:sc_attacker_last_move
						# this = scope:sc_attacker
						# scope:sc_attacker_last_move = flag:stoic_veteran
					# }
				# }
			# }
			# set_local_variable = {
				# name = combat_move_stoic_veteran_flag
				# value = yes
			# }
		# }
		
		## Blade Dance
		2000 = {
			trigger = {
				NOT = { exists = local_var:combat_move_blade_dance_flag }
				has_trait = lifestyle_blademaster
				# Block special moves twice in a row.
				NOR = {
					AND = {
						exists = scope:sc_defender_last_move
						this = scope:sc_defender
						scope:sc_defender_last_move = flag:blade_dance
					}
					AND = {
						exists = scope:sc_attacker_last_move
						this = scope:sc_attacker
						scope:sc_attacker_last_move = flag:blade_dance
					}
				}
			}
			set_local_variable = {
				name = combat_move_blade_dance_flag
				value = yes
			}
		}
		## Wrath of [HighGod]
		1000 = {
			trigger = {
				NOT = { exists = local_var:combat_move_wrath_of_highgod_flag }
				has_trait = zealous
				faith = {
					NOT = { has_doctrine_parameter = holy_wars_forbidden }
				}
				# Block special moves twice in a row.
				NOR = {
					AND = {
						exists = scope:sc_defender_last_move
						this = scope:sc_defender
						scope:sc_defender_last_move = flag:wrath_of_highgod
					}
					AND = {
						exists = scope:sc_attacker_last_move
						this = scope:sc_attacker
						scope:sc_attacker_last_move = flag:wrath_of_highgod
					}
				}
			}
			set_local_variable = {
				name = combat_move_wrath_of_highgod_flag
				value = yes
			}
		}
		## Hurt Me Better
		2000 = {
			trigger = {
				NOT = { exists = local_var:combat_move_hurt_me_better_flag }
				OR = {
					has_trait = deviant
					any_secret = { secret_type = secret_deviant }
				}
				# Block special moves twice in a row.
				NOR = {
					AND = {
						exists = scope:sc_defender_last_move
						this = scope:sc_defender
						scope:sc_defender_last_move = flag:hurt_me_better
					}
					AND = {
						exists = scope:sc_attacker_last_move
						this = scope:sc_attacker
						scope:sc_attacker_last_move = flag:hurt_me_better
					}
				}
			}
			set_local_variable = {
				name = combat_move_hurt_me_better_flag
				value = yes
			}
		}
		# Misc moves
		## Kick a rock at their shin.
		1 = {	#Fallback move; we don't really ever want to see this.
			trigger = {
				NOT = { exists = local_var:combat_move_special_fallback_flag }
				#Fallback, always available.
			}
			set_local_variable = {
				name = combat_move_special_fallback_flag
				value = yes
			}
			# No down-weight for something that's already 0.001%.
		}
		## Something to Hide
		1000 = {
			trigger = {
				NOT = { exists = local_var:combat_move_something_to_hide_flag }
				OR = {
					AND = {
						this = scope:sc_attacker
						has_usable_hook = scope:sc_defender
					}
					AND = {
						this = scope:sc_defender
						has_usable_hook = scope:sc_attacker
					}
				}
				# The single combat cannot be fatal, or this is moot.
				duel_will_end_in_opponent_death_trigger = no
				# Block special moves twice in a row.
				NOR = {
					AND = {
						exists = scope:sc_defender_last_move
						this = scope:sc_defender
						scope:sc_defender_last_move = flag:something_to_hide
					}
					AND = {
						exists = scope:sc_attacker_last_move
						this = scope:sc_attacker
						scope:sc_attacker_last_move = flag:something_to_hide
					}
				}
			}
			set_local_variable = {
				name = combat_move_something_to_hide_flag
				value = yes
			}
		}
	}
}

# Select a single tier 1 combat move from the list.
scripted_effect select_tier_1_move_effect = {
	random_list = {
		#Ordinary moves.
		70 = {
			random_list = {
				# Wait and Hope
				1000 = {
					trigger = {
						NOT = { exists = local_var:combat_move_wait_and_hope_flag }
						#Fallback, always available.
					}
					set_local_variable = {
						name = combat_move_wait_and_hope_flag
						value = yes
					}
					# Weight down repeat moves
					modifier = {
						add = sce_regular_combat_repeat_down_weight
						OR = {
							AND = {
								exists = scope:sc_defender_last_move
								this = scope:sc_defender
								scope:sc_defender_last_move = flag:wait_and_hope
							}
							AND = {
								exists = scope:sc_attacker_last_move
								this = scope:sc_attacker
								scope:sc_attacker_last_move = flag:wait_and_hope
							}
						}
					}
				}
				# Unsure Attack
				1000 = {
					trigger = {
						NOT = { exists = local_var:combat_move_unsure_attack_flag }
						#Fallback, always available.
					}
					set_local_variable = {
						name = combat_move_unsure_attack_flag
						value = yes
					}
					# Weight down repeat moves
					modifier = {
						add = sce_regular_combat_repeat_down_weight
						OR = {
							AND = {
								exists = scope:sc_defender_last_move
								this = scope:sc_defender
								scope:sc_defender_last_move = flag:unsure_attack
							}
							AND = {
								exists = scope:sc_attacker_last_move
								this = scope:sc_attacker
								scope:sc_attacker_last_move = flag:unsure_attack
							}
						}
					}
				}
				# Enthusiastic Onslaught
				1000 = {
					trigger = {
						NOT = { exists = local_var:combat_move_enthusiastic_onslaught_flag }
						#Fallback, always available.
					}
					set_local_variable = {
						name = combat_move_enthusiastic_onslaught_flag
						value = yes
					}
					# Weight down repeat moves
					modifier = {
						add = sce_regular_combat_repeat_down_weight
						OR = {
							AND = {
								exists = scope:sc_defender_last_move
								this = scope:sc_defender
								scope:sc_defender_last_move = flag:enthusiastic_onslaught
							}
							AND = {
								exists = scope:sc_attacker_last_move
								this = scope:sc_attacker
								scope:sc_attacker_last_move = flag:enthusiastic_onslaught
							}
						}
					}
				}
				# Hail Mary
				1000 = {
					trigger = {
						NOT = { exists = local_var:combat_move_hail_mary_flag }
						#Only valid against an opponent who _truly_ outclasses you.
						OR = {
							AND = {
								this = scope:sc_attacker
								prowess_diff = {
									target = scope:sc_defender
									value <= -10
								}
							}
							AND = {
								this = scope:sc_defender
								prowess_diff = {
									target = scope:sc_attacker
									value <= -10
								}
							}
						}
					}
					set_local_variable = {
						name = combat_move_hail_mary_flag
						value = yes
					}
					# Weight down repeat moves
					modifier = {
						add = sce_regular_combat_repeat_down_weight
						OR = {
							AND = {
								exists = scope:sc_defender_last_move
								this = scope:sc_defender
								scope:sc_defender_last_move = flag:hail_mary
							}
							AND = {
								exists = scope:sc_attacker_last_move
								this = scope:sc_attacker
								scope:sc_attacker_last_move = flag:hail_mary
							}
						}
					}
				}
				# Pocket Sand
				1000 = {
					trigger = {
						NOT = { exists = local_var:combat_move_pocket_sand_flag }
						#Only valid against opponents who really won't be able to see it coming a mile away.
						OR = {
							AND = {
								this = scope:sc_attacker
								scope:sc_defender.prowess <= medium_scsk
							}
							AND = {
								this = scope:sc_defender
								scope:sc_attacker.prowess <= medium_scsk
							}
						}
						# Move essentially requires two arms, I'm afraid.
						NOT = { has_trait = maimed }
					}
					set_local_variable = {
						name = combat_move_pocket_sand_flag
						value = yes
					}
					# Weight down repeat moves
					modifier = {
						add = sce_regular_combat_repeat_down_weight
						OR = {
							AND = {
								exists = scope:sc_defender_last_move
								this = scope:sc_defender
								scope:sc_defender_last_move = flag:pocket_sand
							}
							AND = {
								exists = scope:sc_attacker_last_move
								this = scope:sc_attacker
								scope:sc_attacker_last_move = flag:pocket_sand
							}
						}
					}
				}
				# Nut 'em
				1000 = {
					trigger = {
						NOT = { exists = local_var:combat_move_nut_em_flag }
						#No special requirements.
					}
					set_local_variable = {
						name = combat_move_nut_em_flag
						value = yes
					}
					# Weight down repeat moves
					modifier = {
						add = sce_regular_combat_repeat_down_weight
						OR = {
							AND = {
								exists = scope:sc_defender_last_move
								this = scope:sc_defender
								scope:sc_defender_last_move = flag:nut_em
							}
							AND = {
								exists = scope:sc_attacker_last_move
								this = scope:sc_attacker
								scope:sc_attacker_last_move = flag:nut_em
							}
						}
					}
				}
			}
		}
		#Special moves.
		30 = {
			trigger = {
				NOT = { exists = local_var:combat_move_special_slot_used_flag }
			}
			select_special_tier_move_effect = yes
		}
	}
}

# Select a single tier 2 combat move from the list.
scripted_effect select_tier_2_move_effect = {
	random_list = {
		#Ordinary moves.
		70 = {
			random_list = {
				# Guard
				1000 = {
					trigger = {
						NOT = { exists = local_var:combat_move_guard_flag }
						#Fallback, always available.
					}
									set_local_variable = {
						name = combat_move_guard_flag
						value = yes
					}
					# Weight down repeat moves
					modifier = {
						add = sce_regular_combat_repeat_down_weight
						OR = {
							AND = {
								exists = scope:sc_defender_last_move
								this = scope:sc_defender
								scope:sc_defender_last_move = flag:guard
							}
							AND = {
								exists = scope:sc_attacker_last_move
								this = scope:sc_attacker
								scope:sc_attacker_last_move = flag:guard
							}
						}
					}
				}
				# Probing Attack
				1000 = {
					trigger = {
						NOT = { exists = local_var:combat_move_probing_attack_flag }
						#Fallback, always available.
					}
					set_local_variable = {
						name = combat_move_probing_attack_flag
						value = yes
					}
					# Weight down repeat moves
					modifier = {
						add = sce_regular_combat_repeat_down_weight
						OR = {
							AND = {
								exists = scope:sc_defender_last_move
								this = scope:sc_defender
								scope:sc_defender_last_move = flag:probing_attack
							}
							AND = {
								exists = scope:sc_attacker_last_move
								this = scope:sc_attacker
								scope:sc_attacker_last_move = flag:probing_attack
							}
						}
					}
				}
				# Onslaught
				1000 = {
					trigger = {
						NOT = { exists = local_var:combat_move_onslaught_flag }
						#Fallback, always available.
					}
									set_local_variable = {
						name = combat_move_onslaught_flag
						value = yes
					}
					# Weight down repeat moves
					modifier = {
						add = sce_regular_combat_repeat_down_weight
						OR = {
							AND = {
								exists = scope:sc_defender_last_move
								this = scope:sc_defender
								scope:sc_defender_last_move = flag:onslaught
							}
							AND = {
								exists = scope:sc_attacker_last_move
								this = scope:sc_attacker
								scope:sc_attacker_last_move = flag:onslaught
							}
						}
					}
				}
				# Surprise Attack
				1000 = {
					trigger = {
						NOT = { exists = local_var:combat_move_surprise_attack_flag }
						OR = {
							AND = {
								this = scope:sc_attacker
								scope:sc_defender = {
									NOT = { has_trait = paranoid }
								}
							}
							AND = {
								this = scope:sc_defender
								scope:sc_attacker = {
									NOT = { has_trait = paranoid }
								}
							}
						}
					}
					set_local_variable = {
						name = combat_move_surprise_attack_flag
						value = yes
					}
					# Weight down repeat moves
					modifier = {
						add = sce_regular_combat_repeat_down_weight
						OR = {
							AND = {
								exists = scope:sc_defender_last_move
								this = scope:sc_defender
								scope:sc_defender_last_move = flag:surprise_attack
							}
							AND = {
								exists = scope:sc_attacker_last_move
								this = scope:sc_attacker
								scope:sc_attacker_last_move = flag:surprise_attack
							}
						}
					}
				}
				# Taunt
				1000 = {
					trigger = {
						NOT = { exists = local_var:combat_move_taunt_flag }
						OR = {
							AND = {
								this = scope:sc_attacker
								scope:sc_defender = {
									is_ai = yes
									NOT = { has_trait = calm }
								}
							}
							AND = {
								this = scope:sc_defender
								scope:sc_attacker = {
									is_ai = yes
									NOT = { has_trait = calm }
								}
							}
						}
					}
									set_local_variable = {
						name = combat_move_taunt_flag
						value = yes
					}
					# Weight down repeat moves
					modifier = {
						add = sce_regular_combat_repeat_down_weight
						OR = {
							AND = {
								exists = scope:sc_defender_last_move
								this = scope:sc_defender
								scope:sc_defender_last_move = flag:taunt
							}
							AND = {
								exists = scope:sc_attacker_last_move
								this = scope:sc_attacker
								scope:sc_attacker_last_move = flag:taunt
							}
						}
					}
				}
				# Put the Boot In
				1000 = {
					trigger = {
						NOT = { exists = local_var:combat_move_put_the_boot_in_flag }
						#No special requirements.
					}
					set_local_variable = {
						name = combat_move_put_the_boot_in_flag
						value = yes
					}
					# Weight down repeat moves
					modifier = {
						add = sce_regular_combat_repeat_down_weight
						OR = {
							AND = {
								exists = scope:sc_defender_last_move
								this = scope:sc_defender
								scope:sc_defender_last_move = flag:put_the_boot_in
							}
							AND = {
								exists = scope:sc_attacker_last_move
								this = scope:sc_attacker
								scope:sc_attacker_last_move = flag:put_the_boot_in
							}
						}
					}
				}
			}
		}
		#Special moves.
		30 = {
			trigger = {
				NOT = { exists = local_var:combat_move_special_slot_used_flag }
			}
			select_special_tier_move_effect = yes
		}
	}
}

# Select a single tier 3 combat move from the list.
scripted_effect select_tier_3_move_effect = {
	random_list = {
		#Ordinary moves.
		70 = {
			random_list = {
				# Strict Guard
				1000 = {
					trigger = {
						NOT = { exists = local_var:combat_move_strict_guard_flag }
						#Fallback, always available.
					}
					set_local_variable = {
						name = combat_move_strict_guard_flag
						value = yes
					}
					# Weight down repeat moves
					modifier = {
						add = sce_regular_combat_repeat_down_weight
						OR = {
							AND = {
								exists = scope:sc_defender_last_move
								this = scope:sc_defender
								scope:sc_defender_last_move = flag:strict_guard
							}
							AND = {
								exists = scope:sc_attacker_last_move
								this = scope:sc_attacker
								scope:sc_attacker_last_move = flag:strict_guard
							}
						}
					}
				}
				# Confident Attack
				1000 = {
					trigger = {
						NOT = { exists = local_var:combat_move_confident_attack_flag }
						#Fallback, always available.
					}
					set_local_variable = {
						name = combat_move_confident_attack_flag
						value = yes
					}
					# Weight down repeat moves
					modifier = {
						add = sce_regular_combat_repeat_down_weight
						OR = {
							AND = {
								exists = scope:sc_defender_last_move
								this = scope:sc_defender
								scope:sc_defender_last_move = flag:confident_attack
							}
							AND = {
								exists = scope:sc_attacker_last_move
								this = scope:sc_attacker
								scope:sc_attacker_last_move = flag:confident_attack
							}
						}
					}
				}
				# Expert Onslaught
				1000 = {
					trigger = {
						NOT = { exists = local_var:combat_move_expert_onslaught_flag }
						#Fallback, always available.
					}
					set_local_variable = {
						name = combat_move_expert_onslaught_flag
						value = yes
					}
					# Weight down repeat moves
					modifier = {
						add = sce_regular_combat_repeat_down_weight
						OR = {
							AND = {
								exists = scope:sc_defender_last_move
								this = scope:sc_defender
								scope:sc_defender_last_move = flag:expert_onslaught
							}
							AND = {
								exists = scope:sc_attacker_last_move
								this = scope:sc_attacker
								scope:sc_attacker_last_move = flag:expert_onslaught
							}
						}
					}
				}
				# Attempt Disarm
				1000 = {
					trigger = {
						NOT = { exists = local_var:combat_move_attempt_disarm_flag }
						OR = {
							AND = {
								this = scope:sc_attacker
								scope:sc_defender = {
									prowess >= decent_scsk
									# Blademasters cannot be wrong-footed by a disarmament attempt.
									NOT = { has_trait = lifestyle_blademaster }
								}
							}
							AND = {
								this = scope:sc_defender
								scope:sc_attacker = {
									prowess >= decent_scsk
									# Blademasters cannot be wrong-footed by a disarmament attempt.
									NOT = { has_trait = lifestyle_blademaster }
								}
							}
						}
					}
					set_local_variable = {
						name = combat_move_attempt_disarm_flag
						value = yes
					}
					# Weight down repeat moves
					modifier = {
						add = sce_regular_combat_repeat_down_weight
						OR = {
							AND = {
								exists = scope:sc_defender_last_move
								this = scope:sc_defender
								scope:sc_defender_last_move = flag:attempt_disarm
							}
							AND = {
								exists = scope:sc_attacker_last_move
								this = scope:sc_attacker
								scope:sc_attacker_last_move = flag:attempt_disarm
							}
						}
					}
				}
				# Lightning Assault
				1000 = {
					trigger = {
						NOT = { exists = local_var:combat_move_lightning_assault_flag }
						scope:sc_defender.var:current_round = 1
					}
					set_local_variable = {
						name = combat_move_lightning_assault_flag
						value = yes
					}
					# Weight down repeat moves
					modifier = {
						add = sce_regular_combat_repeat_down_weight
						OR = {
							AND = {
								exists = scope:sc_defender_last_move
								this = scope:sc_defender
								scope:sc_defender_last_move = flag:lightning_assault
							}
							AND = {
								exists = scope:sc_attacker_last_move
								this = scope:sc_attacker
								scope:sc_attacker_last_move = flag:lightning_assault
							}
						}
					}
				}
				# Tire Opponent
				1000 = {
					trigger = {
						NOT = { exists = local_var:combat_move_tire_opponent_flag }
						#No special requirements.
					}
					set_local_variable = {
						name = combat_move_tire_opponent_flag
						value = yes
					}
					# Weight down repeat moves
					modifier = {
						add = sce_regular_combat_repeat_down_weight
						OR = {
							AND = {
								exists = scope:sc_defender_last_move
								this = scope:sc_defender
								scope:sc_defender_last_move = flag:tire_opponent
							}
							AND = {
								exists = scope:sc_attacker_last_move
								this = scope:sc_attacker
								scope:sc_attacker_last_move = flag:tire_opponent
							}
						}
					}
				}
			}
		}
		#Special moves.
		30 = {
			trigger = {
				NOT = { exists = local_var:combat_move_special_slot_used_flag }
			}
			select_special_tier_move_effect = yes
		}
	}
}

# Determine what tier of moves a character is getting this round, then pick them.
scripted_effect select_combat_options_from_pool_effect = {
	# DOCUMENTATION
	# First, we look at the single combat skill rating of the combatant, and use this to set tier variables for moves.
	## Only the best and worst combatants get guaranteed tier moves, all best & all worst tier respectively.
	## Second best and second worst have an even 50:50 to get all best/worst tier moves respectively, or to vary one of their move's tier levels by one (e.g., second worst getting x1 tier 2 move and x2 tier 1 moves).
	## Each subsequent step towards the middle of the skill_ratings moves the standard tier ratings by 1. So if mediocre_scsk and below is x3 tier 1 moves by default, then medium_scsk is x2 tier 1 and x1 tier 2 moves by default.
	## Medium, decent, high, and very_high skill_ratings then have a 33:34:33 chance to vary their tier moves down by one, use their default, or go up by one.
	### This gives us an element of randomness, but one that can be gamed within combat encounters by obtaining modifiers, and stacks the odds in favour of skilled warriors without making them the automatic victors every time.
	
	# MECHANICS
	# Roll for tier draws.
	## For the sake of easy tweakability, all tiers include all variables, so each one can be adjusted as needed for balance.
	## low_scsk or below
	if = {
		limit = { prowess <= low_scsk }
		#low_scsk *always* draws x3 tier 1 moves.
		set_variable = {
			name = tier_1_counter
			value = 3
		}
		set_variable = {
			name = tier_2_counter
			value = 0
		}
		set_variable = {
			name = tier_3_counter
			value = 0
		}
	}
	## mediocre_scsk or below
	else_if = {
		limit = { prowess <= mediocre_scsk }
		random_list = {
			#Bad roll, -1 to tier set.
			50 = {
				set_variable = {
					name = tier_1_counter
					value = 3
				}
				set_variable = {
					name = tier_2_counter
					value = 0
				}
				set_variable = {
					name = tier_3_counter
					value = 0
				}
			}
			#Average roll, default tier set.
			50 = {
				set_variable = {
					name = tier_1_counter
					value = 2
				}
				set_variable = {
					name = tier_2_counter
					value = 1
				}
				set_variable = {
					name = tier_3_counter
					value = 0
				}
			}
		}
	}
	## medium_scsk or below
	else_if = {
		limit = { prowess <= medium_scsk }
		random_list = {
			#Bad roll, -1 to tier set.
			33 = {
				set_variable = {
					name = tier_1_counter
					value = 3
				}
				set_variable = {
					name = tier_2_counter
					value = 0
				}
				set_variable = {
					name = tier_3_counter
					value = 0
				}
			}
			#Average roll, default tier set.
			34 = {
				set_variable = {
					name = tier_1_counter
					value = 2
				}
				set_variable = {
					name = tier_2_counter
					value = 1
				}
				set_variable = {
					name = tier_3_counter
					value = 0
				}
			}
			#Good roll, +1 to tier set.
			33 = {
				set_variable = {
					name = tier_1_counter
					value = 1
				}
				set_variable = {
					name = tier_2_counter
					value = 1
				}
				set_variable = {
					name = tier_3_counter
					value = 1
				}
			}
		}
	}
	## decent_scsk or below
	else_if = {
		limit = { prowess <= decent_scsk }
		random_list = {
			#Bad roll, -1 to tier set.
			33 = {
				set_variable = {
					name = tier_1_counter
					value = 2
				}
				set_variable = {
					name = tier_2_counter
					value = 1
				}
				set_variable = {
					name = tier_3_counter
					value = 0
				}
			}
			#Average roll, default tier set.
			34 = {
				set_variable = {
					name = tier_1_counter
					value = 1
				}
				set_variable = {
					name = tier_2_counter
					value = 1
				}
				set_variable = {
					name = tier_3_counter
					value = 1
				}
			}
			#Good roll, +1 to tier set.
			33 = {
				set_variable = {
					name = tier_1_counter
					value = 0
				}
				set_variable = {
					name = tier_2_counter
					value = 2
				}
				set_variable = {
					name = tier_3_counter
					value = 1
				}
			}
		}
	}
	## high_scsk or below
	else_if = {
		limit = { prowess <= high_scsk }
		random_list = {
			#Bad roll, -1 to tier set.
			33 = {
				set_variable = {
					name = tier_1_counter
					value = 1
				}
				set_variable = {
					name = tier_2_counter
					value = 1
				}
				set_variable = {
					name = tier_3_counter
					value = 1
				}
			}
			#Average roll, default tier set.
			34 = {
				set_variable = {
					name = tier_1_counter
					value = 0
				}
				set_variable = {
					name = tier_2_counter
					value = 2
				}
				set_variable = {
					name = tier_3_counter
					value = 1
				}
			}
			#Good roll, +1 to tier set.
			33 = {
				set_variable = {
					name = tier_1_counter
					value = 0
				}
				set_variable = {
					name = tier_2_counter
					value = 1
				}
				set_variable = {
					name = tier_3_counter
					value = 2
				}
			}
		}
	}
	## very_high_scsk or below
	else_if = {
		limit = { prowess <= very_high_scsk }
		random_list = {
			#Bad roll, -1 to tier set.
			33 = {
				set_variable = {
					name = tier_1_counter
					value = 0
				}
				set_variable = {
					name = tier_2_counter
					value = 2
				}
				set_variable = {
					name = tier_3_counter
					value = 1
				}
			}
			#Average roll, default tier set.
			34 = {
				set_variable = {
					name = tier_1_counter
					value = 0
				}
				set_variable = {
					name = tier_2_counter
					value = 1
				}
				set_variable = {
					name = tier_3_counter
					value = 2
				}
			}
			#Good roll, +1 to tier set.
			33 = {
				set_variable = {
					name = tier_1_counter
					value = 0
				}
				set_variable = {
					name = tier_2_counter
					value = 0
				}
				set_variable = {
					name = tier_3_counter
					value = 3
				}
			}
		}
	}
	## extremely_high_scsk or below
	else_if = {
		limit = { prowess <= extremely_high_scsk }
		random_list = {
			#Bad roll, -1 to tier set.
			50 = {
				set_variable = {
					name = tier_1_counter
					value = 0
				}
				set_variable = {
					name = tier_2_counter
					value = 1
				}
				set_variable = {
					name = tier_3_counter
					value = 2
				}
			}
			#Average roll, default tier set.
			50 = {
				set_variable = {
					name = tier_1_counter
					value = 0
				}
				set_variable = {
					name = tier_2_counter
					value = 0
				}
				set_variable = {
					name = tier_3_counter
					value = 3
				}
			}
		}
	}
	## more than extremely_high_scsk
	else = {
		#Better than extremely_high_scsk always draws x3 tier 3 moves.
		set_variable = {
			name = tier_1_counter
			value = 0
		}
		set_variable = {
			name = tier_2_counter
			value = 0
		}
		set_variable = {
			name = tier_3_counter
			value = 3
		}
	}

	# DOCUMENTATION
	# Next, clear all previous combat flags from the character, & iterate through each tier value up to three times, selecting valid moves from the set.
	## Every time we select a move, we reduce that tier's tier count variable by 1, so the player will only ever have three options available.
	## Each select_tier_[X]_move_effect set incorporates a mix of flat combat moves and special moves triggered by locations, traits, special circumstances, etc. Special moves are available at all tiers, but you can only roll x1 per round.
	## Every tier has at least three ordinary, standard moves that all characters can access, so characters will never not have a full roster of moves.

	# MECHANICS
	# Clear previous combat flags.
	remove_single_combat_character_local_variables_effect = yes
	# Iterate through combat move sets for each tier till we've got a full roster of moves.
	## Tier 1
	if = {
		limit = {
			# Check that the variable exists; strictly unnecessary, but stops a false positive clogging the error log.
			has_variable = tier_1_counter
			var:tier_1_counter > 0
		}
		change_variable = {
			name = tier_1_counter
			add = -1
		}
		select_tier_1_move_effect = yes
	}
	if = {
		limit = {
			# Check that the variable exists; strictly unnecessary, but stops a false positive clogging the error log.
			has_variable = tier_1_counter
			var:tier_1_counter > 0
		}
		change_variable = {
			name = tier_1_counter
			add = -1
		}
		select_tier_1_move_effect = yes
	}
	if = {
		limit = {
			# Check that the variable exists; strictly unnecessary, but stops a false positive clogging the error log.
			has_variable = tier_1_counter
			var:tier_1_counter > 0
		}
		change_variable = {
			name = tier_1_counter
			add = -1
		}
		select_tier_1_move_effect = yes
	}
	## Tier 2
	if = {
		limit = {
			# Check that the variable exists; strictly unnecessary, but stops a false positive clogging the error log.
			has_variable = tier_2_counter
			var:tier_2_counter > 0
		}
		change_variable = {
			name = tier_2_counter
			add = -1
		}
		select_tier_2_move_effect = yes
	}
	if = {
		limit = {
			# Check that the variable exists; strictly unnecessary, but stops a false positive clogging the error log.
			has_variable = tier_2_counter
			var:tier_2_counter > 0
		}
		change_variable = {
			name = tier_2_counter
			add = -1
		}
		select_tier_2_move_effect = yes
	}
	if = {
		limit = {
			# Check that the variable exists; strictly unnecessary, but stops a false positive clogging the error log.
			has_variable = tier_2_counter
			var:tier_2_counter > 0
		}
		change_variable = {
			name = tier_2_counter
			add = -1
		}
		select_tier_2_move_effect = yes
	}
	## Tier 3
	if = {
		limit = {
			# Check that the variable exists; strictly unnecessary, but stops a false positive clogging the error log.
			has_variable = tier_3_counter
			var:tier_3_counter > 0
		}
		change_variable = {
			name = tier_3_counter
			add = -1
		}
		select_tier_3_move_effect = yes
	}
	if = {
		limit = {
			# Check that the variable exists; strictly unnecessary, but stops a false positive clogging the error log.
			has_variable = tier_3_counter
			var:tier_3_counter > 0
		}
		change_variable = {
			name = tier_3_counter
			add = -1
		}
		select_tier_3_move_effect = yes
	}
	if = {
		limit = {
			# Check that the variable exists; strictly unnecessary, but stops a false positive clogging the error log.
			has_variable = tier_3_counter
			var:tier_3_counter > 0
		}
		change_variable = {
			name = tier_3_counter
			add = -1
		}
		select_tier_3_move_effect = yes
	}
}

# Determine whether scope:sc_loser will be unharmed, wounded, or killed at the end of a duel.
scripted_effect work_out_wounds_or_death_effect = {
	#Fatality:Practice - no wounds, please
	if = {
		limit = { scope:fatality = flag:practice }
		# No extra effect.
	}
	# Fatality:No = death has been disabled.
	if = {
		limit = { scope:fatality = flag:no }
		scope:sc_loser = {
			increase_wounds_no_death_effect = { REASON = duel }
		}
	}
	# Fatality:Possible = death is only possible via wounds.
	else_if = {
		limit = { scope:fatality = flag:possible }
		scope:sc_loser = {
			increase_wounds_effect = { REASON = duel }
		}
	}
	# Fatality:Default = death is only possible for non-tribals, and always for tribals, taking scope:sc_attacker as the instigating government.
	else_if = {
		limit = { scope:fatality = flag:default }
		if = {
			limit = { fatality_default_will_die_trigger = yes }
			scope:sc_loser = {
				single_combat_death_effect = yes
			}
		}
		else = {
			scope:sc_loser = {
				increase_wounds_effect = { REASON = duel }
			}
		}
	}
	# Fatality:Always = losing is always fatal.
	else_if = {
		limit = { scope:fatality = flag:always }
		scope:sc_victor = {
			if = {
				limit = {
					this = scope:sc_attacker
					NOT = { has_execute_reason = scope:sc_loser }
				}
				add_kinslayer_trait_or_nothing_effect = { VICTIM = scope:sc_loser }
			}
		}
		scope:sc_loser = {
			single_combat_death_effect = yes
		}
	}
}

# Sort the end of combat rigmarole & clean-up.
scripted_effect finalise_combat_results_effect = {
	# Determine if a death rattle is applicable, and if so, set which one.
	scope:sc_loser = {
		if  = {
			limit = { duel_will_end_in_my_death_trigger = yes }
			# First off, we look to see if scope:sc_loser is prevented from talking.
			## wordless
			if = {
				limit = {
					OR = {
						AND = {
							this = scope:sc_defender
							OR = {
								scope:sc_attacker_last_move = flag:technique_from_legend
								scope:sc_attacker_last_move = flag:hail_mary
								scope:sc_attacker_last_move = flag:like_a_viper
							}
						}
						AND = {
							this = scope:sc_attacker
							OR = {
								scope:sc_defender_last_move = flag:onslaught
								scope:sc_defender_last_move = flag:strict_guard
								scope:sc_defender_last_move = flag:pocket_silver
								scope:sc_defender_last_move = flag:blade_dance
							}
						}
					}
				}
				save_scope_value_as = {
					name = death_rattle
					value = flag:wordless
				}
			}
			## muffled
			else_if = {
				limit = {
					OR = {
						AND = {
							this = scope:sc_defender
							OR = {
								scope:sc_attacker_last_move = flag:is_that_a_crocodile
								AND = {
									scope:sc_attacker_last_move = flag:rough_terrain_expert
									scope:sc_defender.location = { terrain = wetlands }
								}
							}
						}
						AND = {
							this = scope:sc_attacker
							# Scope:sc_attacker currently only suffers this for the wetlands death. It'll need to be sub-AND'ed as above if any more are added.
							scope:sc_defender_last_move = flag:rough_terrain_expert
							scope:sc_defender.location = { terrain = wetlands }
						}
					}
				}
				save_scope_value_as = {
					name = death_rattle
					value = flag:muffled
				}
			}
			## choking
			else_if = {
				limit = {
					OR = {
						AND = {
							this = scope:sc_defender
							OR = {
								scope:sc_attacker_last_move = flag:wait_and_hope
								scope:sc_attacker_last_move = flag:enthusiastic_onslaught
								scope:sc_attacker_last_move = flag:pocket_sand
								scope:sc_attacker_last_move = flag:expert_onslaught
								scope:sc_attacker_last_move = flag:reason_you_suck_speech
								scope:sc_attacker_last_move = flag:pocket_silver
								scope:sc_attacker_last_move = flag:raaargh
								scope:sc_attacker_last_move = flag:hard_grit
								scope:sc_attacker_last_move = flag:butchery
							}
						}
						AND = {
							this = scope:sc_attacker
							OR = {
								scope:sc_defender_last_move = flag:wait_and_hope
								scope:sc_defender_last_move = flag:unsure_attack
								scope:sc_defender_last_move = flag:pocket_sand
								scope:sc_defender_last_move = flag:nut_em
								scope:sc_defender_last_move = flag:tire_opponent
								scope:sc_defender_last_move = flag:martial_voice
								scope:sc_defender_last_move = flag:is_that_a_crocodile
								scope:sc_defender_last_move = flag:desert_warrior
								scope:sc_defender_last_move = flag:butchery
							}
						}
					}
				}
				save_scope_value_as = {
					name = death_rattle
					value = flag:choking
				}
			}
			## pleading screams
			else_if = {
				limit = {
					# We actually don't use this for scope:sc_defender anywhere at present.
					this = scope:sc_attacker
					scope:sc_defender_last_move = flag:expert_onslaught
				}
				save_scope_value_as = {
					name = death_rattle
					value = flag:pleading_screams
				}
			}
			# Then, we go through possible relations, ordered by importance/rarity.
			## has soulmate
			else_if = {
				limit = {
					any_relation = {
						type = soulmate
						count >= 1
						NOT = { this = scope:sc_victor }
					}
				}
				random_relation = {
					type = soulmate
					save_scope_as = sc_loser_soulmate
				}
				save_scope_value_as = {
					name = death_rattle
					value = flag:soulmate
				}
			}
			## has best_friend
			else_if = {
				limit = {
					any_relation = {
						type = best_friend
						count >= 1
						NOT = { this = scope:sc_victor }
					}
				}
				random_relation = {
					type = best_friend
					save_scope_as = sc_loser_best_friend
				}
				save_scope_value_as = {
					name = death_rattle
					value = flag:best_friend
				}
			}
			## killed_by_soulmate
			else_if = {
				limit = { has_relation_soulmate = scope:sc_victor }
				save_scope_value_as = {
					name = death_rattle
					value = flag:killed_by_soulmate
				}
			}
			## killed_by_best_friend
			else_if = {
				limit = { has_relation_best_friend = scope:sc_victor }
				save_scope_value_as = {
					name = death_rattle
					value = flag:killed_by_best_friend
				}
			}
			## killed_by_nemesis
			else_if = {
				limit = { has_relation_nemesis = scope:sc_victor }
				save_scope_value_as = {
					name = death_rattle
					value = flag:killed_by_nemesis
				}
			}
			## killed_by_close_or_extended_family
			else_if = {
				limit = {
					any_close_or_extended_family_member = { this = scope:sc_victor }
				}
				save_scope_value_as = {
					name = death_rattle
					value = flag:killed_by_close_or_extended_family
				}
			}
			## is sinner
			else_if = {
				limit = {
					num_sinful_traits >= 3
					piety_level <= 0
				}
				save_scope_value_as = {
					name = death_rattle
					value = flag:sinner
				}
			}
			## is saint
			else_if = {
				limit = {
					num_virtuous_traits >= 3
					piety_level >= 5
				}
				save_scope_value_as = {
					name = death_rattle
					value = flag:saint
				}
			}
			## is legend
			else_if = {
				limit = {
					prestige_level >= 5
					NOT = { has_trait = humble }
				}
				save_scope_value_as = {
					name = death_rattle
					value = flag:legend
				}
			}
			## killed_by_rival
			else_if = {
				limit = { has_relation_rival = scope:sc_victor }
				save_scope_value_as = {
					name = death_rattle
					value = flag:killed_by_rival
				}
			}
			## killed_by_friend_or_lover
			else_if = {
				limit = {
					OR = {
						has_relation_friend = scope:sc_victor
						has_relation_lover = scope:sc_victor
					}
				}
				save_scope_value_as = {
					name = death_rattle
					value = flag:killed_by_friend_or_lover
				}
			}
			## killed_by_spouse
			else_if = {
				limit = {
					any_spouse = { this = scope:sc_victor }
				}
				save_scope_value_as = {
					name = death_rattle
					value = flag:killed_by_spouse
				}
			}
			## killed_by_your_head_of_faith
			else_if = {
				limit = { faith.religious_head = scope:sc_victor }
				save_scope_value_as = {
					name = death_rattle
					value = flag:killed_by_your_head_of_faith
				}
			}
			## killed_by_another_head_of_faith
			else_if = {
				limit = {
					NOT = { faith.religious_head = scope:sc_victor }
					scope:sc_victor.faith.religious_head = scope:sc_victor
				}
				save_scope_value_as = {
					name = death_rattle
					value = flag:killed_by_another_head_of_faith
				}
			}
			## killed_by_cultural_head
			else_if = {
				limit = { culture.culture_head = scope:sc_victor }
				save_scope_value_as = {
					name = death_rattle
					value = flag:killed_by_cultural_head
				}
			}
			## killed_by_house_head
			else_if = {
				limit = { house.house_head = scope:sc_victor }
				save_scope_value_as = {
					name = death_rattle
					value = flag:killed_by_house_head
				}
			}
			## killed_by_dynasty_head
			else_if = {
				limit = { dynasty.dynast = scope:sc_victor }
				save_scope_value_as = {
					name = death_rattle
					value = flag:killed_by_dynasty_head
				}
			}
			## believes in valhalla
			else_if = {
				limit = {
					# Specific to Germanic pagans.
					# Warcraft
					like_germanic_religion_trigger = yes

					# And they gotta be warlike.
					faith = {
						OR = {
							has_doctrine_parameter = warmonger
							has_doctrine_parameter = conquest_cb_enabled
							has_doctrine_parameter = invasion_cb_enabled
							has_doctrine_parameter = great_holy_wars_active_if_reformed
							has_doctrine_parameter = clergy_can_fight
							has_doctrine_parameter = cheaper_holy_wars_active
							has_doctrine_parameter = great_holy_wars_active
						}
					}
				}
				save_scope_value_as = {
					name = death_rattle
					value = flag:valhalla
				}
			}
			# Otherwise, we default to the fallback.
			## scream
			else = {
				save_scope_value_as = {
					name = death_rattle
					value = flag:scream
				}
			}
		}
	}
	# Send out results events.
	## We do this before death calculation so that the loser isn't too dead to be told that they've died (if they died).
	scope:sc_loser = { trigger_event = single_combat.0031 }
	scope:sc_victor = { trigger_event = single_combat.0041 }
	# Setup for artifact.4080
	scope:sc_victor = {
		if = {
			limit = {
				any_character_artifact = {
					is_equipped = yes
					artifact_slot_type = primary_armament
					NOT = { has_variable = artifact_duel_var }
				}
			}
			random_character_artifact = {
				limit = {
					is_equipped = yes
					artifact_slot_type = primary_armament
					NOT = { has_variable = artifact_duel_var }
				}
				set_variable = {
					name = artifact_duel_var
					value = 1
				}
			}
		}
		else_if = {
			limit = {
				any_character_artifact = {
					is_equipped = yes
					artifact_slot_type = primary_armament
					has_variable = artifact_duel_var
				}
			}
			random_character_artifact = {
				limit = {
					is_equipped = yes
					artifact_slot_type = primary_armament
					has_variable = artifact_duel_var
				}
				change_variable = {
					name = artifact_duel_var
					add = 1
				}
			}
		}
		# Legend seed setup
		if = {
			limit = {
				scope:sc_loser = {
					OR = {
						highest_held_title_tier >= tier_empire
						any_held_title = { is_head_of_faith = yes }
						has_nickname = nick_genghis_khan
					}
				}
			}
			create_legend_seed = {
				type = heroic
				quality = illustrious
				chronicle = legendary_battle
				properties = {
					winner = root
					loser = scope:sc_loser
					location = root.location
				}
			}
		}
	}
	# Sort glory allocation.
	scope:sc_victor = {
		if = {
			limit = {
				exists = accolade
				accolade = { is_accolade_active = yes }
			}
			# Glory is relative to the prowess difference between two characters. Beating someone equally matched or better is worth more.
			## Massively outclassed.
			if = {
				limit = {
					prowess_diff = {
						target = scope:sc_loser
						value <= -20
					}
				}
				accolade = { add_glory = monumental_glory_gain }
			}
			## Majorly outclassed.
			else_if = {
				limit = {
					prowess_diff = {
						target = scope:sc_loser
						value <= -15
					}
				}
				accolade = { add_glory = massive_glory_gain }
			}
			## Somewhat outclassed.
			else_if = {
				limit = {
					prowess_diff = {
						target = scope:sc_loser
						value <= -8
					}
				}
				accolade = { add_glory = major_glory_gain }
			}
			## Slightly outclassed.
			else_if = {
				limit = {
					prowess_diff = {
						target = scope:sc_loser
						value <= -4
					}
				}
				accolade = { add_glory = medium_glory_gain }
			}
			## Evenly matched.
			else_if = {
				limit = {
					prowess_diff = {
						target = scope:sc_loser
						value <= 0
					}
				}
				accolade = { add_glory = minor_glory_gain }
			}
			## Slightly in your favour.
			else_if = {
				limit = {
					prowess_diff = {
						target = scope:sc_loser
						value <= 4
					}
				}
				accolade = { add_glory = minimal_glory_gain }
			}
			## Below this, things are too much in your favour and you're not earning glory, you're defending what you already have.
			
			#Beating your rival means additional glory gain
			if = {
				limit = {
					OR = {
						has_relation_rival = scope:sc_loser
						has_relation_nemesis = scope:sc_loser
					}
				}
				accolade = { add_glory = minor_glory_gain }
			}
		}
	}
	# Calculate wounds/death; we use an effect so that we can show it as a tooltip elsewhere.
	work_out_wounds_or_death_effect = yes
	# Send the final output event & clean up.
	remove_single_combat_info_effect = yes
	scope:sc_defender = {
		if = {
			limit = { is_alive = yes }
			remove_variable = engaged_in_single_combat
		}
	}
	scope:sc_attacker = {
		if = {
			limit = { is_alive = yes }
			remove_variable = engaged_in_single_combat
		}
	}
	## We use the initiator if they're alive...
	if = {
		limit = {
			scope:sc_initiator = { is_alive = yes }
		}
		scope:sc_initiator = { 
			trigger_event = { saved_event_id = scope:follow_up_event }
		}
	}
	## Or otherwise the other person.
	### Doesn't hugely matter, technically, since the output event should be from a neutral scope, but if they're dead then the event won't fire and the chain silently invalidates.
	else_if = {
		limit = {
			scope:sc_defender = { is_alive = yes }
		}
		scope:sc_defender = {
			trigger_event = { saved_event_id = scope:follow_up_event }
		}
	}
	else = {
		scope:sc_attacker = {
			trigger_event = { saved_event_id = scope:follow_up_event }
		}
	}
}

# Determine the current chances for either party to injure themselves _before_ the next move is made.
scripted_effect calculate_injury_risks_effect = {
	scope:sc_attacker = {
		set_variable = {
			name = sc_attacker_injury_risk_check
			value = {
				value = scope:sc_attacker.var:sc_attacker_injury_risk_score
				add = scope:sc_attacker.var:sc_attacker_injury_bonus
			}
		}
	}
	scope:sc_defender = {
		set_variable = {
			name = sc_defender_injury_risk_check
			value = {
				value = scope:sc_defender.var:sc_defender_injury_risk_score
				add = scope:sc_defender.var:sc_defender_injury_bonus
			}
		}
	}
}

# Determine which of the two parties, if either, is currently closest to winning the single combat via skill.
scripted_effect calculate_success_chances_effect = {
	scope:sc_attacker = {
		set_variable = {
			name = sc_attacker_success_check
			value = {
				value = scope:sc_attacker.var:sc_attacker_duel_success_score
				subtract = scope:sc_defender.var:sc_defender_duel_success_score
			}
		}
	}
	scope:sc_defender = {
		set_variable = {
			name = sc_defender_success_check
			value = {
				value = scope:sc_defender.var:sc_defender_duel_success_score
				subtract = scope:sc_attacker.var:sc_attacker_duel_success_score
			}
		}
	}
}

##################################################
# COMBAT MOVE SCRIPTED EFFECTS

# Update the results of the current combat move.
scripted_effect adjust_risk_reward_effect = {
	# Adjust scope:sc_attacker's scores if we're looking at them.
	if = {
		limit = { this = scope:sc_attacker }
		change_variable = {
			name = sc_attacker_injury_risk_score
			add = $INJURY_RISK$
		}
		change_variable = {
			name = sc_attacker_duel_success_score
			add = $DUEL_SUCCESS$
		}
	}

	# Adjust scope:sc_defender's scores if we're looking at them.
	if = {
		limit = { this = scope:sc_defender }
		change_variable = {
			name = sc_defender_injury_risk_score
			add = $INJURY_RISK$
		}
		change_variable = {
			name = sc_defender_duel_success_score
			add = $DUEL_SUCCESS$
		}
	}

	# Inform the current scope about how this will impact duel_success_score.
	if = {
		limit = { $DUEL_SUCCESS$ = duel_success_none }
		# If this is a past tense tooltip, refer to scope:my_foe grammatically.
		if = {
			limit = { this = scope:my_foe }
			custom_tooltip = single_combat.0001.duel_success.none.has_happened
		}
		# Otherwise, we do it from first person.
		else = { custom_tooltip = single_combat.0001.duel_success.none }
	}
	else_if = {
		limit = { $DUEL_SUCCESS$ = duel_success_low }
		# If this is a past tense tooltip, refer to scope:my_foe grammatically.
		if = {
			limit = { this = scope:my_foe }
			custom_tooltip = single_combat.0001.duel_success.low.has_happened
		}
		# Otherwise, we do it from first person.
		else = { custom_tooltip = single_combat.0001.duel_success.low }
	}
	else_if = {
		limit = { $DUEL_SUCCESS$ = duel_success_medium }
		# If this is a past tense tooltip, refer to scope:my_foe grammatically.
		if = {
			limit = { this = scope:my_foe }
			custom_tooltip = single_combat.0001.duel_success.medium.has_happened
		}
		# Otherwise, we do it from first person.
		else = { custom_tooltip = single_combat.0001.duel_success.medium }
	}
	else_if = {
		limit = { $DUEL_SUCCESS$ = duel_success_high }
		# If this is a past tense tooltip, refer to scope:my_foe grammatically.
		if = {
			limit = { this = scope:my_foe }
			custom_tooltip = single_combat.0001.duel_success.high.has_happened
		}
		# Otherwise, we do it from first person.
		else = { custom_tooltip = single_combat.0001.duel_success.high }
	}
	else_if = {
		limit = { $DUEL_SUCCESS$ = duel_success_very_high }
		# If this is a past tense tooltip, refer to scope:my_foe grammatically.
		if = {
			limit = { this = scope:my_foe }
			custom_tooltip = single_combat.0001.duel_success.very_high.has_happened
		}
		# Otherwise, we do it from first person.
		else = { custom_tooltip = single_combat.0001.duel_success.very_high }
	}

	# Aaaand finally tell current scope how this'll impact injury_risk_score.
	if = {
		limit = { $INJURY_RISK$ = injury_risk_none }
		# If this is a past tense tooltip, refer to scope:my_foe grammatically.
		if = {
			limit = { this = scope:my_foe }
			custom_tooltip = single_combat.0001.injury.none.has_happened
		}
		# Otherwise, we do it from first person.
		else = { custom_tooltip = single_combat.0001.injury.none }
	}
	else_if = {
		limit = { $INJURY_RISK$ = injury_risk_low }
		# If this is a past tense tooltip, refer to scope:my_foe grammatically.
		if = {
			limit = { this = scope:my_foe }
			custom_tooltip = single_combat.0001.injury.low.has_happened
		}
		# Otherwise, we do it from first person.
		else = { custom_tooltip = single_combat.0001.injury.low }
	}
	else_if = {
		limit = { $INJURY_RISK$ = injury_risk_medium }
		# If this is a past tense tooltip, refer to scope:my_foe grammatically.
		if = {
			limit = { this = scope:my_foe }
			custom_tooltip = single_combat.0001.injury.medium.has_happened
		}
		# Otherwise, we do it from first person.
		else = { custom_tooltip = single_combat.0001.injury.medium }
	}
	else_if = {
		limit = { $INJURY_RISK$ = injury_risk_high }
		# If this is a past tense tooltip, refer to scope:my_foe grammatically.
		if = {
			limit = { this = scope:my_foe }
			custom_tooltip = single_combat.0001.injury.high.has_happened
		}
		# Otherwise, we do it from first person.
		else = { custom_tooltip = single_combat.0001.injury.high }
	}
	else_if = {
		limit = { $INJURY_RISK$ = injury_risk_very_high }
		# If this is a past tense tooltip, refer to scope:my_foe grammatically.
		if = {
			limit = { this = scope:my_foe }
			custom_tooltip = single_combat.0001.injury.very_high.has_happened
		}
		# Otherwise, we do it from first person.
		else = { custom_tooltip = single_combat.0001.injury.very_high }
	}
}

# Add positive prowess character modifiers from the current move.
scripted_effect increment_combat_buffs_effect = {
	# Determine what our current level of combat buff is.
	## Hidden effect for easy folding & readability.
	hidden_effect = {
			if = {
				limit = {
					NOR = {
						has_character_modifier = duel_edge_buff_01_modifier
						has_character_modifier = duel_edge_buff_02_modifier
						has_character_modifier = duel_edge_buff_03_modifier
						has_character_modifier = duel_edge_buff_04_modifier
						has_character_modifier = duel_edge_buff_05_modifier
						has_character_modifier = duel_edge_buff_06_modifier
						has_character_modifier = duel_edge_buff_07_modifier
						has_character_modifier = duel_edge_buff_08_modifier
						has_character_modifier = duel_edge_buff_09_modifier
						has_character_modifier = duel_edge_buff_10_modifier
						has_character_modifier = duel_edge_buff_11_modifier
						has_character_modifier = duel_edge_buff_12_modifier
						has_character_modifier = duel_edge_buff_13_modifier
						has_character_modifier = duel_edge_buff_14_modifier
						has_character_modifier = duel_edge_buff_15_modifier
						has_character_modifier = duel_edge_buff_16_modifier
						has_character_modifier = duel_edge_buff_17_modifier
						has_character_modifier = duel_edge_buff_18_modifier
						has_character_modifier = duel_edge_buff_19_modifier
						has_character_modifier = duel_edge_buff_20_modifier
						has_character_modifier = duel_edge_buff_21_modifier
						has_character_modifier = duel_edge_buff_22_modifier
						has_character_modifier = duel_edge_buff_23_modifier
						has_character_modifier = duel_edge_buff_24_modifier
						has_character_modifier = duel_edge_buff_25_modifier
						has_character_modifier = duel_edge_buff_26_modifier
						has_character_modifier = duel_edge_buff_27_modifier
						has_character_modifier = duel_edge_buff_28_modifier
						has_character_modifier = duel_edge_buff_29_modifier
						has_character_modifier = duel_edge_buff_30_modifier
					}
				}
				set_local_variable = {
					name = current_duel_edge_buff
					value = 0
				}
			}
			else_if = {
				limit = { has_character_modifier = duel_edge_buff_01_modifier }
				set_local_variable = {
					name = current_duel_edge_buff
					value = 1
				}
			}
			else_if = {
				limit = { has_character_modifier = duel_edge_buff_02_modifier }
				set_local_variable = {
					name = current_duel_edge_buff
					value = 2
				}
			}
			else_if = {
				limit = { has_character_modifier = duel_edge_buff_03_modifier }
				set_local_variable = {
					name = current_duel_edge_buff
					value = 3
				}
			}
			else_if = {
				limit = { has_character_modifier = duel_edge_buff_04_modifier }
				set_local_variable = {
					name = current_duel_edge_buff
					value = 4
				}
			}
			else_if = {
				limit = { has_character_modifier = duel_edge_buff_05_modifier }
				set_local_variable = {
					name = current_duel_edge_buff
					value = 5
				}
			}
			else_if = {
				limit = { has_character_modifier = duel_edge_buff_06_modifier }
				set_local_variable = {
					name = current_duel_edge_buff
					value = 6
				}
			}
			else_if = {
				limit = { has_character_modifier = duel_edge_buff_07_modifier }
				set_local_variable = {
					name = current_duel_edge_buff
					value = 7
				}
			}
			else_if = {
				limit = { has_character_modifier = duel_edge_buff_08_modifier }
				set_local_variable = {
					name = current_duel_edge_buff
					value = 8
				}
			}
			else_if = {
				limit = { has_character_modifier = duel_edge_buff_09_modifier }
				set_local_variable = {
					name = current_duel_edge_buff
					value = 9
				}
			}
			else_if = {
				limit = { has_character_modifier = duel_edge_buff_10_modifier }
				set_local_variable = {
					name = current_duel_edge_buff
					value = 10
				}
			}
			else_if = {
				limit = { has_character_modifier = duel_edge_buff_11_modifier }
				set_local_variable = {
					name = current_duel_edge_buff
					value = 11
				}
			}
			else_if = {
				limit = { has_character_modifier = duel_edge_buff_12_modifier }
				set_local_variable = {
					name = current_duel_edge_buff
					value = 12
				}
			}
			else_if = {
				limit = { has_character_modifier = duel_edge_buff_13_modifier }
				set_local_variable = {
					name = current_duel_edge_buff
					value = 13
				}
			}
			else_if = {
				limit = { has_character_modifier = duel_edge_buff_14_modifier }
				set_local_variable = {
					name = current_duel_edge_buff
					value = 14
				}
			}
			else_if = {
				limit = { has_character_modifier = duel_edge_buff_15_modifier }
				set_local_variable = {
					name = current_duel_edge_buff
					value = 15
				}
			}
			else_if = {
				limit = { has_character_modifier = duel_edge_buff_16_modifier }
				set_local_variable = {
					name = current_duel_edge_buff
					value = 16
				}
			}
			else_if = {
				limit = { has_character_modifier = duel_edge_buff_17_modifier }
				set_local_variable = {
					name = current_duel_edge_buff
					value = 17
				}
			}
			else_if = {
				limit = { has_character_modifier = duel_edge_buff_18_modifier }
				set_local_variable = {
					name = current_duel_edge_buff
					value = 18
				}
			}
			else_if = {
				limit = { has_character_modifier = duel_edge_buff_19_modifier }
				set_local_variable = {
					name = current_duel_edge_buff
					value = 19
				}
			}
			else_if = {
				limit = { has_character_modifier = duel_edge_buff_20_modifier }
				set_local_variable = {
					name = current_duel_edge_buff
					value = 20
				}
			}
			else_if = {
				limit = { has_character_modifier = duel_edge_buff_21_modifier }
				set_local_variable = {
					name = current_duel_edge_buff
					value = 21
				}
			}
			else_if = {
				limit = { has_character_modifier = duel_edge_buff_22_modifier }
				set_local_variable = {
					name = current_duel_edge_buff
					value = 22
				}
			}
			else_if = {
				limit = { has_character_modifier = duel_edge_buff_23_modifier }
				set_local_variable = {
					name = current_duel_edge_buff
					value = 23
				}
			}
			else_if = {
				limit = { has_character_modifier = duel_edge_buff_24_modifier }
				set_local_variable = {
					name = current_duel_edge_buff
					value = 24
				}
			}
			else_if = {
				limit = { has_character_modifier = duel_edge_buff_25_modifier }
				set_local_variable = {
					name = current_duel_edge_buff
					value = 25
				}
			}
			else_if = {
				limit = { has_character_modifier = duel_edge_buff_26_modifier }
				set_local_variable = {
					name = current_duel_edge_buff
					value = 26
				}
			}
			else_if = {
				limit = { has_character_modifier = duel_edge_buff_27_modifier }
				set_local_variable = {
					name = current_duel_edge_buff
					value = 27
				}
			}
			else_if = {
				limit = { has_character_modifier = duel_edge_buff_28_modifier }
				set_local_variable = {
					name = current_duel_edge_buff
					value = 28
				}
			}
			else_if = {
				limit = { has_character_modifier = duel_edge_buff_29_modifier }
				set_local_variable = {
					name = current_duel_edge_buff
					value = 29
				}
			}
			else_if = {
				limit = { has_character_modifier = duel_edge_buff_30_modifier }
				set_local_variable = {
					name = current_duel_edge_buff
					value = 30
				}
				#Show a tooltip in case the character is overflowing at max buff.
				custom_tooltip = single_combat.0001.tt.maximum_buff_reached
			}
	}
	# Grab the amount we want to add and change the combat modifier accordingly.
	change_local_variable = {
		name = current_duel_edge_buff
		add = $BUFF_INCREMENT$
	}
	# Remove any existing duel edge buffs.
	hidden_effect = { remove_temporary_duel_edge_buff_modifiers_effect = yes }
	# Add the buff corresponding to our new level of edge.
	if = {
		limit = { local_var:current_duel_edge_buff = 1 }
		add_character_modifier = duel_edge_buff_01_modifier
	}
	else_if = {
		limit = { local_var:current_duel_edge_buff = 2 }
		add_character_modifier = duel_edge_buff_02_modifier
	}
	else_if = {
		limit = { local_var:current_duel_edge_buff = 3 }
		add_character_modifier = duel_edge_buff_03_modifier
	}
	else_if = {
		limit = { local_var:current_duel_edge_buff = 4 }
		add_character_modifier = duel_edge_buff_04_modifier
	}
	else_if = {
		limit = { local_var:current_duel_edge_buff = 5 }
		add_character_modifier = duel_edge_buff_05_modifier
	}
	else_if = {
		limit = { local_var:current_duel_edge_buff = 6 }
		add_character_modifier = duel_edge_buff_06_modifier
	}
	else_if = {
		limit = { local_var:current_duel_edge_buff = 7 }
		add_character_modifier = duel_edge_buff_07_modifier
	}
	else_if = {
		limit = { local_var:current_duel_edge_buff = 8 }
		add_character_modifier = duel_edge_buff_08_modifier
	}
	else_if = {
		limit = { local_var:current_duel_edge_buff = 9 }
		add_character_modifier = duel_edge_buff_09_modifier
	}
	else_if = {
		limit = { local_var:current_duel_edge_buff = 10 }
		add_character_modifier = duel_edge_buff_10_modifier
	}
	else_if = {
		limit = { local_var:current_duel_edge_buff = 11 }
		add_character_modifier = duel_edge_buff_11_modifier
	}
	else_if = {
		limit = { local_var:current_duel_edge_buff = 12 }
		add_character_modifier = duel_edge_buff_12_modifier
	}
	else_if = {
		limit = { local_var:current_duel_edge_buff = 13 }
		add_character_modifier = duel_edge_buff_13_modifier
	}
	else_if = {
		limit = { local_var:current_duel_edge_buff = 14 }
		add_character_modifier = duel_edge_buff_14_modifier
	}
	else_if = {
		limit = { local_var:current_duel_edge_buff = 15 }
		add_character_modifier = duel_edge_buff_15_modifier
	}
	else_if = {
		limit = { local_var:current_duel_edge_buff = 16 }
		add_character_modifier = duel_edge_buff_16_modifier
	}
	else_if = {
		limit = { local_var:current_duel_edge_buff = 17 }
		add_character_modifier = duel_edge_buff_17_modifier
	}
	else_if = {
		limit = { local_var:current_duel_edge_buff = 18 }
		add_character_modifier = duel_edge_buff_18_modifier
	}
	else_if = {
		limit = { local_var:current_duel_edge_buff = 19 }
		add_character_modifier = duel_edge_buff_19_modifier
	}
	else_if = {
		limit = { local_var:current_duel_edge_buff = 20 }
		add_character_modifier = duel_edge_buff_20_modifier
	}
	else_if = {
		limit = { local_var:current_duel_edge_buff = 21 }
		add_character_modifier = duel_edge_buff_21_modifier
	}
	else_if = {
		limit = { local_var:current_duel_edge_buff = 22 }
		add_character_modifier = duel_edge_buff_22_modifier
	}
	else_if = {
		limit = { local_var:current_duel_edge_buff = 23 }
		add_character_modifier = duel_edge_buff_23_modifier
	}
	else_if = {
		limit = { local_var:current_duel_edge_buff = 24 }
		add_character_modifier = duel_edge_buff_24_modifier
	}
	else_if = {
		limit = { local_var:current_duel_edge_buff = 25 }
		add_character_modifier = duel_edge_buff_25_modifier
	}
	else_if = {
		limit = { local_var:current_duel_edge_buff = 26 }
		add_character_modifier = duel_edge_buff_26_modifier
	}
	else_if = {
		limit = { local_var:current_duel_edge_buff = 27 }
		add_character_modifier = duel_edge_buff_27_modifier
	}
	else_if = {
		limit = { local_var:current_duel_edge_buff = 28 }
		add_character_modifier = duel_edge_buff_28_modifier
	}
	else_if = {
		limit = { local_var:current_duel_edge_buff = 29 }
		add_character_modifier = duel_edge_buff_29_modifier
	}
	else_if = {
		limit = { local_var:current_duel_edge_buff >= 30 }
		add_character_modifier = duel_edge_buff_30_modifier
		#Show a tooltip in case the character is overflowing at max buff.
		custom_tooltip = single_combat.0001.tt.maximum_buff_reached
	}
	# Finally, note that the character needs a stats recalc.
	add_character_flag = sce_needs_forced_recalc_flag
}

# Add negative prowess character modifiers from the current move.
scripted_effect increment_combat_debuffs_effect = {
	# Determine what our current level of combat buff is.
	## Hidden effect for easy folding & readability.
	hidden_effect = {
			if = {
				limit = {
					NOR = {
						has_character_modifier = duel_edge_debuff_01_modifier
						has_character_modifier = duel_edge_debuff_02_modifier
						has_character_modifier = duel_edge_debuff_03_modifier
						has_character_modifier = duel_edge_debuff_04_modifier
						has_character_modifier = duel_edge_debuff_05_modifier
						has_character_modifier = duel_edge_debuff_06_modifier
						has_character_modifier = duel_edge_debuff_07_modifier
						has_character_modifier = duel_edge_debuff_08_modifier
						has_character_modifier = duel_edge_debuff_09_modifier
						has_character_modifier = duel_edge_debuff_10_modifier
						has_character_modifier = duel_edge_debuff_11_modifier
						has_character_modifier = duel_edge_debuff_12_modifier
						has_character_modifier = duel_edge_debuff_13_modifier
						has_character_modifier = duel_edge_debuff_14_modifier
						has_character_modifier = duel_edge_debuff_15_modifier
						has_character_modifier = duel_edge_debuff_16_modifier
						has_character_modifier = duel_edge_debuff_17_modifier
						has_character_modifier = duel_edge_debuff_18_modifier
						has_character_modifier = duel_edge_debuff_19_modifier
						has_character_modifier = duel_edge_debuff_20_modifier
						has_character_modifier = duel_edge_debuff_21_modifier
						has_character_modifier = duel_edge_debuff_22_modifier
						has_character_modifier = duel_edge_debuff_23_modifier
						has_character_modifier = duel_edge_debuff_24_modifier
						has_character_modifier = duel_edge_debuff_25_modifier
						has_character_modifier = duel_edge_debuff_26_modifier
						has_character_modifier = duel_edge_debuff_27_modifier
						has_character_modifier = duel_edge_debuff_28_modifier
						has_character_modifier = duel_edge_debuff_29_modifier
						has_character_modifier = duel_edge_debuff_30_modifier
					}
				}
				set_local_variable = {
					name = current_duel_edge_debuff
					value = 0
				}
			}
			else_if = {
				limit = { has_character_modifier = duel_edge_debuff_01_modifier }
				set_local_variable = {
					name = current_duel_edge_debuff
					value = 1
				}
			}
			else_if = {
				limit = { has_character_modifier = duel_edge_debuff_02_modifier }
				set_local_variable = {
					name = current_duel_edge_debuff
					value = 2
				}
			}
			else_if = {
				limit = { has_character_modifier = duel_edge_debuff_03_modifier }
				set_local_variable = {
					name = current_duel_edge_debuff
					value = 3
				}
			}
			else_if = {
				limit = { has_character_modifier = duel_edge_debuff_04_modifier }
				set_local_variable = {
					name = current_duel_edge_debuff
					value = 4
				}
			}
			else_if = {
				limit = { has_character_modifier = duel_edge_debuff_05_modifier }
				set_local_variable = {
					name = current_duel_edge_debuff
					value = 5
				}
			}
			else_if = {
				limit = { has_character_modifier = duel_edge_debuff_06_modifier }
				set_local_variable = {
					name = current_duel_edge_debuff
					value = 6
				}
			}
			else_if = {
				limit = { has_character_modifier = duel_edge_debuff_07_modifier }
				set_local_variable = {
					name = current_duel_edge_debuff
					value = 7
				}
			}
			else_if = {
				limit = { has_character_modifier = duel_edge_debuff_08_modifier }
				set_local_variable = {
					name = current_duel_edge_debuff
					value = 8
				}
			}
			else_if = {
				limit = { has_character_modifier = duel_edge_debuff_09_modifier }
				set_local_variable = {
					name = current_duel_edge_debuff
					value = 9
				}
			}
			else_if = {
				limit = { has_character_modifier = duel_edge_debuff_10_modifier }
				set_local_variable = {
					name = current_duel_edge_debuff
					value = 10
				}
			}
			else_if = {
				limit = { has_character_modifier = duel_edge_debuff_11_modifier }
				set_local_variable = {
					name = current_duel_edge_debuff
					value = 11
				}
			}
			else_if = {
				limit = { has_character_modifier = duel_edge_debuff_12_modifier }
				set_local_variable = {
					name = current_duel_edge_debuff
					value = 12
				}
			}
			else_if = {
				limit = { has_character_modifier = duel_edge_debuff_13_modifier }
				set_local_variable = {
					name = current_duel_edge_debuff
					value = 13
				}
			}
			else_if = {
				limit = { has_character_modifier = duel_edge_debuff_14_modifier }
				set_local_variable = {
					name = current_duel_edge_debuff
					value = 14
				}
			}
			else_if = {
				limit = { has_character_modifier = duel_edge_debuff_15_modifier }
				set_local_variable = {
					name = current_duel_edge_debuff
					value = 15
				}
			}
			else_if = {
				limit = { has_character_modifier = duel_edge_debuff_16_modifier }
				set_local_variable = {
					name = current_duel_edge_debuff
					value = 16
				}
			}
			else_if = {
				limit = { has_character_modifier = duel_edge_debuff_17_modifier }
				set_local_variable = {
					name = current_duel_edge_debuff
					value = 17
				}
			}
			else_if = {
				limit = { has_character_modifier = duel_edge_debuff_18_modifier }
				set_local_variable = {
					name = current_duel_edge_debuff
					value = 18
				}
			}
			else_if = {
				limit = { has_character_modifier = duel_edge_debuff_19_modifier }
				set_local_variable = {
					name = current_duel_edge_debuff
					value = 19
				}
			}
			else_if = {
				limit = { has_character_modifier = duel_edge_debuff_20_modifier }
				set_local_variable = {
					name = current_duel_edge_debuff
					value = 20
				}
			}
			else_if = {
				limit = { has_character_modifier = duel_edge_debuff_21_modifier }
				set_local_variable = {
					name = current_duel_edge_debuff
					value = 21
				}
			}
			else_if = {
				limit = { has_character_modifier = duel_edge_debuff_22_modifier }
				set_local_variable = {
					name = current_duel_edge_debuff
					value = 22
				}
			}
			else_if = {
				limit = { has_character_modifier = duel_edge_debuff_23_modifier }
				set_local_variable = {
					name = current_duel_edge_debuff
					value = 23
				}
			}
			else_if = {
				limit = { has_character_modifier = duel_edge_debuff_24_modifier }
				set_local_variable = {
					name = current_duel_edge_debuff
					value = 24
				}
			}
			else_if = {
				limit = { has_character_modifier = duel_edge_debuff_25_modifier }
				set_local_variable = {
					name = current_duel_edge_debuff
					value = 25
				}
			}
			else_if = {
				limit = { has_character_modifier = duel_edge_debuff_26_modifier }
				set_local_variable = {
					name = current_duel_edge_debuff
					value = 26
				}
			}
			else_if = {
				limit = { has_character_modifier = duel_edge_debuff_27_modifier }
				set_local_variable = {
					name = current_duel_edge_debuff
					value = 27
				}
			}
			else_if = {
				limit = { has_character_modifier = duel_edge_debuff_28_modifier }
				set_local_variable = {
					name = current_duel_edge_debuff
					value = 28
				}
			}
			else_if = {
				limit = { has_character_modifier = duel_edge_debuff_29_modifier }
				set_local_variable = {
					name = current_duel_edge_debuff
					value = 29
				}
			}
			else_if = {
				limit = { has_character_modifier = duel_edge_debuff_30_modifier }
				set_local_variable = {
					name = current_duel_edge_debuff
					value = 30
				}
				#Show a tooltip in case the character is overflowing at max buff.
				custom_tooltip = single_combat.0001.tt.maximum_debuff_reached
			}
	}
	# Grab the amount we want to add and change the combat modifier accordingly.
	change_local_variable = {
		name = current_duel_edge_debuff
		add = $DEBUFF_INCREMENT$
	}
	# Remove any existing duel edge buffs.
	hidden_effect = { remove_temporary_duel_edge_debuff_modifiers_effect = yes }
	# Add the buff corresponding to our new level of edge.
	if = {
		limit = { local_var:current_duel_edge_debuff = 1 }
		add_character_modifier = duel_edge_debuff_01_modifier
	}
	else_if = {
		limit = { local_var:current_duel_edge_debuff = 2 }
		add_character_modifier = duel_edge_debuff_02_modifier
	}
	else_if = {
		limit = { local_var:current_duel_edge_debuff = 3 }
		add_character_modifier = duel_edge_debuff_03_modifier
	}
	else_if = {
		limit = { local_var:current_duel_edge_debuff = 4 }
		add_character_modifier = duel_edge_debuff_04_modifier
	}
	else_if = {
		limit = { local_var:current_duel_edge_debuff = 5 }
		add_character_modifier = duel_edge_debuff_05_modifier
	}
	else_if = {
		limit = { local_var:current_duel_edge_debuff = 6 }
		add_character_modifier = duel_edge_debuff_06_modifier
	}
	else_if = {
		limit = { local_var:current_duel_edge_debuff = 7 }
		add_character_modifier = duel_edge_debuff_07_modifier
	}
	else_if = {
		limit = { local_var:current_duel_edge_debuff = 8 }
		add_character_modifier = duel_edge_debuff_08_modifier
	}
	else_if = {
		limit = { local_var:current_duel_edge_debuff = 9 }
		add_character_modifier = duel_edge_debuff_09_modifier
	}
	else_if = {
		limit = { local_var:current_duel_edge_debuff = 10 }
		add_character_modifier = duel_edge_debuff_10_modifier
	}
	else_if = {
		limit = { local_var:current_duel_edge_debuff = 11 }
		add_character_modifier = duel_edge_debuff_11_modifier
	}
	else_if = {
		limit = { local_var:current_duel_edge_debuff = 12 }
		add_character_modifier = duel_edge_debuff_12_modifier
	}
	else_if = {
		limit = { local_var:current_duel_edge_debuff = 13 }
		add_character_modifier = duel_edge_debuff_13_modifier
	}
	else_if = {
		limit = { local_var:current_duel_edge_debuff = 14 }
		add_character_modifier = duel_edge_debuff_14_modifier
	}
	else_if = {
		limit = { local_var:current_duel_edge_debuff = 15 }
		add_character_modifier = duel_edge_debuff_15_modifier
	}
	else_if = {
		limit = { local_var:current_duel_edge_debuff = 16 }
		add_character_modifier = duel_edge_debuff_16_modifier
	}
	else_if = {
		limit = { local_var:current_duel_edge_debuff = 17 }
		add_character_modifier = duel_edge_debuff_17_modifier
	}
	else_if = {
		limit = { local_var:current_duel_edge_debuff = 18 }
		add_character_modifier = duel_edge_debuff_18_modifier
	}
	else_if = {
		limit = { local_var:current_duel_edge_debuff = 19 }
		add_character_modifier = duel_edge_debuff_19_modifier
	}
	else_if = {
		limit = { local_var:current_duel_edge_debuff = 20 }
		add_character_modifier = duel_edge_debuff_20_modifier
	}
	else_if = {
		limit = { local_var:current_duel_edge_debuff = 21 }
		add_character_modifier = duel_edge_debuff_21_modifier
	}
	else_if = {
		limit = { local_var:current_duel_edge_debuff = 22 }
		add_character_modifier = duel_edge_debuff_22_modifier
	}
	else_if = {
		limit = { local_var:current_duel_edge_debuff = 23 }
		add_character_modifier = duel_edge_debuff_23_modifier
	}
	else_if = {
		limit = { local_var:current_duel_edge_debuff = 24 }
		add_character_modifier = duel_edge_debuff_24_modifier
	}
	else_if = {
		limit = { local_var:current_duel_edge_debuff = 25 }
		add_character_modifier = duel_edge_debuff_25_modifier
	}
	else_if = {
		limit = { local_var:current_duel_edge_debuff = 26 }
		add_character_modifier = duel_edge_debuff_26_modifier
	}
	else_if = {
		limit = { local_var:current_duel_edge_debuff = 27 }
		add_character_modifier = duel_edge_debuff_27_modifier
	}
	else_if = {
		limit = { local_var:current_duel_edge_debuff = 28 }
		add_character_modifier = duel_edge_debuff_28_modifier
	}
	else_if = {
		limit = { local_var:current_duel_edge_debuff = 29 }
		add_character_modifier = duel_edge_debuff_29_modifier
	}
	else_if = {
		limit = { local_var:current_duel_edge_debuff >= 30 }
		add_character_modifier = duel_edge_debuff_30_modifier
		#Show a tooltip in case the character is overflowing at max buff.
		custom_tooltip = single_combat.0001.tt.maximum_debuff_reached
	}
	# Finally, note that the character needs a stats recalc.
	add_character_flag = sce_needs_forced_recalc_flag
}

# Tier One move effects
scripted_effect combat_move_wait_and_hope_effect = {
	#No special effects.

	#Iterate last move for loc purposes.
	if = {
		limit = { this = scope:sc_attacker }
		save_scope_value_as = {
			name = sc_attacker_last_move
			value = flag:wait_and_hope
		}
	}
	if = {
		limit = { this = scope:sc_defender }
		save_scope_value_as = {
			name = sc_defender_last_move
			value = flag:wait_and_hope
		}
	}

	#And adjust risk-reward scores.
	adjust_risk_reward_effect = {
		INJURY_RISK = injury_risk_medium
		DUEL_SUCCESS = duel_success_low
	}
}
scripted_effect combat_move_unsure_attack_effect = {
	#No special effects.

	#Change the last move registered for loc purposes.
	if = {
		limit = { this = scope:sc_attacker }
		save_scope_value_as = {
			name = sc_attacker_last_move
			value = flag:unsure_attack
		}
	}
	if = {
		limit = { this = scope:sc_defender }
		save_scope_value_as = {
			name = sc_defender_last_move
			value = flag:unsure_attack
		}
	}

	#And adjust risk-reward scores.
	adjust_risk_reward_effect = {
		INJURY_RISK = injury_risk_high
		DUEL_SUCCESS = duel_success_medium
	}
}
scripted_effect combat_move_enthusiastic_onslaught_effect = {
	#No special effects.

	#Change the last move registered for loc purposes.
	if = {
		limit = { this = scope:sc_attacker }
		save_scope_value_as = {
			name = sc_attacker_last_move
			value = flag:enthusiastic_onslaught
		}
	}
	if = {
		limit = { this = scope:sc_defender }
		save_scope_value_as = {
			name = sc_defender_last_move
			value = flag:enthusiastic_onslaught
		}
	}

	#And adjust risk-reward scores.
	adjust_risk_reward_effect = {
		INJURY_RISK = injury_risk_very_high
		DUEL_SUCCESS = duel_success_high
	}
}
scripted_effect combat_move_hail_mary_effect = {
	#No special effects.

	#Change the last move registered for loc purposes.
	if = {
		limit = { this = scope:sc_attacker }
		save_scope_value_as = {
			name = sc_attacker_last_move
			value = flag:hail_mary
		}
	}
	if = {
		limit = { this = scope:sc_defender }
		save_scope_value_as = {
			name = sc_defender_last_move
			value = flag:hail_mary
		}
	}

	#And adjust risk-reward scores.
	adjust_risk_reward_effect = {
		INJURY_RISK = injury_risk_high
		DUEL_SUCCESS = duel_success_very_high
	}
}
scripted_effect combat_move_pocket_sand_effect = {
	# Your opponent gets grit in their eyes!
	## Scope:sc_attacker first.
	if = {
		limit = { this = scope:sc_attacker }
		scope:sc_defender = {
			increment_combat_debuffs_effect = { DEBUFF_INCREMENT = 4 }
		}
	}
	## Then scope:sc_defender.
	if = {
		limit = { this = scope:sc_defender }
		scope:sc_attacker = {
			increment_combat_debuffs_effect = { DEBUFF_INCREMENT = 4 }
		}
	}

	#Change the last move registered for loc purposes.
	if = {
		limit = { this = scope:sc_attacker }
		save_scope_value_as = {
			name = sc_attacker_last_move
			value = flag:pocket_sand
		}
	}
	if = {
		limit = { this = scope:sc_defender }
		save_scope_value_as = {
			name = sc_defender_last_move
			value = flag:pocket_sand
		}
	}

	#And adjust risk-reward scores.
	adjust_risk_reward_effect = {
		INJURY_RISK = injury_risk_low
		DUEL_SUCCESS = duel_success_none
	}
}
scripted_effect combat_move_nut_em_effect = {
	# A headbutt to the face often offends. Both parties, really.
	scope:sc_attacker = {
		increment_combat_debuffs_effect = { DEBUFF_INCREMENT = 4 }
	}
	scope:sc_defender = {
		increment_combat_debuffs_effect = { DEBUFF_INCREMENT = 4 }
	}

	#Change the last move registered for loc purposes.
	if = {
		limit = { this = scope:sc_attacker }
		save_scope_value_as = {
			name = sc_attacker_last_move
			value = flag:nut_em
		}
	}
	if = {
		limit = { this = scope:sc_defender }
		save_scope_value_as = {
			name = sc_defender_last_move
			value = flag:nut_em
		}
	}

	#And adjust risk-reward scores.
	adjust_risk_reward_effect = {
		INJURY_RISK = injury_risk_high
		DUEL_SUCCESS = duel_success_medium
	}
}

# Tier Two move effects
scripted_effect combat_move_guard_effect = {
	#No special effects.

	#Change the last move registered for loc purposes.
	if = {
		limit = { this = scope:sc_attacker }
		save_scope_value_as = {
			name = sc_attacker_last_move
			value = flag:guard
		}
	}
	if = {
		limit = { this = scope:sc_defender }
		save_scope_value_as = {
			name = sc_defender_last_move
			value = flag:guard
		}
	}

	#And adjust risk-reward scores.
	adjust_risk_reward_effect = {
		INJURY_RISK = injury_risk_low
		DUEL_SUCCESS = duel_success_low
	}
}
scripted_effect combat_move_probing_attack_effect = {
	#No special effects.

	#Change the last move registered for loc purposes.
	if = {
		limit = { this = scope:sc_attacker }
		save_scope_value_as = {
			name = sc_attacker_last_move
			value = flag:probing_attack
		}
	}
	if = {
		limit = { this = scope:sc_defender }
		save_scope_value_as = {
			name = sc_defender_last_move
			value = flag:probing_attack
		}
	}

	#And adjust risk-reward scores.
	adjust_risk_reward_effect = {
		INJURY_RISK = injury_risk_medium
		DUEL_SUCCESS = duel_success_medium
	}
}
scripted_effect combat_move_onslaught_effect = {
	#No special effects.

	#Change the last move registered for loc purposes.
	if = {
		limit = { this = scope:sc_attacker }
		save_scope_value_as = {
			name = sc_attacker_last_move
			value = flag:onslaught
		}
	}
	if = {
		limit = { this = scope:sc_defender }
		save_scope_value_as = {
			name = sc_defender_last_move
			value = flag:onslaught
		}
	}

	#And adjust risk-reward scores.
	adjust_risk_reward_effect = {
		INJURY_RISK = injury_risk_high
		DUEL_SUCCESS = duel_success_high
	}
}
scripted_effect combat_move_surprise_attack_effect = {
	#Special effects taken care of in risk-reward section.

	#Change the last move registered for loc purposes.
	if = {
		limit = { this = scope:sc_attacker }
		save_scope_value_as = {
			name = sc_attacker_last_move
			value = flag:surprise_attack
		}
	}
	if = {
		limit = { this = scope:sc_defender }
		save_scope_value_as = {
			name = sc_defender_last_move
			value = flag:surprise_attack
		}
	}

	#And adjust risk-reward scores.
	if = {
		limit = {
			OR = {
				AND = {
					this = scope:sc_attacker
					scope:sc_defender = { has_trait = trusting }
				}
				AND = {
					this = scope:sc_defender
					scope:sc_attacker = { has_trait = trusting }
				}
			}
		}
		adjust_risk_reward_effect = {
			INJURY_RISK = injury_risk_medium
			DUEL_SUCCESS = duel_success_very_high
		}
	}
	else = {
		random_list = {
			33 = {
				adjust_risk_reward_effect = {
					INJURY_RISK = injury_risk_medium
					DUEL_SUCCESS = duel_success_low
				}
			}
			34 = {
				adjust_risk_reward_effect = {
					INJURY_RISK = injury_risk_medium
					DUEL_SUCCESS = duel_success_medium
				}
			}
			33 = {
				adjust_risk_reward_effect = {
					INJURY_RISK = injury_risk_medium
					DUEL_SUCCESS = duel_success_high
				}
			}
		}
	}
}
scripted_effect combat_move_taunt_effect = {
	#Your AI opponent becomes enraged.
	if = {
		limit = { this = scope:sc_attacker }
		scope:sc_defender = {
			add_character_modifier = { modifier = combat_move_taunt_modifier }
		}
	}
	if = {
		limit = { this = scope:sc_defender }
		scope:sc_attacker = {
			add_character_modifier = { modifier = combat_move_taunt_modifier }
		}
	}

	#Change the last move registered for loc purposes.
	if = {
		limit = { this = scope:sc_attacker }
		save_scope_value_as = {
			name = sc_attacker_last_move
			value = flag:taunt
		}
	}
	if = {
		limit = { this = scope:sc_defender }
		save_scope_value_as = {
			name = sc_defender_last_move
			value = flag:taunt
		}
	}

	#And adjust risk-reward scores.
	adjust_risk_reward_effect = {
		INJURY_RISK = injury_risk_medium
		DUEL_SUCCESS = duel_success_none
	}
}
scripted_effect combat_move_put_the_boot_in_effect = {
	#No special effects.

	#Change the last move registered for loc purposes.
	if = {
		limit = { this = scope:sc_attacker }
		save_scope_value_as = {
			name = sc_attacker_last_move
			value = flag:put_the_boot_in
		}
	}
	if = {
		limit = { this = scope:sc_defender }
		save_scope_value_as = {
			name = sc_defender_last_move
			value = flag:put_the_boot_in
		}
	}

	#And adjust risk-reward scores.
	adjust_risk_reward_effect = {
		INJURY_RISK = injury_risk_very_high
		DUEL_SUCCESS = duel_success_very_high
	}
}

# Tier Three move effects
scripted_effect combat_move_strict_guard_effect = {
	#No special effects.

	#Change the last move registered for loc purposes.
	if = {
		limit = { this = scope:sc_attacker }
		save_scope_value_as = {
			name = sc_attacker_last_move
			value = flag:strict_guard
		}
	}
	if = {
		limit = { this = scope:sc_defender }
		save_scope_value_as = {
			name = sc_defender_last_move
			value = flag:strict_guard
		}
	}

	#And adjust risk-reward scores.
	adjust_risk_reward_effect = {
		INJURY_RISK = injury_risk_none
		DUEL_SUCCESS = duel_success_low
	}
}
scripted_effect combat_move_confident_attack_effect = {
	#No special effects.

	#Change the last move registered for loc purposes.
	if = {
		limit = { this = scope:sc_attacker }
		save_scope_value_as = {
			name = sc_attacker_last_move
			value = flag:confident_attack
		}
	}
	if = {
		limit = { this = scope:sc_defender }
		save_scope_value_as = {
			name = sc_defender_last_move
			value = flag:confident_attack
		}
	}

	#And adjust risk-reward scores.
	adjust_risk_reward_effect = {
		INJURY_RISK = injury_risk_low
		DUEL_SUCCESS = duel_success_medium
	}
}
scripted_effect combat_move_expert_onslaught_effect = {
	#No special effects.

	#Change the last move registered for loc purposes.
	if = {
		limit = { this = scope:sc_attacker }
		save_scope_value_as = {
			name = sc_attacker_last_move
			value = flag:expert_onslaught
		}
	}
	if = {
		limit = { this = scope:sc_defender }
		save_scope_value_as = {
			name = sc_defender_last_move
			value = flag:expert_onslaught
		}
	}

	#And adjust risk-reward scores.
	adjust_risk_reward_effect = {
		INJURY_RISK = injury_risk_medium
		DUEL_SUCCESS = duel_success_high
	}
}
scripted_effect combat_move_attempt_disarm_effect = {
	# You attempt to disarm your opponent, making their grip on their weapon shaky.
	## Scope:sc_attacker first.
	if = {
		limit = { this = scope:sc_attacker }
		scope:sc_defender = {
			increment_combat_debuffs_effect = { DEBUFF_INCREMENT = 6 }
		}
	}
	## Then scope:sc_defender.
	if = {
		limit = { this = scope:sc_defender }
		scope:sc_attacker = {
			increment_combat_debuffs_effect = { DEBUFF_INCREMENT = 6 }
		}
	}

	#Change the last move registered for loc purposes.
	if = {
		limit = { this = scope:sc_attacker }
		save_scope_value_as = {
			name = sc_attacker_last_move
			value = flag:attempt_disarm
		}
	}
	if = {
		limit = { this = scope:sc_defender }
		save_scope_value_as = {
			name = sc_defender_last_move
			value = flag:attempt_disarm
		}
	}

	#And adjust risk-reward scores.
	adjust_risk_reward_effect = {
		INJURY_RISK = injury_risk_medium
		DUEL_SUCCESS = duel_success_low
	}
}
scripted_effect combat_move_lightning_assault_effect = {
	#No special effects.

	#Change the last move registered for loc purposes.
	if = {
		limit = { this = scope:sc_attacker }
		save_scope_value_as = {
			name = sc_attacker_last_move
			value = flag:lightning_assault
		}
	}
	if = {
		limit = { this = scope:sc_defender }
		save_scope_value_as = {
			name = sc_defender_last_move
			value = flag:lightning_assault
		}
	}

	#And adjust risk-reward scores.
	adjust_risk_reward_effect = {
		INJURY_RISK = injury_risk_high
		DUEL_SUCCESS = duel_success_very_high
	}
}
scripted_effect combat_move_tire_opponent_effect = {
	# Drastically improve your own wound threshold due to relative tiredness.
	if = {
		limit = { this = scope:sc_attacker }
		change_variable = {
			name = sc_attacker_injury_risk_score
			add = combat_move_wound_threshold_bonus_2
		}
		custom_tooltip = single_combat.0001.wound_threshold.medium_bonus.tt
	}
	if = {
		limit = { this = scope:sc_defender }
		change_variable = {
			name = sc_defender_injury_risk_score
			add = combat_move_wound_threshold_bonus_2
		}
		custom_tooltip = single_combat.0001.wound_threshold.medium_bonus.tt
	}

	#Change the last move registered for loc purposes.
	if = {
		limit = { this = scope:sc_attacker }
		save_scope_value_as = {
			name = sc_attacker_last_move
			value = flag:tire_opponent
		}
	}
	if = {
		limit = { this = scope:sc_defender }
		save_scope_value_as = {
			name = sc_defender_last_move
			value = flag:tire_opponent
		}
	}

	#And adjust risk-reward scores.
	adjust_risk_reward_effect = {
		INJURY_RISK = injury_risk_none
		DUEL_SUCCESS = duel_success_low
	}
}

# High Secondary Skill move effects
scripted_effect combat_move_reason_you_suck_speech_effect = {
	# Explain, at length, why your opponent is a cad & you're rad.
	add_prestige = combat_move_reason_you_suck_speech_value

	#Change the last move registered for loc purposes.
	if = {
		limit = { this = scope:sc_attacker }
		save_scope_value_as = {
			name = sc_attacker_last_move
			value = flag:reason_you_suck_speech
		}
	}
	if = {
		limit = { this = scope:sc_defender }
		save_scope_value_as = {
			name = sc_defender_last_move
			value = flag:reason_you_suck_speech
		}
	}

	#And adjust risk-reward scores.
	adjust_risk_reward_effect = {
		INJURY_RISK = injury_risk_medium
		DUEL_SUCCESS = duel_success_none
	}
}
scripted_effect combat_move_technique_from_legend_effect = {
	#No special effects.

	#Change the last move registered for loc purposes.
	if = {
		limit = { this = scope:sc_attacker }
		save_scope_value_as = {
			name = sc_attacker_last_move
			value = flag:technique_from_legend
		}
	}
	if = {
		limit = { this = scope:sc_defender }
		save_scope_value_as = {
			name = sc_defender_last_move
			value = flag:technique_from_legend
		}
	}

	#And adjust risk-reward scores.
	adjust_risk_reward_effect = {
		INJURY_RISK = injury_risk_low
		DUEL_SUCCESS = duel_success_high
	}
}
scripted_effect combat_move_like_a_viper_effect = {
	# Drastically reduce your opponent's wound threshold by off-balancing them.
	if = {
		limit = { this = scope:sc_attacker }
		scope:sc_defender = {
			change_variable = {
				name = sc_defender_injury_risk_score
				add = combat_move_wound_threshold_malus_2
			}
		}
		custom_tooltip = single_combat.0001.wound_threshold.medium_malus.tt
	}
	if = {
		limit = { this = scope:sc_defender }
		scope:sc_attacker = {
			change_variable = {
				name = sc_attacker_injury_risk_score
				add = combat_move_wound_threshold_malus_2
			}
		}
		custom_tooltip = single_combat.0001.wound_threshold.medium_malus.tt
	}

	#Change the last move registered for loc purposes.
	if = {
		limit = { this = scope:sc_attacker }
		save_scope_value_as = {
			name = sc_attacker_last_move
			value = flag:like_a_viper
		}
	}
	if = {
		limit = { this = scope:sc_defender }
		save_scope_value_as = {
			name = sc_defender_last_move
			value = flag:like_a_viper
		}
	}

	#And adjust risk-reward scores.
	adjust_risk_reward_effect = {
		INJURY_RISK = injury_risk_medium
		DUEL_SUCCESS = duel_success_high
	}
}
scripted_effect combat_move_pocket_silver_effect = {
	# You fling a purse of silver right at your opponent's face.
	## We deliberately don't use pay_short_term_gold, since that'll read weirdly to the player.
	if = {
		limit = { this = scope:sc_attacker }
		remove_short_term_gold = combat_move_pocket_silver_value
		scope:sc_defender = { add_gold = combat_move_pocket_silver_value }
	}
	if = {
		limit = { this = scope:sc_defender }
		remove_short_term_gold = combat_move_pocket_silver_value
		scope:sc_attacker = { add_gold = combat_move_pocket_silver_value }
	}

	#Change the last move registered for loc purposes.
	if = {
		limit = { this = scope:sc_attacker }
		save_scope_value_as = {
			name = sc_attacker_last_move
			value = flag:pocket_silver
		}
	}
	if = {
		limit = { this = scope:sc_defender }
		save_scope_value_as = {
			name = sc_defender_last_move
			value = flag:pocket_silver
		}
	}

	#And adjust risk-reward scores.
	adjust_risk_reward_effect = {
		INJURY_RISK = injury_risk_none
		DUEL_SUCCESS = duel_success_medium
	}
}
scripted_effect combat_move_martial_voice_effect = {
	# You go drill sergeant on your opponent.
	## Scope:sc_attacker first.
	if = {
		limit = { this = scope:sc_attacker }
		scope:sc_defender = {
			# Arrogant characters are a bit less susceptible to this.
			if = {
				limit = { has_trait = arrogant }
				increment_combat_debuffs_effect = { DEBUFF_INCREMENT = 2 }
			}
			else = {
				increment_combat_debuffs_effect = { DEBUFF_INCREMENT = 4 }
			}
		}
	}
	## Then we look at scope:sc_defender.
	else_if = {
		limit = { this = scope:sc_defender }
		scope:sc_attacker = {
			# Arrogant characters are a bit less susceptible to this.
			if = {
				limit = { has_trait = arrogant }
				increment_combat_debuffs_effect = { DEBUFF_INCREMENT = 2 }
			}
			else = {
				increment_combat_debuffs_effect = { DEBUFF_INCREMENT = 4 }
			}
		}
	}

	#Change the last move registered for loc purposes.
	if = {
		limit = { this = scope:sc_attacker }
		save_scope_value_as = {
			name = sc_attacker_last_move
			value = flag:martial_voice
		}
	}
	if = {
		limit = { this = scope:sc_defender }
		save_scope_value_as = {
			name = sc_defender_last_move
			value = flag:martial_voice
		}
	}

	#And adjust risk-reward scores.
	adjust_risk_reward_effect = {
		INJURY_RISK = injury_risk_low
		DUEL_SUCCESS = duel_success_none
	}
}
scripted_effect combat_move_mocking_boast_effect = {
	# Your opponent takes +4 levels of combat debuffs, and some stress.
	## Scope:sc_attacker first.
	if = {
		limit = { this = scope:sc_attacker }
		scope:sc_defender = {
			increment_combat_debuffs_effect = { DEBUFF_INCREMENT = 2 }
			# Arrogant characters are a bit more susceptible.
			if = {
				limit = { has_trait = arrogant }
				add_stress = medium_stress_gain
			}
			else = { add_stress = minor_stress_gain }
		}
	}
	## Then we look at scope:sc_defender.
	else_if = {
		limit = { this = scope:sc_defender }
		scope:sc_attacker = {
			increment_combat_debuffs_effect = { DEBUFF_INCREMENT = 2 }
			# Arrogant characters are a bit more susceptible.
			if = {
				limit = { has_trait = arrogant }
				add_stress = medium_stress_gain
			}
			else = { add_stress = minor_stress_gain }
		}
	}

	#Change the last move registered for loc purposes.
	if = {
		limit = { this = scope:sc_attacker }
		save_scope_value_as = {
			name = sc_attacker_last_move
			value = flag:mocking_boast
		}
	}
	if = {
		limit = { this = scope:sc_defender }
		save_scope_value_as = {
			name = sc_defender_last_move
			value = flag:mocking_boast
		}
	}

	#And adjust risk-reward scores.
	adjust_risk_reward_effect = {
		INJURY_RISK = injury_risk_none
		DUEL_SUCCESS = duel_success_none
	}
}

# Location-Specific move effects
scripted_effect combat_move_is_that_a_crocodile_effect = {
	#No special effects.

	#Change the last move registered for loc purposes.
	if = {
		limit = { this = scope:sc_attacker }
		save_scope_value_as = {
			name = sc_attacker_last_move
			value = flag:is_that_a_crocodile
		}
	}
	if = {
		limit = { this = scope:sc_defender }
		save_scope_value_as = {
			name = sc_defender_last_move
			value = flag:is_that_a_crocodile
		}
	}

	# Maximum of one crocodile per fight.
	save_scope_value_as = {
		name = had_crocodile
		value = yes
	}

	#And adjust risk-reward scores.
	adjust_risk_reward_effect = {
		INJURY_RISK = injury_risk_none
		DUEL_SUCCESS = duel_success_very_high
	}
}
scripted_effect combat_move_desert_warrior_effect = {
	#Add +2 ranks of combat buff.
	increment_combat_buffs_effect = { BUFF_INCREMENT = 2 }

	#Change the last move registered for loc purposes.
	if = {
		limit = { this = scope:sc_attacker }
		save_scope_value_as = {
			name = sc_attacker_last_move
			value = flag:desert_warrior
		}
	}
	if = {
		limit = { this = scope:sc_defender }
		save_scope_value_as = {
			name = sc_defender_last_move
			value = flag:desert_warrior
		}
	}

	#And adjust risk-reward scores.
	adjust_risk_reward_effect = {
		INJURY_RISK = injury_risk_low
		DUEL_SUCCESS = duel_success_high
	}
}
scripted_effect combat_move_jungle_stalker_effect = {
	#Add +2 ranks of combat buff.
	increment_combat_buffs_effect = { BUFF_INCREMENT = 2 }

	#Change the last move registered for loc purposes.
	if = {
		limit = { this = scope:sc_attacker }
		save_scope_value_as = {
			name = sc_attacker_last_move
			value = flag:jungle_stalker
		}
	}
	if = {
		limit = { this = scope:sc_defender }
		save_scope_value_as = {
			name = sc_defender_last_move
			value = flag:jungle_stalker
		}
	}

	#And adjust risk-reward scores.
	adjust_risk_reward_effect = {
		INJURY_RISK = injury_risk_low
		DUEL_SUCCESS = duel_success_high
	}
}
scripted_effect combat_move_open_terrain_expert_effect = {
	#Add +2 ranks of combat buff.
	increment_combat_buffs_effect = { BUFF_INCREMENT = 2 }

	#Change the last move registered for loc purposes.
	if = {
		limit = { this = scope:sc_attacker }
		save_scope_value_as = {
			name = sc_attacker_last_move
			value = flag:open_terrain_expert
		}
	}
	if = {
		limit = { this = scope:sc_defender }
		save_scope_value_as = {
			name = sc_defender_last_move
			value = flag:open_terrain_expert
		}
	}

	#And adjust risk-reward scores.
	adjust_risk_reward_effect = {
		INJURY_RISK = injury_risk_low
		DUEL_SUCCESS = duel_success_high
	}
}
scripted_effect combat_move_rough_terrain_expert_effect = {
	#Add +2 ranks of combat buff.
	increment_combat_buffs_effect = { BUFF_INCREMENT = 2 }

	#Change the last move registered for loc purposes.
	if = {
		limit = { this = scope:sc_attacker }
		save_scope_value_as = {
			name = sc_attacker_last_move
			value = flag:rough_terrain_expert
		}
	}
	if = {
		limit = { this = scope:sc_defender }
		save_scope_value_as = {
			name = sc_defender_last_move
			value = flag:rough_terrain_expert
		}
	}

	#And adjust risk-reward scores.
	adjust_risk_reward_effect = {
		INJURY_RISK = injury_risk_low
		DUEL_SUCCESS = duel_success_high
	}
}
scripted_effect combat_move_forest_fighter_effect = {
	#Add +2 ranks of combat buff.
	increment_combat_buffs_effect = { BUFF_INCREMENT = 2 }

	#Change the last move registered for loc purposes.
	if = {
		limit = { this = scope:sc_attacker }
		save_scope_value_as = {
			name = sc_attacker_last_move
			value = flag:forest_fighter
		}
	}
	if = {
		limit = { this = scope:sc_defender }
		save_scope_value_as = {
			name = sc_defender_last_move
			value = flag:forest_fighter
		}
	}

	#And adjust risk-reward scores.
	adjust_risk_reward_effect = {
		INJURY_RISK = injury_risk_low
		DUEL_SUCCESS = duel_success_high
	}
}

# Trait-Specific move effects
scripted_effect combat_move_raaargh_effect = {
	#Going berserk is a major stress relief.
	add_stress = medium_stress_loss

	#Change the last move registered for loc purposes.
	if = {
		limit = { this = scope:sc_attacker }
		save_scope_value_as = {
			name = sc_attacker_last_move
			value = flag:raaargh
		}
	}
	if = {
		limit = { this = scope:sc_defender }
		save_scope_value_as = {
			name = sc_defender_last_move
			value = flag:raaargh
		}
	}

	#And adjust risk-reward scores.
	adjust_risk_reward_effect = {
		INJURY_RISK = injury_risk_medium
		DUEL_SUCCESS = duel_success_very_high
	}
}
scripted_effect combat_move_hard_grit_effect = {
	#Add +4 ranks of combat buff.
	increment_combat_buffs_effect = { BUFF_INCREMENT = 4 }

	#Change the last move registered for loc purposes.
	if = {
		limit = { this = scope:sc_attacker }
		save_scope_value_as = {
			name = sc_attacker_last_move
			value = flag:hard_grit
		}
	}
	if = {
		limit = { this = scope:sc_defender }
		save_scope_value_as = {
			name = sc_defender_last_move
			value = flag:hard_grit
		}
	}

	#And adjust risk-reward scores.
	adjust_risk_reward_effect = {
		INJURY_RISK = injury_risk_none
		DUEL_SUCCESS = duel_success_high
	}
}
scripted_effect combat_move_feint_and_stab_effect = {
	# Quick-thinking is a habit.
	add_character_modifier = {
		modifier = combat_move_feint_and_stab_modifier
		years = 5
	}

	#Change the last move registered for loc purposes.
	if = {
		limit = { this = scope:sc_attacker }
		save_scope_value_as = {
			name = sc_attacker_last_move
			value = flag:feint_and_stab
		}
	}
	if = {
		limit = { this = scope:sc_defender }
		save_scope_value_as = {
			name = sc_defender_last_move
			value = flag:feint_and_stab
		}
	}

	#And adjust risk-reward scores.
	adjust_risk_reward_effect = {
		INJURY_RISK = injury_risk_medium
		DUEL_SUCCESS = duel_success_high
	}
}
scripted_effect combat_move_butchery_effect = {
	# Show people what happens when they mess with you.
	add_dread = combat_move_butchery_dread_value

	#Change the last move registered for loc purposes.
	if = {
		limit = { this = scope:sc_attacker }
		save_scope_value_as = {
			name = sc_attacker_last_move
			value = flag:butchery
		}
	}
	if = {
		limit = { this = scope:sc_defender }
		save_scope_value_as = {
			name = sc_defender_last_move
			value = flag:butchery
		}
	}

	#And adjust risk-reward scores.
	adjust_risk_reward_effect = {
		INJURY_RISK = injury_risk_medium
		DUEL_SUCCESS = duel_success_high
	}
}
scripted_effect combat_move_stoic_veteran_effect = {
	# You didn't die in Miklagard, you won't die here, you won't even die soon.
	add_character_modifier = {
		modifier = combat_move_stoic_veteran_modifier
		years = 5
	}

	#Change the last move registered for loc purposes.
	if = {
		limit = { this = scope:sc_attacker }
		save_scope_value_as = {
			name = sc_attacker_last_move
			value = flag:stoic_veteran
		}
	}
	if = {
		limit = { this = scope:sc_defender }
		save_scope_value_as = {
			name = sc_defender_last_move
			value = flag:stoic_veteran
		}
	}

	#And adjust risk-reward scores.
	adjust_risk_reward_effect = {
		INJURY_RISK = injury_risk_none
		DUEL_SUCCESS = duel_success_medium
	}
}
scripted_effect combat_move_blade_dance_effect = {
	# Show off your skill with the blade.
	add_prestige = combat_move_blade_dance_value

	#Change the last move registered for loc purposes.
	if = {
		limit = { this = scope:sc_attacker }
		save_scope_value_as = {
			name = sc_attacker_last_move
			value = flag:blade_dance
		}
	}
	if = {
		limit = { this = scope:sc_defender }
		save_scope_value_as = {
			name = sc_defender_last_move
			value = flag:blade_dance
		}
	}

	#And adjust risk-reward scores.
	adjust_risk_reward_effect = {
		INJURY_RISK = injury_risk_low
		DUEL_SUCCESS = duel_success_high
	}
}
## Not a separate combat move, just an effect inside the subsequent one.
scripted_effect combat_move_wrath_of_highgod_piety_reward_effect = {
	# Non-scripted values used to keep the piety amount low; you might take this option several times in one duel, so we don't really want you to be farming piety from it.

	# Righteous faiths give little piety
	if = {
		limit = {
			faith = {
				faith_hostility_level = {
					target = $MY_FOE$.faith
					value = faith_fully_accepted_level
				}
			}
		}
		add_piety = 10
	}
	# Astray faiths are a bit further from the light
	else_if = {
		limit = {
			faith = {
				faith_hostility_level = {
					target = $MY_FOE$.faith
					value = faith_astray_level
				}
			}
		}
		add_piety = 25
	}
	# Hostile faiths make HighGod sit up and take notice
	else_if = {
		limit = {
			faith = {
				faith_hostility_level = {
					target = $MY_FOE$.faith
					value = faith_hostile_level
				}
			}
		}
		add_piety = 50
	}
	# Evil faiths are actually worth writing home about
	else_if = {
		limit = {
			faith = {
				faith_hostility_level = {
					target = $MY_FOE$.faith
					value = faith_evil_level
				}
			}
		}
		add_piety = 75
	}
}
scripted_effect combat_move_wrath_of_highgod_effect = {
	#Earn piety scaling with how intolerant you are of your opponent.
	if = {
		limit = { this = scope:sc_attacker }
		combat_move_wrath_of_highgod_piety_reward_effect = { MY_FOE = scope:sc_defender }
	}
	if = {
		limit = { this = scope:sc_defender }
		combat_move_wrath_of_highgod_piety_reward_effect = { MY_FOE = scope:sc_attacker }
	}

	#Change the last move registered for loc purposes.
	if = {
		limit = { this = scope:sc_attacker }
		save_scope_value_as = {
			name = sc_attacker_last_move
			value = flag:wrath_of_highgod
		}
	}
	if = {
		limit = { this = scope:sc_defender }
		save_scope_value_as = {
			name = sc_defender_last_move
			value = flag:wrath_of_highgod
		}
	}

	#And adjust risk-reward scores.
	adjust_risk_reward_effect = {
		INJURY_RISK = injury_risk_none
		DUEL_SUCCESS = duel_success_low
	}
}
scripted_effect combat_move_hurt_me_better_effect = {
	# Deviant characters can cancel out their wound penalties, or gain a moderate buff otherwise.
	if = {
		limit = {
			# To cancel out wounded, they must have any wounded trait.
			has_trait = wounded
			# And must not have cancelled it out already.
			NOR = {
				has_character_modifier = combat_move_hurt_me_better_wounded_1_modifier
				has_character_modifier = combat_move_hurt_me_better_wounded_2_modifier
				has_character_modifier = combat_move_hurt_me_better_wounded_3_modifier
			}
		}
		if = {
			limit = { has_trait = wounded_1 }
			add_character_modifier = combat_move_hurt_me_better_wounded_1_modifier
		}
		else_if = {
			limit = { has_trait = wounded_2 }
			add_character_modifier = combat_move_hurt_me_better_wounded_2_modifier
		}
		else_if = {
			limit = { has_trait = wounded_3 }
			add_character_modifier = combat_move_hurt_me_better_wounded_3_modifier
		}
	}
	else = {
		# Otherwise, we just buff their duel edge twice.
		increment_combat_buffs_effect = { BUFF_INCREMENT = 2 }
	}

	#Change the last move registered for loc purposes.
	if = {
		limit = { this = scope:sc_attacker }
		save_scope_value_as = {
			name = sc_attacker_last_move
			value = flag:hurt_me_better
		}
	}
	if = {
		limit = { this = scope:sc_defender }
		save_scope_value_as = {
			name = sc_defender_last_move
			value = flag:hurt_me_better
		}
	}

	#And adjust risk-reward scores.
	adjust_risk_reward_effect = {
		INJURY_RISK = injury_risk_medium
		DUEL_SUCCESS = duel_success_medium
	}
}

# Misc move effects
scripted_effect combat_move_special_fallback_effect = {
	#No special effects.

	#Change the last move registered for loc purposes.
	if = {
		limit = { this = scope:sc_attacker }
		save_scope_value_as = {
			name = sc_attacker_last_move
			value = flag:special_fallback
		}
	}
	if = {
		limit = { this = scope:sc_defender }
		save_scope_value_as = {
			name = sc_defender_last_move
			value = flag:special_fallback
		}
	}

	#And adjust risk-reward scores.
	adjust_risk_reward_effect = {
		INJURY_RISK = injury_risk_low
		DUEL_SUCCESS = duel_success_low
	}
}
scripted_effect combat_move_something_to_hide_effect = {
	# You imply that things might go poorly for your opponent if they don't back down.
	## Scope:sc_attacker first.
	if = {
		limit = { this = scope:sc_attacker }
		# If the hook is strong, then add +8 ranks of combat debuff for your opponent.
		if = {
			limit = { has_strong_usable_hook = scope:sc_defender }
			scope:sc_defender = {
				increment_combat_debuffs_effect = { DEBUFF_INCREMENT = 8 }
			}
		}
		# Otherwise, we only add +4 ranks.
		else = {
			scope:sc_defender = {
				increment_combat_debuffs_effect = { DEBUFF_INCREMENT = 4 }
			}
		}
	}
	## Then scope:sc_defender.
	if = {
		limit = { this = scope:sc_defender }
		# If the hook is strong, then add +8 ranks of combat debuff for your opponent.
		if = {
			limit = { has_strong_usable_hook = scope:sc_attacker }
			scope:sc_attacker = {
				increment_combat_debuffs_effect = { DEBUFF_INCREMENT = 8 }
			}
		}
		# Otherwise, we only add +4 ranks.
		else = {
			scope:sc_attacker = {
				increment_combat_debuffs_effect = { DEBUFF_INCREMENT = 4 }
			}
		}
	}

	#Change the last move registered for loc purposes.
	if = {
		limit = { this = scope:sc_attacker }
		save_scope_value_as = {
			name = sc_attacker_last_move
			value = flag:something_to_hide
		}
	}
	if = {
		limit = { this = scope:sc_defender }
		save_scope_value_as = {
			name = sc_defender_last_move
			value = flag:something_to_hide
		}
	}

	#And adjust risk-reward scores.
	adjust_risk_reward_effect = {
		INJURY_RISK = injury_risk_none
		DUEL_SUCCESS = duel_success_none
	}
}

# Artifact damage effect - input slot type, chance for damage to happen at all, and max possible damage as percent of max possible
scripted_effect may_damage_artifact_effect = {
	if = {
		limit = {
			any_equipped_character_artifact = {
				# Warcraft
				artifact_can_be_damaged_trigger = yes
				
				artifact_slot_type = $TYPE$
			}
		}
		random_equipped_character_artifact = {
			limit = {
				# Warcraft
				artifact_can_be_damaged_trigger = yes
				
				artifact_slot_type = $TYPE$
			}
			random = {
				chance = $CHANCE$
				add_durability = {
					value = artifact_max_durability
					multiply = {
						value = {
							integer_range = {
								min = 5
								max = $PERCENT$
							} 
						}
						multiply = -0.01
					}
				}
			}
		}
	}
}

##################################################
# SINGLE COMBAT EVENTS

##################################################
# Participant Events
# by Ewan Cowhig Croft
# 0001 - 0020
##################################################

#	Standard combat event.
single_combat.0001 = {
	type = character_event
	window = duel_event
	title = {
		first_valid = {
			triggered_desc = {
				trigger = { this = scope:sc_defender }
				desc = single_combat.0001.t
			}
			triggered_desc = {
				trigger = { this = scope:sc_attacker }
				desc = single_combat.0011.t
			}
		}
	}
	desc = {
		first_valid = {
			#If we're scope:sc_defender, give us defensive descs.
			triggered_desc = {
				trigger = { this = scope:sc_defender }
				desc = {
					# First round.
					## We just play an intro spiel.
					triggered_desc = {
						trigger = { scope:sc_defender.var:current_round = 1 }
						desc = single_combat.0001.desc.sc_defender.intro
					}
					## Slightly different capstone speeches, depending on how deadly the duel is expected to be.
					triggered_desc = {
						trigger = {
							scope:sc_defender.var:current_round = 1
							duel_will_end_in_opponent_death_trigger = no
						}
						desc = single_combat.0001.desc.capstone.intro.first_blood
					}
					triggered_desc = {
						trigger = {
							scope:sc_defender.var:current_round = 1
							duel_will_end_in_opponent_death_trigger = yes
						}
						desc = single_combat.0001.desc.capstone.intro.deadly
					}
					# Scope:sc_defender feedback.
					## So you can see a bit of fairly-static feedback on how your selected combat move went.
					triggered_desc = {
						trigger = { exists = scope:sc_defender_last_move }
						desc = {
							first_valid = {
								triggered_desc = {
									trigger = {
										scope:sc_defender_last_move = flag:wait_and_hope
										duel_will_end_in_my_death_trigger = yes
										NOT = { has_trait = brave }
									}
									desc = single_combat.0001.desc.my_feedback.wait_and_hope.will_die
								}
								triggered_desc = {
									trigger = {
										scope:sc_defender_last_move = flag:wait_and_hope
										OR = {
											duel_will_end_in_my_death_trigger = no
											has_trait = brave
										}
									}
									desc = single_combat.0001.desc.my_feedback.wait_and_hope.will_live
								}
								triggered_desc = {
									trigger = { scope:sc_defender_last_move = flag:unsure_attack }
									desc = single_combat.0001.desc.my_feedback.unsure_attack
								}
								triggered_desc = {
									trigger = { scope:sc_defender_last_move = flag:enthusiastic_onslaught }
									desc = single_combat.0001.desc.my_feedback.enthusiastic_onslaught
								}
								triggered_desc = {
									trigger = { scope:sc_defender_last_move = flag:hail_mary }
									desc = single_combat.0001.desc.my_feedback.hail_mary
								}
								triggered_desc = {
									trigger = { scope:sc_defender_last_move = flag:pocket_sand }
									desc = single_combat.0001.desc.my_feedback.pocket_sand
								}
								triggered_desc = {
									trigger = { scope:sc_defender_last_move = flag:nut_em }
									desc = single_combat.0001.desc.my_feedback.nut_em
								}
								triggered_desc = {
									trigger = { scope:sc_defender_last_move = flag:guard }
									desc = single_combat.0001.desc.my_feedback.guard
								}
								triggered_desc = {
									trigger = { scope:sc_defender_last_move = flag:probing_attack }
									desc = single_combat.0001.desc.my_feedback.probing_attack
								}
								triggered_desc = {
									trigger = { scope:sc_defender_last_move = flag:onslaught }
									desc = single_combat.0001.desc.my_feedback.onslaught
								}
								triggered_desc = {
									trigger = { scope:sc_defender_last_move = flag:surprise_attack }
									desc = single_combat.0001.desc.my_feedback.surprise_attack
								}
								triggered_desc = {
									trigger = { scope:sc_defender_last_move = flag:taunt }
									desc = single_combat.0001.desc.my_feedback.taunt
								}
								triggered_desc = {
									trigger = { scope:sc_defender_last_move = flag:put_the_boot_in }
									desc = single_combat.0001.desc.my_feedback.put_the_boot_in
								}
								triggered_desc = {
									trigger = { scope:sc_defender_last_move = flag:strict_guard }
									desc = single_combat.0001.desc.my_feedback.strict_guard
								}
								triggered_desc = {
									trigger = { scope:sc_defender_last_move = flag:confident_attack }
									desc = single_combat.0001.desc.my_feedback.confident_attack
								}
								triggered_desc = {
									trigger = { scope:sc_defender_last_move = flag:expert_onslaught }
									desc = single_combat.0001.desc.my_feedback.expert_onslaught
								}
								triggered_desc = {
									trigger = { scope:sc_defender_last_move = flag:attempt_disarm }
									desc = single_combat.0001.desc.my_feedback.attempt_disarm
								}
								triggered_desc = {
									trigger = { scope:sc_defender_last_move = flag:lightning_assault }
									desc = single_combat.0001.desc.my_feedback.lightning_assault
								}
								triggered_desc = {
									trigger = { scope:sc_defender_last_move = flag:tire_opponent }
									desc = single_combat.0001.desc.my_feedback.tire_opponent
								}
								triggered_desc = {
									trigger = { scope:sc_defender_last_move = flag:reason_you_suck_speech }
									desc = single_combat.0001.desc.my_feedback.reason_you_suck_speech
								}
								triggered_desc = {
									trigger = { scope:sc_defender_last_move = flag:technique_from_legend }
									desc = single_combat.0001.desc.my_feedback.technique_from_legend
								}
								triggered_desc = {
									trigger = { scope:sc_defender_last_move = flag:like_a_viper }
									desc = single_combat.0001.desc.my_feedback.like_a_viper
								}
								triggered_desc = {
									trigger = { scope:sc_defender_last_move = flag:pocket_silver }
									desc = single_combat.0001.desc.my_feedback.pocket_silver
								}
								triggered_desc = {
									trigger = { scope:sc_defender_last_move = flag:martial_voice }
									desc = single_combat.0001.desc.my_feedback.martial_voice
								}
								triggered_desc = {
									trigger = { scope:sc_defender_last_move = flag:mocking_boast }
									desc = single_combat.0001.desc.my_feedback.mocking_boast
								}
								triggered_desc = {
									trigger = { scope:sc_defender_last_move = flag:is_that_a_crocodile }
									desc = single_combat.0001.desc.my_feedback.is_that_a_crocodile
								}
								triggered_desc = {
									trigger = { scope:sc_defender_last_move = flag:desert_warrior }
									desc = single_combat.0001.desc.my_feedback.desert_warrior
								}
								triggered_desc = {
									trigger = { scope:sc_defender_last_move = flag:jungle_stalker }
									desc = single_combat.0001.desc.my_feedback.jungle_stalker
								}
								triggered_desc = {
									trigger = { scope:sc_defender_last_move = flag:open_terrain_expert }
									desc = single_combat.0001.desc.my_feedback.open_terrain_expert
								}
								triggered_desc = {
									trigger = {
										scope:sc_defender_last_move = flag:rough_terrain_expert
										scope:sc_defender.location = { rocky_locale_trigger = yes }
									}
									desc = single_combat.0001.desc.my_feedback.rough_terrain_expert.rocky
								}
								triggered_desc = {
									trigger = {
										scope:sc_defender_last_move = flag:rough_terrain_expert
										scope:sc_defender.location = { terrain = wetlands }
									}
									desc = single_combat.0001.desc.my_feedback.rough_terrain_expert.boggy
								}
								triggered_desc = {
									trigger = { scope:sc_defender_last_move = flag:forest_fighter }
									desc = single_combat.0001.desc.my_feedback.forest_fighter
								}
								triggered_desc = {
									trigger = { scope:sc_defender_last_move = flag:raaargh }
									desc = single_combat.0001.desc.my_feedback.raaargh
								}
								triggered_desc = {
									trigger = { scope:sc_defender_last_move = flag:hard_grit }
									desc = single_combat.0001.desc.my_feedback.hard_grit
								}
								triggered_desc = {
									trigger = { scope:sc_defender_last_move = flag:feint_and_stab }
									desc = single_combat.0001.desc.my_feedback.feint_and_stab
								}
								triggered_desc = {
									trigger = { scope:sc_defender_last_move = flag:butchery }
									desc = single_combat.0001.desc.my_feedback.butchery
								}
								triggered_desc = {
									trigger = { scope:sc_defender_last_move = flag:stoic_veteran }
									desc = single_combat.0001.desc.my_feedback.stoic_veteran
								}
								triggered_desc = {
									trigger = { scope:sc_defender_last_move = flag:blade_dance }
									desc = single_combat.0001.desc.my_feedback.blade_dance
								}
								triggered_desc = {
									trigger = { scope:sc_defender_last_move = flag:wrath_of_highgod }
									desc = single_combat.0001.desc.my_feedback.wrath_of_highgod
								}
								triggered_desc = {
									trigger = { scope:sc_defender_last_move = flag:hurt_me_better }
									desc = single_combat.0001.desc.my_feedback.hurt_me_better
								}
								triggered_desc = {
									trigger = { scope:sc_defender_last_move = flag:special_fallback }
									desc = single_combat.0001.desc.my_feedback.special_fallback
								}
								triggered_desc = {
									trigger = { scope:sc_defender_last_move = flag:something_to_hide }
									desc = single_combat.0001.desc.my_feedback.something_to_hide
								}
							}
						}
					}
					# Scope:sc_attacker responses.
					## What move did your opponent pick, and how does that play out from your POV?
					triggered_desc = {
						trigger = { exists = scope:sc_attacker_last_move }
						desc = {
							first_valid = {
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:wait_and_hope }
									desc = single_combat.0001.desc.opponent_response.wait_and_hope
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:unsure_attack }
									desc = single_combat.0001.desc.opponent_response.unsure_attack
								}
								triggered_desc = {
									trigger = {
										scope:sc_attacker_last_move = flag:enthusiastic_onslaught
										scope:sc_attacker = { house_not_allowed_to_yell_motto_trigger = yes }
									}
									desc = single_combat.0001.desc.opponent_response.enthusiastic_onslaught.banned_house
								}
								triggered_desc = {
									trigger = {
										scope:sc_attacker_last_move = flag:enthusiastic_onslaught
										scope:sc_attacker.house = scope:sc_defender.house
									}
									desc = single_combat.0001.desc.opponent_response.enthusiastic_onslaught.own_house
								}
								triggered_desc = {
									trigger = {
										scope:sc_attacker_last_move = flag:enthusiastic_onslaught
										#Otherwise, we can shout the motto.
									}
									desc = single_combat.0001.desc.opponent_response.enthusiastic_onslaught.motto
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:hail_mary }
									desc = single_combat.0001.desc.opponent_response.hail_mary
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:pocket_sand }
									desc = single_combat.0001.desc.opponent_response.pocket_sand
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:nut_em }
									desc = single_combat.0001.desc.opponent_response.nut_em
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:guard }
									desc = single_combat.0001.desc.opponent_response.guard
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:probing_attack }
									desc = single_combat.0001.desc.opponent_response.probing_attack
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:onslaught }
									desc = single_combat.0001.desc.opponent_response.onslaught
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:surprise_attack }
									desc = single_combat.0001.desc.opponent_response.surprise_attack
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:taunt }
									desc = single_combat.0001.desc.opponent_response.taunt
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:put_the_boot_in }
									desc = single_combat.0001.desc.opponent_response.put_the_boot_in
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:strict_guard }
									desc = single_combat.0001.desc.opponent_response.strict_guard
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:confident_attack }
									desc = single_combat.0001.desc.opponent_response.confident_attack
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:expert_onslaught }
									desc = single_combat.0001.desc.opponent_response.expert_onslaught
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:attempt_disarm }
									desc = single_combat.0001.desc.opponent_response.attempt_disarm
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:lightning_assault }
									desc = single_combat.0001.desc.opponent_response.lightning_assault
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:tire_opponent }
									desc = single_combat.0001.desc.opponent_response.tire_opponent
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:reason_you_suck_speech }
									desc = single_combat.0001.desc.opponent_response.reason_you_suck_speech
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:technique_from_legend }
									desc = single_combat.0001.desc.opponent_response.technique_from_legend
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:like_a_viper }
									desc = single_combat.0001.desc.opponent_response.like_a_viper
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:pocket_silver }
									desc = single_combat.0001.desc.opponent_response.pocket_silver
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:martial_voice }
									desc = single_combat.0001.desc.opponent_response.martial_voice
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:mocking_boast }
									desc = single_combat.0001.desc.opponent_response.mocking_boast
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:is_that_a_crocodile }
									desc = single_combat.0001.desc.opponent_response.is_that_a_crocodile
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:desert_warrior }
									desc = single_combat.0001.desc.opponent_response.desert_warrior
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:jungle_stalker }
									desc = single_combat.0001.desc.opponent_response.jungle_stalker
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:open_terrain_expert }
									desc = single_combat.0001.desc.opponent_response.open_terrain_expert
								}
								triggered_desc = {
									trigger = {
										scope:sc_attacker_last_move = flag:rough_terrain_expert
										scope:sc_defender.location = { rocky_locale_trigger = yes }
									}
									desc = single_combat.0001.desc.opponent_response.rough_terrain_expert.rocky
								}
								triggered_desc = {
									trigger = {
										scope:sc_attacker_last_move = flag:rough_terrain_expert
										scope:sc_defender.location = { terrain = wetlands }
									}
									desc = single_combat.0001.desc.opponent_response.rough_terrain_expert.boggy
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:forest_fighter }
									desc = single_combat.0001.desc.opponent_response.forest_fighter
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:raaargh }
									desc = single_combat.0001.desc.opponent_response.raaargh
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:hard_grit }
									desc = single_combat.0001.desc.opponent_response.hard_grit
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:feint_and_stab }
									desc = single_combat.0001.desc.opponent_response.feint_and_stab
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:butchery }
									desc = single_combat.0001.desc.opponent_response.butchery
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:stoic_veteran }
									desc = single_combat.0001.desc.opponent_response.stoic_veteran
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:blade_dance }
									desc = single_combat.0001.desc.opponent_response.blade_dance
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:wrath_of_highgod }
									desc = single_combat.0001.desc.opponent_response.wrath_of_highgod
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:hurt_me_better }
									desc = single_combat.0001.desc.opponent_response.hurt_me_better
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:special_fallback }
									desc = single_combat.0001.desc.opponent_response.special_fallback
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:something_to_hide }
									desc = single_combat.0001.desc.opponent_response.something_to_hide
								}
							}
						}
					}
					# Duel status updates.
					triggered_desc = {
						trigger = { scope:sc_defender.var:current_round > 1 }
						desc = {
							first_valid = {
								# Injury updates.
								## For scope:sc_defender.
								### Injury chance very unlikely.
								triggered_desc = {
									trigger = { sc_defender_injury_check_actual <= single_combat_injury_very_unlikely_value }
									desc = single_combat.0001.desc.injury_check.personal.very_unlikely
								}
								### Injury chance unlikely.
								triggered_desc = {
									trigger = { sc_defender_injury_check_actual <= single_combat_injury_unlikely_value }
									desc = single_combat.0001.desc.injury_check.personal.unlikely
								}
								### Injury chance moderate.
								triggered_desc = {
									trigger = { sc_defender_injury_check_actual <= single_combat_injury_neutral_value }
									desc = single_combat.0001.desc.injury_check.personal.moderate
								}
								### Injury chance likely.
								triggered_desc = {
									trigger = { sc_defender_injury_check_actual <= single_combat_injury_likely_value }
									desc = single_combat.0001.desc.injury_check.personal.likely
								}
								### Injury chance very likely.
								desc = single_combat.0001.desc.injury_check.personal.very_likely
							}
							first_valid = {
								## For scope:sc_attacker.
								### Injury chance very unlikely.
								triggered_desc = {
									trigger = { sc_attacker_injury_check_actual <= single_combat_injury_very_unlikely_value }
									desc = single_combat.0001.desc.injury_check.opponent.very_unlikely
								}
								### Injury chance unlikely.
								triggered_desc = {
									trigger = { sc_attacker_injury_check_actual <= single_combat_injury_unlikely_value }
									desc = single_combat.0001.desc.injury_check.opponent.unlikely
								}
								### Injury chance moderate.
								triggered_desc = {
									trigger = { sc_attacker_injury_check_actual <= single_combat_injury_neutral_value }
									desc = single_combat.0001.desc.injury_check.opponent.moderate
								}
								### Injury chance likely.
								triggered_desc = {
									trigger = { sc_attacker_injury_check_actual <= single_combat_injury_likely_value }
									desc = single_combat.0001.desc.injury_check.opponent.likely
								}
								### Injury chance very likely.
								desc = single_combat.0001.desc.injury_check.opponent.very_likely
							}
							first_valid = {
								# Success updates.
								## Victory almost impossible.
								triggered_desc = {
									trigger = { scope:sc_defender.var:sc_defender_success_check <= single_combat_success_almost_impossible_value }
									desc = single_combat.0001.desc.success_check.almost_impossible
								}
								## Victory very unlikely.
								triggered_desc = {
									trigger = { scope:sc_defender.var:sc_defender_success_check <= single_combat_success_very_unlikely_value }
									desc = single_combat.0001.desc.success_check.very_unlikely
								}
								## Victory unlikely.
								triggered_desc = {
									trigger = { scope:sc_defender.var:sc_defender_success_check <= single_combat_success_unlikely_value }
									desc = single_combat.0001.desc.success_check.unlikely
								}
								## Victory in the balance.
								triggered_desc = {
									trigger = { scope:sc_defender.var:sc_defender_success_check <= single_combat_success_likely_value }
									desc = single_combat.0001.desc.success_check.moderate
								}
								## Victory likely.
								triggered_desc = {
									trigger = { scope:sc_defender.var:sc_defender_success_check <= single_combat_success_very_likely_value }
									desc = single_combat.0001.desc.success_check.likely
								}
								## Victory very likely.
								triggered_desc = {
									trigger = { scope:sc_defender.var:sc_defender_success_check <= single_combat_success_almost_certain_value }
									desc = single_combat.0001.desc.success_check.very_likely
								}
								## Victory almost certain.
								desc = single_combat.0001.desc.success_check.almost_certain
							}
						}
					}
				}
			}
			#Otherwise, give us the offensive descs. Triggered_desc kept for indenting.
			triggered_desc = {
				trigger = { this = scope:sc_attacker }
				desc = {
					# First round.
					## We just play an intro spiel.
					triggered_desc = {
						trigger = { scope:sc_defender.var:current_round = 1 }
						desc = single_combat.0001.desc.sc_attacker.intro
					}
					## Slightly different capstone speeches, depending on how deadly the duel is expected to be.
					triggered_desc = {
						trigger = {
							scope:sc_defender.var:current_round = 1
							duel_will_end_in_opponent_death_trigger = no
						}
						desc = single_combat.0001.desc.capstone.intro.first_blood
					}
					triggered_desc = {
						trigger = {
							scope:sc_defender.var:current_round = 1
							duel_will_end_in_opponent_death_trigger = yes
						}
						desc = single_combat.0001.desc.capstone.intro.deadly
					}
					triggered_desc = {
						trigger = { scope:sc_defender.var:current_round = 1 }
						desc = single_combat.0001.desc.sc_attacker.intro.epilogue
					}
					# Scope:sc_attacker feedback.
					## So you can see a bit of fairly-static feedback on how your selected combat move went.
					triggered_desc = {
						trigger = { exists = scope:sc_attacker_last_move }
						desc = {
							first_valid = {
								triggered_desc = {
									trigger = {
										scope:sc_attacker_last_move = flag:wait_and_hope
										duel_will_end_in_my_death_trigger = yes
										NOT = { has_trait = brave }
									}
									desc = single_combat.0001.desc.my_feedback.wait_and_hope.will_die
								}
								triggered_desc = {
									trigger = {
										scope:sc_attacker_last_move = flag:wait_and_hope
										OR = {
											duel_will_end_in_my_death_trigger = no
											has_trait = brave
										}
									}
									desc = single_combat.0001.desc.my_feedback.wait_and_hope.will_live
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:unsure_attack }
									desc = single_combat.0001.desc.my_feedback.unsure_attack
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:enthusiastic_onslaught }
									desc = single_combat.0001.desc.my_feedback.enthusiastic_onslaught
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:hail_mary }
									desc = single_combat.0001.desc.my_feedback.hail_mary
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:pocket_sand }
									desc = single_combat.0001.desc.my_feedback.pocket_sand
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:nut_em }
									desc = single_combat.0001.desc.my_feedback.nut_em
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:guard }
									desc = single_combat.0001.desc.my_feedback.guard
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:probing_attack }
									desc = single_combat.0001.desc.my_feedback.probing_attack
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:onslaught }
									desc = single_combat.0001.desc.my_feedback.onslaught
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:surprise_attack }
									desc = single_combat.0001.desc.my_feedback.surprise_attack
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:taunt }
									desc = single_combat.0001.desc.my_feedback.taunt
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:put_the_boot_in }
									desc = single_combat.0001.desc.my_feedback.put_the_boot_in
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:strict_guard }
									desc = single_combat.0001.desc.my_feedback.strict_guard
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:confident_attack }
									desc = single_combat.0001.desc.my_feedback.confident_attack
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:expert_onslaught }
									desc = single_combat.0001.desc.my_feedback.expert_onslaught
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:attempt_disarm }
									desc = single_combat.0001.desc.my_feedback.attempt_disarm
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:lightning_assault }
									desc = single_combat.0001.desc.my_feedback.lightning_assault
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:tire_opponent }
									desc = single_combat.0001.desc.my_feedback.tire_opponent
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:reason_you_suck_speech }
									desc = single_combat.0001.desc.my_feedback.reason_you_suck_speech
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:technique_from_legend }
									desc = single_combat.0001.desc.my_feedback.technique_from_legend
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:like_a_viper }
									desc = single_combat.0001.desc.my_feedback.like_a_viper
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:pocket_silver }
									desc = single_combat.0001.desc.my_feedback.pocket_silver
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:martial_voice }
									desc = single_combat.0001.desc.my_feedback.martial_voice
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:mocking_boast }
									desc = single_combat.0001.desc.my_feedback.mocking_boast
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:is_that_a_crocodile }
									desc = single_combat.0001.desc.my_feedback.is_that_a_crocodile
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:desert_warrior }
									desc = single_combat.0001.desc.my_feedback.desert_warrior
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:jungle_stalker }
									desc = single_combat.0001.desc.my_feedback.jungle_stalker
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:open_terrain_expert }
									desc = single_combat.0001.desc.my_feedback.open_terrain_expert
								}
								triggered_desc = {
									trigger = {
										scope:sc_attacker_last_move = flag:rough_terrain_expert
										scope:sc_defender.location = { rocky_locale_trigger = yes }
									}
									desc = single_combat.0001.desc.my_feedback.rough_terrain_expert.rocky
								}
								triggered_desc = {
									trigger = {
										scope:sc_attacker_last_move = flag:rough_terrain_expert
										scope:sc_defender.location = { terrain = wetlands }
									}
									desc = single_combat.0001.desc.my_feedback.rough_terrain_expert.boggy
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:forest_fighter }
									desc = single_combat.0001.desc.my_feedback.forest_fighter
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:raaargh }
									desc = single_combat.0001.desc.my_feedback.raaargh
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:hard_grit }
									desc = single_combat.0001.desc.my_feedback.hard_grit
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:feint_and_stab }
									desc = single_combat.0001.desc.my_feedback.feint_and_stab
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:butchery }
									desc = single_combat.0001.desc.my_feedback.butchery
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:stoic_veteran }
									desc = single_combat.0001.desc.my_feedback.stoic_veteran
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:blade_dance }
									desc = single_combat.0001.desc.my_feedback.blade_dance
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:wrath_of_highgod }
									desc = single_combat.0001.desc.my_feedback.wrath_of_highgod
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:hurt_me_better }
									desc = single_combat.0001.desc.my_feedback.hurt_me_better
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:special_fallback }
									desc = single_combat.0001.desc.my_feedback.special_fallback
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:something_to_hide }
									desc = single_combat.0001.desc.my_feedback.something_to_hide
								}
							}
						}
					}
					# Scope:sc_defender responses.
					## What move did your opponent pick, and how does that play out from your POV?
					triggered_desc = {
						trigger = { exists = scope:sc_defender_last_move }
						desc = {
							first_valid = {
								triggered_desc = {
									trigger = { scope:sc_defender_last_move = flag:wait_and_hope }
									desc = single_combat.0001.desc.opponent_response.wait_and_hope
								}
								triggered_desc = {
									trigger = { scope:sc_defender_last_move = flag:unsure_attack }
									desc = single_combat.0001.desc.opponent_response.unsure_attack
								}
								triggered_desc = {
									trigger = {
										scope:sc_defender_last_move = flag:enthusiastic_onslaught
										scope:sc_defender = { house_not_allowed_to_yell_motto_trigger = yes }
									}
									desc = single_combat.0001.desc.opponent_response.enthusiastic_onslaught.banned_house
								}
								triggered_desc = {
									trigger = {
										scope:sc_defender_last_move = flag:enthusiastic_onslaught
										scope:sc_defender.house = scope:sc_attacker.house
									}
									desc = single_combat.0001.desc.opponent_response.enthusiastic_onslaught.own_house
								}
								triggered_desc = {
									trigger = {
										scope:sc_defender_last_move = flag:enthusiastic_onslaught
										#Otherwise, we can shout the motto.
									}
									desc = single_combat.0001.desc.opponent_response.enthusiastic_onslaught.motto
								}
								triggered_desc = {
									trigger = { scope:sc_defender_last_move = flag:hail_mary }
									desc = single_combat.0001.desc.opponent_response.hail_mary
								}
								triggered_desc = {
									trigger = { scope:sc_defender_last_move = flag:pocket_sand }
									desc = single_combat.0001.desc.opponent_response.pocket_sand
								}
								triggered_desc = {
									trigger = { scope:sc_defender_last_move = flag:nut_em }
									desc = single_combat.0001.desc.opponent_response.nut_em
								}
								triggered_desc = {
									trigger = { scope:sc_defender_last_move = flag:guard }
									desc = single_combat.0001.desc.opponent_response.guard
								}
								triggered_desc = {
									trigger = { scope:sc_defender_last_move = flag:probing_attack }
									desc = single_combat.0001.desc.opponent_response.probing_attack
								}
								triggered_desc = {
									trigger = { scope:sc_defender_last_move = flag:onslaught }
									desc = single_combat.0001.desc.opponent_response.onslaught
								}
								triggered_desc = {
									trigger = { scope:sc_defender_last_move = flag:surprise_attack }
									desc = single_combat.0001.desc.opponent_response.surprise_attack
								}
								triggered_desc = {
									trigger = { scope:sc_defender_last_move = flag:taunt }
									desc = single_combat.0001.desc.opponent_response.taunt
								}
								triggered_desc = {
									trigger = { scope:sc_defender_last_move = flag:put_the_boot_in }
									desc = single_combat.0001.desc.opponent_response.put_the_boot_in
								}
								triggered_desc = {
									trigger = { scope:sc_defender_last_move = flag:strict_guard }
									desc = single_combat.0001.desc.opponent_response.strict_guard
								}
								triggered_desc = {
									trigger = { scope:sc_defender_last_move = flag:confident_attack }
									desc = single_combat.0001.desc.opponent_response.confident_attack
								}
								triggered_desc = {
									trigger = { scope:sc_defender_last_move = flag:expert_onslaught }
									desc = single_combat.0001.desc.opponent_response.expert_onslaught
								}
								triggered_desc = {
									trigger = { scope:sc_defender_last_move = flag:attempt_disarm }
									desc = single_combat.0001.desc.opponent_response.attempt_disarm
								}
								triggered_desc = {
									trigger = { scope:sc_defender_last_move = flag:lightning_assault }
									desc = single_combat.0001.desc.opponent_response.lightning_assault
								}
								triggered_desc = {
									trigger = { scope:sc_defender_last_move = flag:tire_opponent }
									desc = single_combat.0001.desc.opponent_response.tire_opponent
								}
								triggered_desc = {
									trigger = { scope:sc_defender_last_move = flag:reason_you_suck_speech }
									desc = single_combat.0001.desc.opponent_response.reason_you_suck_speech
								}
								triggered_desc = {
									trigger = { scope:sc_defender_last_move = flag:technique_from_legend }
									desc = single_combat.0001.desc.opponent_response.technique_from_legend
								}
								triggered_desc = {
									trigger = { scope:sc_defender_last_move = flag:like_a_viper }
									desc = single_combat.0001.desc.opponent_response.like_a_viper
								}
								triggered_desc = {
									trigger = { scope:sc_defender_last_move = flag:pocket_silver }
									desc = single_combat.0001.desc.opponent_response.pocket_silver
								}
								triggered_desc = {
									trigger = { scope:sc_defender_last_move = flag:martial_voice }
									desc = single_combat.0001.desc.opponent_response.martial_voice
								}
								triggered_desc = {
									trigger = { scope:sc_defender_last_move = flag:mocking_boast }
									desc = single_combat.0001.desc.opponent_response.mocking_boast
								}
								triggered_desc = {
									trigger = { scope:sc_defender_last_move = flag:is_that_a_crocodile }
									desc = single_combat.0001.desc.opponent_response.is_that_a_crocodile
								}
								triggered_desc = {
									trigger = { scope:sc_defender_last_move = flag:desert_warrior }
									desc = single_combat.0001.desc.opponent_response.desert_warrior
								}
								triggered_desc = {
									trigger = { scope:sc_defender_last_move = flag:jungle_stalker }
									desc = single_combat.0001.desc.opponent_response.jungle_stalker
								}
								triggered_desc = {
									trigger = { scope:sc_defender_last_move = flag:open_terrain_expert }
									desc = single_combat.0001.desc.opponent_response.open_terrain_expert
								}
								triggered_desc = {
									trigger = {
										scope:sc_defender_last_move = flag:rough_terrain_expert
										scope:sc_defender.location = { rocky_locale_trigger = yes }
									}
									desc = single_combat.0001.desc.opponent_response.rough_terrain_expert.rocky
								}
								triggered_desc = {
									trigger = {
										scope:sc_defender_last_move = flag:rough_terrain_expert
										scope:sc_defender.location = { terrain = wetlands }
									}
									desc = single_combat.0001.desc.opponent_response.rough_terrain_expert.boggy
								}
								triggered_desc = {
									trigger = { scope:sc_defender_last_move = flag:forest_fighter }
									desc = single_combat.0001.desc.opponent_response.forest_fighter
								}
								triggered_desc = {
									trigger = { scope:sc_defender_last_move = flag:raaargh }
									desc = single_combat.0001.desc.opponent_response.raaargh
								}
								triggered_desc = {
									trigger = { scope:sc_defender_last_move = flag:hard_grit }
									desc = single_combat.0001.desc.opponent_response.hard_grit
								}
								triggered_desc = {
									trigger = { scope:sc_defender_last_move = flag:feint_and_stab }
									desc = single_combat.0001.desc.opponent_response.feint_and_stab
								}
								triggered_desc = {
									trigger = { scope:sc_defender_last_move = flag:butchery }
									desc = single_combat.0001.desc.opponent_response.butchery
								}
								triggered_desc = {
									trigger = { scope:sc_defender_last_move = flag:stoic_veteran }
									desc = single_combat.0001.desc.opponent_response.stoic_veteran
								}
								triggered_desc = {
									trigger = { scope:sc_defender_last_move = flag:blade_dance }
									desc = single_combat.0001.desc.opponent_response.blade_dance
								}
								triggered_desc = {
									trigger = { scope:sc_defender_last_move = flag:wrath_of_highgod }
									desc = single_combat.0001.desc.opponent_response.wrath_of_highgod
								}
								triggered_desc = {
									trigger = { scope:sc_defender_last_move = flag:hurt_me_better }
									desc = single_combat.0001.desc.opponent_response.hurt_me_better
								}
								triggered_desc = {
									trigger = { scope:sc_defender_last_move = flag:special_fallback }
									desc = single_combat.0001.desc.opponent_response.special_fallback
								}
								triggered_desc = {
									trigger = { scope:sc_defender_last_move = flag:something_to_hide }
									desc = single_combat.0001.desc.opponent_response.something_to_hide
								}
							}
						}
					}
					# Duel status updates.
					triggered_desc = {
						trigger = { scope:sc_defender.var:current_round > 1 }
						desc = {
							first_valid = {
								# Injury updates.
								## For scope:sc_attacker.
								### Injury chance very unlikely.
								triggered_desc = {
									trigger = { sc_attacker_injury_check_actual <= single_combat_injury_very_unlikely_value }
									desc = single_combat.0001.desc.injury_check.personal.very_unlikely
								}
								### Injury chance unlikely.
								triggered_desc = {
									trigger = { sc_attacker_injury_check_actual <= single_combat_injury_unlikely_value }
									desc = single_combat.0001.desc.injury_check.personal.unlikely
								}
								### Injury chance moderate.
								triggered_desc = {
									trigger = { sc_attacker_injury_check_actual <= single_combat_injury_neutral_value }
									desc = single_combat.0001.desc.injury_check.personal.moderate
								}
								### Injury chance likely.
								triggered_desc = {
									trigger = { sc_attacker_injury_check_actual <= single_combat_injury_likely_value }
									desc = single_combat.0001.desc.injury_check.personal.likely
								}
								### Injury chance very likely.
								desc = single_combat.0001.desc.injury_check.personal.very_likely
							}
							first_valid = {
								## For scope:sc_defender.
								### Injury chance very unlikely.
								triggered_desc = {
									trigger = { sc_defender_injury_check_actual <= single_combat_injury_very_unlikely_value }
									desc = single_combat.0001.desc.injury_check.opponent.very_unlikely
								}
								### Injury chance unlikely.
								triggered_desc = {
									trigger = { sc_defender_injury_check_actual <= single_combat_injury_unlikely_value }
									desc = single_combat.0001.desc.injury_check.opponent.unlikely
								}
								### Injury chance moderate.
								triggered_desc = {
									trigger = { sc_defender_injury_check_actual <= single_combat_injury_neutral_value }
									desc = single_combat.0001.desc.injury_check.opponent.moderate
								}
								### Injury chance likely.
								triggered_desc = {
									trigger = { sc_defender_injury_check_actual <= single_combat_injury_likely_value }
									desc = single_combat.0001.desc.injury_check.opponent.likely
								}
								### Injury chance very likely.
								desc = single_combat.0001.desc.injury_check.opponent.very_likely
							}
							first_valid = {
								# Success updates.
								## Victory almost impossible.
								triggered_desc = {
									trigger = { scope:sc_attacker.var:sc_attacker_success_check <= single_combat_success_almost_impossible_value }
									desc = single_combat.0001.desc.success_check.almost_impossible
								}
								## Victory very unlikely.
								triggered_desc = {
									trigger = { scope:sc_attacker.var:sc_attacker_success_check <= single_combat_success_very_unlikely_value }
									desc = single_combat.0001.desc.success_check.very_unlikely
								}
								## Victory unlikely.
								triggered_desc = {
									trigger = { scope:sc_attacker.var:sc_attacker_success_check <= single_combat_success_unlikely_value }
									desc = single_combat.0001.desc.success_check.unlikely
								}
								## Victory in the balance.
								triggered_desc = {
									trigger = { scope:sc_attacker.var:sc_attacker_success_check <= single_combat_success_likely_value }
									desc = single_combat.0001.desc.success_check.moderate
								}
								## Victory likely.
								triggered_desc = {
									trigger = { scope:sc_attacker.var:sc_attacker_success_check <= single_combat_success_very_likely_value }
									desc = single_combat.0001.desc.success_check.likely
								}
								## Victory very likely.
								triggered_desc = {
									trigger = { scope:sc_attacker.var:sc_attacker_success_check <= single_combat_success_almost_certain_value }
									desc = single_combat.0001.desc.success_check.very_likely
								}
								## Victory almost certain.
								desc = single_combat.0001.desc.success_check.almost_certain
							}
						}
					}
				}
			}
		}
	}
	theme = martial
	left_portrait = {
		character = scope:myself
		scripted_animation = duel_wield_weapon
	}
	right_portrait = {
		character = scope:my_foe
		scripted_animation = duel_wield_weapon
	}
	artifact = {
		target = scope:myself.var:signature_weapon_scope
		position = lower_left_portrait
		trigger = { exists = scope:myself.var:signature_weapon_scope }
	}

	artifact = {
		target = scope:my_foe.var:signature_weapon_scope
		position = lower_right_portrait
		trigger = { exists = scope:my_foe.var:signature_weapon_scope }
	}

	# Background Logic
	override_background = {
		trigger = { scope:locale = flag:terrain_scope }
		reference = terrain_scope
	}
	override_background = {
		trigger = { scope:locale = flag:battlefield }
		reference = battlefield
	}
	override_background = {
		trigger = { scope:locale = flag:alley_night }
		reference = alley_night
	}
	override_background = {
		trigger = { scope:locale = flag:alley_day }
		reference = alley_day
	}
	override_background = {
		trigger = { scope:locale = flag:temple }
		reference = temple
	}
	override_background = {
		trigger = { scope:locale = flag:corridor_night }
		reference = corridor_night
	}
	override_background = {
		trigger = { scope:locale = flag:corridor_day }
		reference = corridor_day
	}
	override_background = {
		trigger = { scope:locale = flag:courtyard }
		reference = courtyard
	}
	override_background = {
		trigger = { scope:locale = flag:dungeon }
		reference = dungeon
	}
	override_background = {
		trigger = { scope:locale = flag:docks }
		reference = docks
	}
	override_background = {
		trigger = { scope:locale = flag:feast }
		reference = feast
	}
	override_background = {
		trigger = { scope:locale = flag:market }
		reference = market
	}
	override_background = {
		trigger = { scope:locale = flag:tavern }
		reference = tavern
	}
	override_background = {
		trigger = { scope:locale = flag:throne_room }
		reference = throne_room
	}
	override_background = {
		trigger = { scope:locale = flag:army_camp }
		reference = army_camp
	}

	immediate = {
		play_music_cue = "mx_cue_combat_stinger"
		# Generate combat options.
		select_combat_options_from_pool_effect = yes
		# Set up portraits for this event, putting the current actor always on the left.
		if = {
			limit = { this = scope:sc_defender }
			scope:sc_defender = { save_scope_as = myself }
			scope:sc_attacker = { save_scope_as = my_foe }
		}
		else = {
			scope:sc_attacker = { save_scope_as = myself }
			scope:sc_defender = { save_scope_as = my_foe }
		}

		# Show opponent's move effect.
		if = {
			# Check that there's a last move kicking about to look at.
			limit = {
				OR = {
					exists = scope:sc_attacker_last_move
					exists = scope:sc_defender_last_move
				}
			}
			if = {
				limit = {
					OR = {
						AND = {
							this = scope:sc_defender
							scope:sc_attacker_last_move = flag:wait_and_hope
						}
						AND = {
							this = scope:sc_attacker
							scope:sc_defender_last_move = flag:wait_and_hope
						}
					}
				}
				scope:my_foe = {
					show_as_tooltip = { combat_move_wait_and_hope_effect = yes }
				}
			}
			if = {
				limit = {
					OR = {
						AND = {
							this = scope:sc_defender
							scope:sc_attacker_last_move = flag:unsure_attack
						}
						AND = {
							this = scope:sc_attacker
							scope:sc_defender_last_move = flag:unsure_attack
						}
					}
				}
				scope:my_foe = {
					show_as_tooltip = { combat_move_unsure_attack_effect = yes }
				}
			}
			if = {
				limit = {
					OR = {
						AND = {
							this = scope:sc_defender
							scope:sc_attacker_last_move = flag:enthusiastic_onslaught
						}
						AND = {
							this = scope:sc_attacker
							scope:sc_defender_last_move = flag:enthusiastic_onslaught
						}
					}
				}
				scope:my_foe = {
					show_as_tooltip = { combat_move_enthusiastic_onslaught_effect = yes }
				}
			}
			if = {
				limit = {
					OR = {
						AND = {
							this = scope:sc_defender
							scope:sc_attacker_last_move = flag:hail_mary
						}
						AND = {
							this = scope:sc_attacker
							scope:sc_defender_last_move = flag:hail_mary
						}
					}
				}
				scope:my_foe = {
					show_as_tooltip = { combat_move_hail_mary_effect = yes }
				}
			}
			if = {
				limit = {
					OR = {
						AND = {
							this = scope:sc_defender
							scope:sc_attacker_last_move = flag:pocket_sand
						}
						AND = {
							this = scope:sc_attacker
							scope:sc_defender_last_move = flag:pocket_sand
						}
					}
				}
				scope:my_foe = {
					show_as_tooltip = { combat_move_pocket_sand_effect = yes }
				}
			}
			if = {
				limit = {
					OR = {
						AND = {
							this = scope:sc_defender
							scope:sc_attacker_last_move = flag:nut_em
						}
						AND = {
							this = scope:sc_attacker
							scope:sc_defender_last_move = flag:nut_em
						}
					}
				}
				scope:my_foe = {
					show_as_tooltip = { combat_move_nut_em_effect = yes }
				}
			}
			if = {
				limit = {
					OR = {
						AND = {
							this = scope:sc_defender
							scope:sc_attacker_last_move = flag:guard
						}
						AND = {
							this = scope:sc_attacker
							scope:sc_defender_last_move = flag:guard
						}
					}
				}
				scope:my_foe = {
					show_as_tooltip = { combat_move_guard_effect = yes }
				}
			}
			if = {
				limit = {
					OR = {
						AND = {
							this = scope:sc_defender
							scope:sc_attacker_last_move = flag:probing_attack
						}
						AND = {
							this = scope:sc_attacker
							scope:sc_defender_last_move = flag:probing_attack
						}
					}
				}
				scope:my_foe = {
					show_as_tooltip = { combat_move_probing_attack_effect = yes }
				}
			}
			if = {
				limit = {
					OR = {
						AND = {
							this = scope:sc_defender
							scope:sc_attacker_last_move = flag:onslaught
						}
						AND = {
							this = scope:sc_attacker
							scope:sc_defender_last_move = flag:onslaught
						}
					}
				}
				scope:my_foe = {
					show_as_tooltip = { combat_move_onslaught_effect = yes }
				}
			}
			if = {
				limit = {
					OR = {
						AND = {
							this = scope:sc_defender
							scope:sc_attacker_last_move = flag:surprise_attack
						}
						AND = {
							this = scope:sc_attacker
							scope:sc_defender_last_move = flag:surprise_attack
						}
					}
				}
				scope:my_foe = {
					show_as_tooltip = { combat_move_surprise_attack_effect = yes }
				}
			}
			if = {
				limit = {
					OR = {
						AND = {
							this = scope:sc_defender
							scope:sc_attacker_last_move = flag:taunt
						}
						AND = {
							this = scope:sc_attacker
							scope:sc_defender_last_move = flag:taunt
						}
					}
				}
				scope:my_foe = {
					show_as_tooltip = { combat_move_taunt_effect = yes }
				}
			}
			if = {
				limit = {
					OR = {
						AND = {
							this = scope:sc_defender
							scope:sc_attacker_last_move = flag:put_the_boot_in
						}
						AND = {
							this = scope:sc_attacker
							scope:sc_defender_last_move = flag:put_the_boot_in
						}
					}
				}
				scope:my_foe = {
					show_as_tooltip = { combat_move_put_the_boot_in_effect = yes }
				}
			}
			if = {
				limit = {
					OR = {
						AND = {
							this = scope:sc_defender
							scope:sc_attacker_last_move = flag:strict_guard
						}
						AND = {
							this = scope:sc_attacker
							scope:sc_defender_last_move = flag:strict_guard
						}
					}
				}
				scope:my_foe = {
					show_as_tooltip = { combat_move_strict_guard_effect = yes }
				}
			}
			if = {
				limit = {
					OR = {
						AND = {
							this = scope:sc_defender
							scope:sc_attacker_last_move = flag:confident_attack
						}
						AND = {
							this = scope:sc_attacker
							scope:sc_defender_last_move = flag:confident_attack
						}
					}
				}
				scope:my_foe = {
					show_as_tooltip = { combat_move_confident_attack_effect = yes }
				}
			}
			if = {
				limit = {
					OR = {
						AND = {
							this = scope:sc_defender
							scope:sc_attacker_last_move = flag:expert_onslaught
						}
						AND = {
							this = scope:sc_attacker
							scope:sc_defender_last_move = flag:expert_onslaught
						}
					}
				}
				scope:my_foe = {
					show_as_tooltip = { combat_move_expert_onslaught_effect = yes }
				}
			}
			if = {
				limit = {
					OR = {
						AND = {
							this = scope:sc_defender
							scope:sc_attacker_last_move = flag:attempt_disarm
						}
						AND = {
							this = scope:sc_attacker
							scope:sc_defender_last_move = flag:attempt_disarm
						}
					}
				}
				scope:my_foe = {
					show_as_tooltip = { combat_move_attempt_disarm_effect = yes }
				}
			}
			if = {
				limit = {
					OR = {
						AND = {
							this = scope:sc_defender
							scope:sc_attacker_last_move = flag:lightning_assault
						}
						AND = {
							this = scope:sc_attacker
							scope:sc_defender_last_move = flag:lightning_assault
						}
					}
				}
				scope:my_foe = {
					show_as_tooltip = { combat_move_lightning_assault_effect = yes }
				}
			}
			if = {
				limit = {
					OR = {
						AND = {
							this = scope:sc_defender
							scope:sc_attacker_last_move = flag:tire_opponent
						}
						AND = {
							this = scope:sc_attacker
							scope:sc_defender_last_move = flag:tire_opponent
						}
					}
				}
				scope:my_foe = {
					show_as_tooltip = { combat_move_tire_opponent_effect = yes }
				}
			}
			if = {
				limit = {
					OR = {
						AND = {
							this = scope:sc_defender
							scope:sc_attacker_last_move = flag:reason_you_suck_speech
						}
						AND = {
							this = scope:sc_attacker
							scope:sc_defender_last_move = flag:reason_you_suck_speech
						}
					}
				}
				scope:my_foe = {
					show_as_tooltip = { combat_move_reason_you_suck_speech_effect = yes }
				}
			}
			if = {
				limit = {
					OR = {
						AND = {
							this = scope:sc_defender
							scope:sc_attacker_last_move = flag:technique_from_legend
						}
						AND = {
							this = scope:sc_attacker
							scope:sc_defender_last_move = flag:technique_from_legend
						}
					}
				}
				scope:my_foe = {
					show_as_tooltip = { combat_move_technique_from_legend_effect = yes }
				}
			}
			if = {
				limit = {
					OR = {
						AND = {
							this = scope:sc_defender
							scope:sc_attacker_last_move = flag:like_a_viper
						}
						AND = {
							this = scope:sc_attacker
							scope:sc_defender_last_move = flag:like_a_viper
						}
					}
				}
				scope:my_foe = {
					show_as_tooltip = { combat_move_like_a_viper_effect = yes }
				}
			}
			if = {
				limit = {
					OR = {
						AND = {
							this = scope:sc_defender
							scope:sc_attacker_last_move = flag:pocket_silver
						}
						AND = {
							this = scope:sc_attacker
							scope:sc_defender_last_move = flag:pocket_silver
						}
					}
				}
				scope:my_foe = {
					show_as_tooltip = { combat_move_pocket_silver_effect = yes }
				}
			}
			if = {
				limit = {
					OR = {
						AND = {
							this = scope:sc_defender
							scope:sc_attacker_last_move = flag:martial_voice
						}
						AND = {
							this = scope:sc_attacker
							scope:sc_defender_last_move = flag:martial_voice
						}
					}
				}
				scope:my_foe = {
					show_as_tooltip = { combat_move_martial_voice_effect = yes }
				}
			}
			if = {
				limit = {
					OR = {
						AND = {
							this = scope:sc_defender
							scope:sc_attacker_last_move = flag:mocking_boast
						}
						AND = {
							this = scope:sc_attacker
							scope:sc_defender_last_move = flag:mocking_boast
						}
					}
				}
				scope:my_foe = {
					show_as_tooltip = { combat_move_mocking_boast_effect = yes }
				}
			}
			if = {
				limit = {
					OR = {
						AND = {
							this = scope:sc_defender
							scope:sc_attacker_last_move = flag:is_that_a_crocodile
						}
						AND = {
							this = scope:sc_attacker
							scope:sc_defender_last_move = flag:is_that_a_crocodile
						}
					}
				}
				scope:my_foe = {
					show_as_tooltip = { combat_move_is_that_a_crocodile_effect = yes }
				}
			}
			if = {
				limit = {
					OR = {
						AND = {
							this = scope:sc_defender
							scope:sc_attacker_last_move = flag:desert_warrior
						}
						AND = {
							this = scope:sc_attacker
							scope:sc_defender_last_move = flag:desert_warrior
						}
					}
				}
				scope:my_foe = {
					show_as_tooltip = { combat_move_desert_warrior_effect = yes }
				}
			}
			if = {
				limit = {
					OR = {
						AND = {
							this = scope:sc_defender
							scope:sc_attacker_last_move = flag:jungle_stalker
						}
						AND = {
							this = scope:sc_attacker
							scope:sc_defender_last_move = flag:jungle_stalker
						}
					}
				}
				scope:my_foe = {
					show_as_tooltip = { combat_move_jungle_stalker_effect = yes }
				}
			}
			if = {
				limit = {
					OR = {
						AND = {
							this = scope:sc_defender
							scope:sc_attacker_last_move = flag:open_terrain_expert
						}
						AND = {
							this = scope:sc_attacker
							scope:sc_defender_last_move = flag:open_terrain_expert
						}
					}
				}
				scope:my_foe = {
					show_as_tooltip = { combat_move_open_terrain_expert_effect = yes }
				}
			}
			if = {
				limit = {
					OR = {
						AND = {
							this = scope:sc_defender
							scope:sc_attacker_last_move = flag:rough_terrain_expert
						}
						AND = {
							this = scope:sc_attacker
							scope:sc_defender_last_move = flag:rough_terrain_expert
						}
					}
				}
				scope:my_foe = {
					show_as_tooltip = { combat_move_rough_terrain_expert_effect = yes }
				}
			}
			if = {
				limit = {
					OR = {
						AND = {
							this = scope:sc_defender
							scope:sc_attacker_last_move = flag:forest_fighter
						}
						AND = {
							this = scope:sc_attacker
							scope:sc_defender_last_move = flag:forest_fighter
						}
					}
				}
				scope:my_foe = {
					show_as_tooltip = { combat_move_forest_fighter_effect = yes }
				}
			}
			if = {
				limit = {
					OR = {
						AND = {
							this = scope:sc_defender
							scope:sc_attacker_last_move = flag:raaargh
						}
						AND = {
							this = scope:sc_attacker
							scope:sc_defender_last_move = flag:raaargh
						}
					}
				}
				scope:my_foe = {
					show_as_tooltip = { combat_move_raaargh_effect = yes }
				}
			}
			if = {
				limit = {
					OR = {
						AND = {
							this = scope:sc_defender
							scope:sc_attacker_last_move = flag:hard_grit
						}
						AND = {
							this = scope:sc_attacker
							scope:sc_defender_last_move = flag:hard_grit
						}
					}
				}
				scope:my_foe = {
					show_as_tooltip = { combat_move_hard_grit_effect = yes }
				}
			}
			if = {
				limit = {
					OR = {
						AND = {
							this = scope:sc_defender
							scope:sc_attacker_last_move = flag:feint_and_stab
						}
						AND = {
							this = scope:sc_attacker
							scope:sc_defender_last_move = flag:feint_and_stab
						}
					}
				}
				scope:my_foe = {
					show_as_tooltip = { combat_move_feint_and_stab_effect = yes }
				}
			}
			if = {
				limit = {
					OR = {
						AND = {
							this = scope:sc_defender
							scope:sc_attacker_last_move = flag:butchery
						}
						AND = {
							this = scope:sc_attacker
							scope:sc_defender_last_move = flag:butchery
						}
					}
				}
				scope:my_foe = {
					show_as_tooltip = { combat_move_butchery_effect = yes }
				}
			}
			if = {
				limit = {
					OR = {
						AND = {
							this = scope:sc_defender
							scope:sc_attacker_last_move = flag:stoic_veteran
						}
						AND = {
							this = scope:sc_attacker
							scope:sc_defender_last_move = flag:stoic_veteran
						}
					}
				}
				scope:my_foe = {
					show_as_tooltip = { combat_move_stoic_veteran_effect = yes }
				}
			}
			if = {
				limit = {
					OR = {
						AND = {
							this = scope:sc_defender
							scope:sc_attacker_last_move = flag:blade_dance
						}
						AND = {
							this = scope:sc_attacker
							scope:sc_defender_last_move = flag:blade_dance
						}
					}
				}
				scope:my_foe = {
					show_as_tooltip = { combat_move_blade_dance_effect = yes }
				}
			}
			if = {
				limit = {
					OR = {
						AND = {
							this = scope:sc_defender
							scope:sc_attacker_last_move = flag:wrath_of_highgod
						}
						AND = {
							this = scope:sc_attacker
							scope:sc_defender_last_move = flag:wrath_of_highgod
						}
					}
				}
				scope:my_foe = {
					show_as_tooltip = { combat_move_wrath_of_highgod_effect = yes }
				}
			}
			if = {
				limit = {
					OR = {
						AND = {
							this = scope:sc_defender
							scope:sc_attacker_last_move = flag:hurt_me_better
						}
						AND = {
							this = scope:sc_attacker
							scope:sc_defender_last_move = flag:hurt_me_better
						}
					}
				}
				scope:my_foe = {
					show_as_tooltip = { combat_move_hurt_me_better_effect = yes }
				}
			}
			if = {
				limit = {
					OR = {
						AND = {
							this = scope:sc_defender
							scope:sc_attacker_last_move = flag:special_fallback
						}
						AND = {
							this = scope:sc_attacker
							scope:sc_defender_last_move = flag:special_fallback
						}
					}
				}
				scope:my_foe = {
					show_as_tooltip = { combat_move_special_fallback_effect = yes }
				}
			}
			if = {
				limit = {
					OR = {
						AND = {
							this = scope:sc_defender
							scope:sc_attacker_last_move = flag:something_to_hide
						}
						AND = {
							this = scope:sc_attacker
							scope:sc_defender_last_move = flag:something_to_hide
						}
					}
				}
				scope:my_foe = {
					show_as_tooltip = { combat_move_something_to_hide_effect = yes }
				}
			}
		}
	}

	# Stress_impact in the options is deliberately left out of the ai_chance weightings. It's not a huge amount for anyone (typically miniscule for standard moves, minor for special ones), since many of these options can repeat within one combat, and it's no bad thing to have characters come out of duels increasingly stressed.

	#Wait and Hope
	option = {
		name = single_combat.0001.wait_and_hope
		trigger = { exists = local_var:combat_move_wait_and_hope_flag }

		#Move clarification
		custom_tooltip = single_combat.0001.tt.wait_and_hope

		#Move effects
		## First, we show the move's effects with no guff.
		show_as_tooltip = { combat_move_wait_and_hope_effect = yes }
		## Then, we check to make sure if scope:my_foe is still around to suffer the effects. This prevents errors if they die mid-combat.
		if = {
			limit = {
				scope:my_foe = { is_alive = yes }
			}
			hidden_effect = { combat_move_wait_and_hope_effect = yes }
		}

		stress_impact = {
			patient = miniscule_stress_impact_loss
			calm = miniscule_stress_impact_loss
			impatient = miniscule_stress_impact_gain
			wrathful = miniscule_stress_impact_gain
		}
		ai_chance = {
			base = 100
			sce_timid_personality_scripted_modifier = yes
		}
	}

	#Unsure Attack
	option = {
		name = {
			trigger = { scope:fatality = flag:yes }
			text = single_combat.0001.unsure_attack
		}
		name = {
			trigger = { scope:fatality = flag:no }
			text = single_combat.0001.unsure_attack_non_fatal
		}
		trigger = { exists = local_var:combat_move_unsure_attack_flag }

		#Move clarification
		custom_tooltip = single_combat.0001.tt.unsure_attack

		#Move effects
		## First, we show the move's effects with no guff.
		show_as_tooltip = { combat_move_unsure_attack_effect = yes }
		## Then, we check to make sure if scope:my_foe is still around to suffer the effects. This prevents errors if they die mid-combat.
		if = {
			limit = {
				scope:my_foe = { is_alive = yes }
			}
			hidden_effect = { combat_move_unsure_attack_effect = yes }
		}

		# No stress for middle-ground standard options.
		ai_chance = {
			base = 100
			sce_rational_personality_scripted_modifier = yes
		}
	}

	#Enthusiastic Onslaught
	option = {
		# Since we yell the house motto here, we need slight separation between variants.
		## Firstly, if your house is on the banned list, you use a fallback.
		name = {
			trigger = { house_not_allowed_to_yell_motto_trigger = yes }
			text = single_combat.0001.enthusiastic_onslaught.banned_house
		}
		## Secondly, if you're fighting another member of your own house, you use a different fallback.
		name = {
			trigger = {
				house_not_allowed_to_yell_motto_trigger = no
				scope:sc_attacker.house = scope:sc_defender.house
			}
			text = single_combat.0001.enthusiastic_onslaught.own_house
		}
		## Thirdly, if you're a shouty house who isn't fighting another person from your shouty house, then you use your motto.
		name = {
			trigger = {
				house_not_allowed_to_yell_motto_trigger = no
				NOT = { scope:sc_attacker.house = scope:sc_defender.house }
			}
			text = single_combat.0001.enthusiastic_onslaught.motto
		}
		trigger = { exists = local_var:combat_move_enthusiastic_onslaught_flag }

		#Move clarification
		custom_tooltip = single_combat.0001.tt.enthusiastic_onslaught

		#Move effects
		## First, we show the move's effects with no guff.
		show_as_tooltip = { combat_move_enthusiastic_onslaught_effect = yes }
		## Then, we check to make sure if scope:my_foe is still around to suffer the effects. This prevents errors if they die mid-combat.
		if = {
			limit = {
				scope:my_foe = { is_alive = yes }
			}
			hidden_effect = { combat_move_enthusiastic_onslaught_effect = yes }
		}

		stress_impact = {
			impatient = miniscule_stress_impact_loss
			wrathful = miniscule_stress_impact_loss
			patient = miniscule_stress_impact_gain
			calm = miniscule_stress_impact_gain
		}
		ai_chance = {
			base = 100
			sce_aggressive_personality_scripted_modifier = yes
		}
	}

	#Hail Mary
	option = {
		name = single_combat.0001.hail_mary
		trigger = { exists = local_var:combat_move_hail_mary_flag }

		#Move clarification
		custom_tooltip = single_combat.0001.tt.hail_mary

		#Move effects
		## First, we show the move's effects with no guff.
		show_as_tooltip = { combat_move_hail_mary_effect = yes }
		## Then, we check to make sure if scope:my_foe is still around to suffer the effects. This prevents errors if they die mid-combat.
		if = {
			limit = {
				scope:my_foe = { is_alive = yes }
			}
			hidden_effect = { combat_move_hail_mary_effect = yes }
		}

		stress_impact = {
			impatient = miniscule_stress_impact_loss
			brave = minor_stress_impact_loss
			patient = miniscule_stress_impact_gain
			craven = minor_stress_impact_gain
		}
		ai_chance = {
			base = 100
			sce_preferred_aggressive_personality_scripted_modifier = yes
		}
	}

	#Pocket Sand
	option = {
		name = single_combat.0001.pocket_sand
		trigger = { exists = local_var:combat_move_pocket_sand_flag }

		#Move clarification
		custom_tooltip = single_combat.0001.tt.pocket_sand

		#Move effects
		## First, we show the move's effects with no guff.
		show_as_tooltip = { combat_move_pocket_sand_effect = yes }
		## Then, we check to make sure if scope:my_foe is still around to suffer the effects. This prevents errors if they die mid-combat.
		if = {
			limit = {
				scope:my_foe = { is_alive = yes }
			}
			hidden_effect = { combat_move_pocket_sand_effect = yes }
		}

		stress_impact = {
			deceitful = miniscule_stress_impact_loss
			arbitrary = miniscule_stress_impact_loss
			honest = miniscule_stress_impact_gain
			just = miniscule_stress_impact_gain
		}
		ai_chance = {
			base = 100
			sce_preferred_timid_personality_scripted_modifier = yes
		}
	}

	#Nut 'em
	option = {
		name = single_combat.0001.nut_em
		trigger = { exists = local_var:combat_move_nut_em_flag }

		#Move clarification
		custom_tooltip = single_combat.0001.tt.nut_em

		#Move effects
		## First, we show the move's effects with no guff.
		show_as_tooltip = { combat_move_nut_em_effect = yes }
		## Then, we check to make sure if scope:my_foe is still around to suffer the effects. This prevents errors if they die mid-combat.
		if = {
			limit = {
				scope:my_foe = { is_alive = yes }
			}
			hidden_effect = { combat_move_nut_em_effect = yes }
		}

		stress_impact = {
			deceitful = miniscule_stress_impact_loss
			arbitrary = miniscule_stress_impact_loss
			honest = miniscule_stress_impact_gain
			just = miniscule_stress_impact_gain
		}
		ai_chance = {
			base = 100
			sce_preferred_aggressive_personality_scripted_modifier = yes
		}
	}

	#Guard
	option = {
		name = single_combat.0001.guard
		trigger = { exists = local_var:combat_move_guard_flag }

		#Move clarification
		custom_tooltip = single_combat.0001.tt.guard

		#Move effects
		## First, we show the move's effects with no guff.
		show_as_tooltip = { combat_move_guard_effect = yes }
		## Then, we check to make sure if scope:my_foe is still around to suffer the effects. This prevents errors if they die mid-combat.
		if = {
			limit = {
				scope:my_foe = { is_alive = yes }
			}
			hidden_effect = { combat_move_guard_effect = yes }
		}

		stress_impact = {
			patient = miniscule_stress_impact_loss
			calm = miniscule_stress_impact_loss
			impatient = miniscule_stress_impact_gain
			wrathful = miniscule_stress_impact_gain
		}
		ai_chance = {
			base = 100
			sce_timid_personality_scripted_modifier = yes
		}
	}

	#Probing Attack
	option = {
		name = single_combat.0001.probing_attack
		trigger = { exists = local_var:combat_move_probing_attack_flag }

		#Move clarification
		custom_tooltip = single_combat.0001.tt.probing_attack

		#Move effects
		## First, we show the move's effects with no guff.
		show_as_tooltip = { combat_move_probing_attack_effect = yes }
		## Then, we check to make sure if scope:my_foe is still around to suffer the effects. This prevents errors if they die mid-combat.
		if = {
			limit = {
				scope:my_foe = { is_alive = yes }
			}
			hidden_effect = { combat_move_probing_attack_effect = yes }
		}

		# No stress for middle-ground standard options.
		ai_chance = {
			base = 100
			sce_rational_personality_scripted_modifier = yes
		}
	}

	#Onslaught
	option = {
		name = single_combat.0001.onslaught
		trigger = { exists = local_var:combat_move_onslaught_flag }

		#Move clarification
		custom_tooltip = single_combat.0001.tt.onslaught

		#Move effects
		## First, we show the move's effects with no guff.
		show_as_tooltip = { combat_move_onslaught_effect = yes }
		## Then, we check to make sure if scope:my_foe is still around to suffer the effects. This prevents errors if they die mid-combat.
		if = {
			limit = {
				scope:my_foe = { is_alive = yes }
			}
			hidden_effect = { combat_move_onslaught_effect = yes }
		}

		stress_impact = {
			impatient = miniscule_stress_impact_loss
			wrathful = miniscule_stress_impact_loss
			patient = miniscule_stress_impact_gain
			calm = miniscule_stress_impact_gain
		}
		ai_chance = {
			base = 100
			sce_aggressive_personality_scripted_modifier = yes
		}
	}

	#Surprise Attack
	option = {
		name = single_combat.0001.surprise_attack
		trigger = { exists = local_var:combat_move_surprise_attack_flag }

		#Move clarification
		custom_tooltip = single_combat.0001.tt.surprise_attack

		#Move effects
		## First, we show the move's effects with no guff.
		show_as_tooltip = { combat_move_surprise_attack_effect = yes }
		## Then, we check to make sure if scope:my_foe is still around to suffer the effects. This prevents errors if they die mid-combat.
		if = {
			limit = {
				scope:my_foe = { is_alive = yes }
			}
			hidden_effect = { combat_move_surprise_attack_effect = yes }
		}

		# No need for stress weighting here; fairly standard tactic that anyone would try.
		ai_chance = {
			base = 100
			sce_preferred_rational_personality_scripted_modifier = yes
		}
	}

	#Taunt
	option = {
		name = single_combat.0001.taunt
		trigger = { exists = local_var:combat_move_taunt_flag }

		#Move clarification
		custom_tooltip = single_combat.0001.tt.taunt

		#Move effects
		## First, we show the move's effects with no guff.
		show_as_tooltip = { combat_move_taunt_effect = yes }
		## Then, we check to make sure if scope:my_foe is still around to suffer the effects. This prevents errors if they die mid-combat.
		if = {
			limit = {
				scope:my_foe = { is_alive = yes }
			}
			hidden_effect = { combat_move_taunt_effect = yes }
		}

		stress_impact = {
			callous = miniscule_stress_impact_loss
			sadistic = miniscule_stress_impact_loss
			compassionate = miniscule_stress_impact_gain
		}
		ai_chance = {
			base = 100
			sce_preferred_timid_personality_scripted_modifier = yes
		}
	}

	#Put the Boot In
	option = {
		name = single_combat.0001.put_the_boot_in
		trigger = { exists = local_var:combat_move_put_the_boot_in_flag }

		#Move clarification
		custom_tooltip = single_combat.0001.tt.put_the_boot_in

		#Move effects
		## First, we show the move's effects with no guff.
		show_as_tooltip = { combat_move_put_the_boot_in_effect = yes }
		## Then, we check to make sure if scope:my_foe is still around to suffer the effects. This prevents errors if they die mid-combat.
		if = {
			limit = {
				scope:my_foe = { is_alive = yes }
			}
			hidden_effect = { combat_move_put_the_boot_in_effect = yes }
		}

		stress_impact = {
			impatient = miniscule_stress_impact_loss
			brave = minor_stress_impact_loss
			patient = miniscule_stress_impact_gain
			craven = minor_stress_impact_gain
		}
		ai_chance = {
			base = 100
			sce_preferred_aggressive_personality_scripted_modifier = yes
		}
	}

	#Strict Guard
	option = {
		name = single_combat.0001.strict_guard
		trigger = { exists = local_var:combat_move_strict_guard_flag }

		#Move clarification
		custom_tooltip = single_combat.0001.tt.strict_guard

		#Move effects
		## First, we show the move's effects with no guff.
		show_as_tooltip = { combat_move_strict_guard_effect = yes }
		## Then, we check to make sure if scope:my_foe is still around to suffer the effects. This prevents errors if they die mid-combat.
		if = {
			limit = {
				scope:my_foe = { is_alive = yes }
			}
			hidden_effect = { combat_move_strict_guard_effect = yes }
		}

		stress_impact = {
			patient = miniscule_stress_impact_loss
			calm = miniscule_stress_impact_loss
			impatient = miniscule_stress_impact_gain
			wrathful = miniscule_stress_impact_gain
		}
		ai_chance = {
			base = 100
			sce_timid_personality_scripted_modifier = yes
		}
	}

	#Confident Attack
	option = {
		name = single_combat.0001.confident_attack
		trigger = { exists = local_var:combat_move_confident_attack_flag }

		#Move clarification
		custom_tooltip = single_combat.0001.tt.confident_attack

		#Move effects
		## First, we show the move's effects with no guff.
		show_as_tooltip = { combat_move_confident_attack_effect = yes }
		## Then, we check to make sure if scope:my_foe is still around to suffer the effects. This prevents errors if they die mid-combat.
		if = {
			limit = {
				scope:my_foe = { is_alive = yes }
			}
			hidden_effect = { combat_move_confident_attack_effect = yes }
		}

		# No stress for middle-ground standard options.
		ai_chance = {
			base = 100
			sce_rational_personality_scripted_modifier = yes
		}
	}

	#Expert Onslaught
	option = {
		name = single_combat.0001.expert_onslaught
		trigger = { exists = local_var:combat_move_expert_onslaught_flag }

		#Move clarification
		custom_tooltip = single_combat.0001.tt.expert_onslaught

		#Move effects
		## First, we show the move's effects with no guff.
		show_as_tooltip = { combat_move_expert_onslaught_effect = yes }
		## Then, we check to make sure if scope:my_foe is still around to suffer the effects. This prevents errors if they die mid-combat.
		if = {
			limit = {
				scope:my_foe = { is_alive = yes }
			}
			hidden_effect = { combat_move_expert_onslaught_effect = yes }
		}

		stress_impact = {
			impatient = miniscule_stress_impact_loss
			wrathful = miniscule_stress_impact_loss
			patient = miniscule_stress_impact_gain
			calm = miniscule_stress_impact_gain
		}
		ai_chance = {
			base = 100
			sce_aggressive_personality_scripted_modifier = yes
		}
	}

	#Attempt Disarm
	option = {
		name = single_combat.0001.attempt_disarm
		trigger = { exists = local_var:combat_move_attempt_disarm_flag }

		#Move clarification
		custom_tooltip = single_combat.0001.tt.attempt_disarm

		#Move effects
		## First, we show the move's effects with no guff.
		show_as_tooltip = { combat_move_attempt_disarm_effect = yes }
		## Then, we check to make sure if scope:my_foe is still around to suffer the effects. This prevents errors if they die mid-combat.
		if = {
			limit = {
				scope:my_foe = { is_alive = yes }
			}
			hidden_effect = { combat_move_attempt_disarm_effect = yes }
		}

		stress_impact = {
			patient = miniscule_stress_impact_loss
			calm = miniscule_stress_impact_loss
			impatient = miniscule_stress_impact_gain
			wrathful = miniscule_stress_impact_gain
		}
		ai_chance = {
			base = 100
			sce_preferred_timid_personality_scripted_modifier = yes
		}
	}

	#Lightning Assault
	option = {
		name = single_combat.0001.lightning_assault
		trigger = { exists = local_var:combat_move_lightning_assault_flag }

		#Move clarification
		custom_tooltip = single_combat.0001.tt.lightning_assault

		#Move effects
		## First, we show the move's effects with no guff.
		show_as_tooltip = { combat_move_lightning_assault_effect = yes }
		## Then, we check to make sure if scope:my_foe is still around to suffer the effects. This prevents errors if they die mid-combat.
		if = {
			limit = {
				scope:my_foe = { is_alive = yes }
			}
			hidden_effect = { combat_move_lightning_assault_effect = yes }
		}

		stress_impact = {
			impatient = miniscule_stress_impact_loss
			diligent = miniscule_stress_impact_loss
			patient = miniscule_stress_impact_gain
			lazy = miniscule_stress_impact_gain
		}
		ai_chance = {
			base = 100
			sce_preferred_aggressive_personality_scripted_modifier = yes
		}
	}

	#Tire Opponent
	option = {
		name = single_combat.0001.tire_opponent
		trigger = { exists = local_var:combat_move_tire_opponent_flag }

		#Move clarification
		custom_tooltip = single_combat.0001.tt.tire_opponent

		#Move effects
		## First, we show the move's effects with no guff.
		show_as_tooltip = { combat_move_tire_opponent_effect = yes }
		## Then, we check to make sure if scope:my_foe is still around to suffer the effects. This prevents errors if they die mid-combat.
		if = {
			limit = {
				scope:my_foe = { is_alive = yes }
			}
			hidden_effect = { combat_move_tire_opponent_effect = yes }
		}

		stress_impact = {
			diligent = miniscule_stress_impact_loss
			calm = miniscule_stress_impact_loss
			lazy = miniscule_stress_impact_gain
			wrathful = miniscule_stress_impact_gain
		}
		ai_chance = {
			base = 100
			sce_preferred_rational_personality_scripted_modifier = yes
		}
	}

	#Reason You Suck Speech
	option = {
		name = single_combat.0001.reason_you_suck_speech
		trigger = { exists = local_var:combat_move_reason_you_suck_speech_flag }

		#Move clarification
		custom_tooltip = single_combat.0001.tt.reason_you_suck_speech

		#Spawn Info
		skill = diplomacy

		#Move effects
		## First, we show the move's effects with no guff.
		show_as_tooltip = { combat_move_reason_you_suck_speech_effect = yes }
		## Then, we check to make sure if scope:my_foe is still around to suffer the effects. This prevents errors if they die mid-combat.
		if = {
			limit = {
				scope:my_foe = { is_alive = yes }
			}
			hidden_effect = { combat_move_reason_you_suck_speech_effect = yes }
		}

		stress_impact = {
			callous = miniscule_stress_impact_loss
			sadistic = miniscule_stress_impact_loss
			gregarious = miniscule_stress_impact_loss
			compassionate = miniscule_stress_impact_gain
			shy = miniscule_stress_impact_gain
		}
		ai_chance = {
			base = 100
			sce_enjoys_arrogant_speeches_scripted_modifier = yes
		}
	}

	#Technique from Legend
	option = {
		name = single_combat.0001.technique_from_legend
		trigger = { exists = local_var:combat_move_technique_from_legend_flag }

		#Move clarification
		custom_tooltip = single_combat.0001.tt.technique_from_legend

		#Spawn Info
		skill = learning

		#Move effects
		## First, we show the move's effects with no guff.
		show_as_tooltip = { combat_move_technique_from_legend_effect = yes }
		## Then, we check to make sure if scope:my_foe is still around to suffer the effects. This prevents errors if they die mid-combat.
		if = {
			limit = {
				scope:my_foe = { is_alive = yes }
			}
			hidden_effect = { combat_move_technique_from_legend_effect = yes }
		}

		stress_impact = {
			brave = minor_stress_impact_loss
			trusting = minor_stress_impact_loss	# A trusting character *totally* believes the legends are both true and accurate!
			craven = minor_stress_impact_gain
			paranoid = minor_stress_impact_gain # Whereas a paranoid character is 99% sure they're bullshit, but is hoping against hope anyway.
		}
		ai_chance = {
			base = 100
			sce_shrewd_fighter_scripted_modifier = yes
			# Weight up relevant traits: scholar
			modifier = {
				add = sce_ai_mod_trait_weight_medium
				has_trait = scholar
			}
			# Weight up relevant traits: theologian
			modifier = {
				add = sce_ai_mod_trait_weight_light
				has_trait = theologian
			}
		}
	}

	#Like a Viper
	option = {
		name = single_combat.0001.like_a_viper
		trigger = { exists = local_var:combat_move_like_a_viper_flag }

		#Move clarification
		custom_tooltip = single_combat.0001.tt.like_a_viper

		#Spawn Info
		skill = intrigue

		#Move effects
		## First, we show the move's effects with no guff.
		show_as_tooltip = { combat_move_like_a_viper_effect = yes }
		## Then, we check to make sure if scope:my_foe is still around to suffer the effects. This prevents errors if they die mid-combat.
		if = {
			limit = {
				scope:my_foe = { is_alive = yes }
			}
			hidden_effect = { combat_move_like_a_viper_effect = yes }
		}

		stress_impact = {
			deceitful = minor_stress_impact_loss
			arbitrary = minor_stress_impact_loss
			honest = minor_stress_impact_gain
			just = minor_stress_impact_gain
		}
		ai_chance = {
			base = 100
			sce_shrewd_fighter_scripted_modifier = yes
			# Weight up relevant traits: schemer
			modifier = {
				add = sce_ai_mod_trait_weight_heavy
				has_trait = schemer
			}
			# Weight up relevant traits: torturer
			modifier = {
				add = sce_ai_mod_trait_weight_medium
				has_trait = torturer
			}
		}
	}

	#Pocket Silver
	option = {
		name = single_combat.0001.pocket_silver
		trigger = { exists = local_var:combat_move_pocket_silver_flag }

		#Move clarification
		custom_tooltip = single_combat.0001.tt.pocket_silver

		#Spawn Info
		skill = stewardship

		#Move effects
		## First, we show the move's effects with no guff.
		show_as_tooltip = { combat_move_pocket_silver_effect = yes }
		## Then, we check to make sure if scope:my_foe is still around to suffer the effects. This prevents errors if they die mid-combat.
		if = {
			limit = {
				scope:my_foe = { is_alive = yes }
			}
			hidden_effect = { combat_move_pocket_silver_effect = yes }
		}

		stress_impact = {
			deceitful = miniscule_stress_impact_loss
			arbitrary = miniscule_stress_impact_loss
			generous = miniscule_stress_impact_loss
			honest = miniscule_stress_impact_gain
			just = miniscule_stress_impact_gain
			greedy = miniscule_stress_impact_gain
		}
		ai_chance = {
			base = 100
			ai_value_modifier = { ai_greed = -0.5 }
			# Weight up relevant traits: avaricious
			modifier = {
				add = sce_ai_mod_trait_down_weight_medium
				has_trait = avaricious
			}
		}
	}

	#Martial Voice
	option = {
		name = single_combat.0001.martial_voice
		trigger = { exists = local_var:combat_move_martial_voice_flag }

		#Move clarification
		custom_tooltip = single_combat.0001.tt.martial_voice

		#Spawn Info
		skill = martial

		#Move effects
		## First, we show the move's effects with no guff.
		show_as_tooltip = { combat_move_martial_voice_effect = yes }
		## Then, we check to make sure if scope:my_foe is still around to suffer the effects. This prevents errors if they die mid-combat.
		if = {
			limit = {
				scope:my_foe = { is_alive = yes }
			}
			hidden_effect = { combat_move_martial_voice_effect = yes }
		}

		stress_impact = {
			callous = miniscule_stress_impact_loss
			sadistic = miniscule_stress_impact_loss
			gregarious = miniscule_stress_impact_loss
			compassionate = miniscule_stress_impact_gain
			shy = miniscule_stress_impact_gain
		}
		ai_chance = {
			base = 100
			sce_enjoys_arrogant_speeches_scripted_modifier = yes
			# Weight up relevant traits: strategist
			modifier = {
				add = sce_ai_mod_trait_weight_medium
				has_trait = strategist
			}
		}
	}

	#Mocking Boast
	option = {
		name = single_combat.0001.mocking_boast
		trigger = { exists = local_var:combat_move_mocking_boast_flag }

		#Move clarification
		custom_tooltip = single_combat.0001.tt.mocking_boast

		#Move effects
		## First, we show the move's effects with no guff.
		show_as_tooltip = { combat_move_mocking_boast_effect = yes }
		## Then, we check to make sure if scope:my_foe is still around to suffer the effects. This prevents errors if they die mid-combat.
		if = {
			limit = {
				scope:my_foe = { is_alive = yes }
			}
			hidden_effect = { combat_move_mocking_boast_effect = yes }
		}

		stress_impact = {
			callous = miniscule_stress_impact_loss
			sadistic = miniscule_stress_impact_loss
			arrogant = miniscule_stress_impact_loss
			compassionate = miniscule_stress_impact_gain
			humble = miniscule_stress_impact_gain
		}
		ai_chance = {
			base = 100
			sce_enjoys_arrogant_speeches_scripted_modifier = yes
		}
	}

	#Is that a Crocodile?!
	option = {
		name = single_combat.0001.is_that_a_crocodile
		trigger = { exists = local_var:combat_move_is_that_a_crocodile_flag }

		#Move clarification
		custom_tooltip = single_combat.0001.tt.is_that_a_crocodile

		#Move effects
		## First, we show the move's effects with no guff.
		show_as_tooltip = { combat_move_is_that_a_crocodile_effect = yes }
		## Then, we check to make sure if scope:my_foe is still around to suffer the effects. This prevents errors if they die mid-combat.
		if = {
			limit = {
				scope:my_foe = { is_alive = yes }
			}
			hidden_effect = { combat_move_is_that_a_crocodile_effect = yes }
		}

		# Though it might be stressful for your opponent, a crocodile is not stressful for you.
		ai_chance = {
			base = 300
			# If you get the good option, use the good option.
		}
	}

	#Desert Warrior
	option = {
		name = single_combat.0001.desert_warrior
		trigger = { exists = local_var:combat_move_desert_warrior_flag }

		#Move clarification
		custom_tooltip = single_combat.0001.tt.desert_warrior

		#Spawn Info
		trait = desert_warrior

		#Move effects
		## First, we show the move's effects with no guff.
		show_as_tooltip = { combat_move_desert_warrior_effect = yes }
		## Then, we check to make sure if scope:my_foe is still around to suffer the effects. This prevents errors if they die mid-combat.
		if = {
			limit = {
				scope:my_foe = { is_alive = yes }
			}
			hidden_effect = { combat_move_desert_warrior_effect = yes }
		}

		stress_impact = {
			diligent = miniscule_stress_impact_loss
			calm = miniscule_stress_impact_loss
			lazy = miniscule_stress_impact_gain
			wrathful = miniscule_stress_impact_gain
		}
		ai_chance = {
			base = 100
			sce_shrewd_fighter_scripted_modifier = yes
		}
	}

	#Jungle Stalker
	option = {
		name = single_combat.0001.jungle_stalker
		trigger = { exists = local_var:combat_move_jungle_stalker_flag }

		#Move clarification
		custom_tooltip = single_combat.0001.tt.jungle_stalker

		#Spawn Info
		trait = jungle_stalker

		#Move effects
		## First, we show the move's effects with no guff.
		show_as_tooltip = { combat_move_jungle_stalker_effect = yes }
		## Then, we check to make sure if scope:my_foe is still around to suffer the effects. This prevents errors if they die mid-combat.
		if = {
			limit = {
				scope:my_foe = { is_alive = yes }
			}
			hidden_effect = { combat_move_jungle_stalker_effect = yes }
		}

		stress_impact = {
			diligent = miniscule_stress_impact_loss
			calm = miniscule_stress_impact_loss
			lazy = miniscule_stress_impact_gain
			wrathful = miniscule_stress_impact_gain
		}
		ai_chance = {
			base = 100
			sce_shrewd_fighter_scripted_modifier = yes
		}
	}

	#Open Terrain Expert
	option = {
		name = single_combat.0001.open_terrain_expert
		trigger = { exists = local_var:combat_move_open_terrain_expert_flag }

		#Move clarification
		custom_tooltip = single_combat.0001.tt.open_terrain_expert

		#Spawn Info
		trait = open_terrain_expert

		#Move effects
		## First, we show the move's effects with no guff.
		show_as_tooltip = { combat_move_open_terrain_expert_effect = yes }
		## Then, we check to make sure if scope:my_foe is still around to suffer the effects. This prevents errors if they die mid-combat.
		if = {
			limit = {
				scope:my_foe = { is_alive = yes }
			}
			hidden_effect = { combat_move_open_terrain_expert_effect = yes }
		}

		stress_impact = {
			diligent = miniscule_stress_impact_loss
			calm = miniscule_stress_impact_loss
			lazy = miniscule_stress_impact_gain
			wrathful = miniscule_stress_impact_gain
		}
		ai_chance = {
			base = 100
			sce_shrewd_fighter_scripted_modifier = yes
		}
	}

	#Rough Terrain Expert
	option = {
		name = single_combat.0001.rough_terrain_expert
		trigger = { exists = local_var:combat_move_rough_terrain_expert_flag }

		#Move clarification
		custom_tooltip = single_combat.0001.tt.rough_terrain_expert

		#Spawn Info
		trait = rough_terrain_expert

		#Move effects
		## First, we show the move's effects with no guff.
		show_as_tooltip = { combat_move_rough_terrain_expert_effect = yes }
		## Then, we check to make sure if scope:my_foe is still around to suffer the effects. This prevents errors if they die mid-combat.
		if = {
			limit = {
				scope:my_foe = { is_alive = yes }
			}
			hidden_effect = { combat_move_rough_terrain_expert_effect = yes }
		}

		stress_impact = {
			diligent = miniscule_stress_impact_loss
			calm = miniscule_stress_impact_loss
			lazy = miniscule_stress_impact_gain
			wrathful = miniscule_stress_impact_gain
		}
		ai_chance = {
			base = 100
			sce_shrewd_fighter_scripted_modifier = yes
		}
	}

	#Forest Fighter
	option = {
		name = single_combat.0001.forest_fighter
		trigger = { exists = local_var:combat_move_forest_fighter_flag }

		#Move clarification
		custom_tooltip = single_combat.0001.tt.forest_fighter

		#Spawn Info
		trait = forest_fighter

		#Move effects
		## First, we show the move's effects with no guff.
		show_as_tooltip = { combat_move_forest_fighter_effect = yes }
		## Then, we check to make sure if scope:my_foe is still around to suffer the effects. This prevents errors if they die mid-combat.
		if = {
			limit = {
				scope:my_foe = { is_alive = yes }
			}
			hidden_effect = { combat_move_forest_fighter_effect = yes }
		}

		stress_impact = {
			diligent = miniscule_stress_impact_loss
			calm = miniscule_stress_impact_loss
			lazy = miniscule_stress_impact_gain
			wrathful = miniscule_stress_impact_gain
		}
		ai_chance = {
			base = 100
			sce_shrewd_fighter_scripted_modifier = yes
		}
	}

	#RAAARGH!
	option = {
		name = single_combat.0001.raaargh
		trigger = { exists = local_var:combat_move_raaargh_flag }

		#Move clarification
		custom_tooltip = single_combat.0001.tt.raaargh

		#Spawn Info
		trait = berserker

		#Move effects
		## First, we show the move's effects with no guff.
		show_as_tooltip = { combat_move_raaargh_effect = yes }
		## Then, we check to make sure if scope:my_foe is still around to suffer the effects. This prevents errors if they die mid-combat.
		if = {
			limit = {
				scope:my_foe = { is_alive = yes }
			}
			hidden_effect = { combat_move_raaargh_effect = yes }
		}

		# No stress for RAAARGH!, as it gives stress loss.
		ai_chance = {
			base = 100
			sce_preferred_shrewd_fighter_scripted_modifier = yes
		}
	}

	#Hard Grit
	option = {
		name = single_combat.0001.hard_grit
		trigger = { exists = local_var:combat_move_hard_grit_flag }

		#Move clarification
		custom_tooltip = single_combat.0001.tt.hard_grit

		#Spawn Info
		trait = shieldmaiden

		#Move effects
		## First, we show the move's effects with no guff.
		show_as_tooltip = { combat_move_hard_grit_effect = yes }
		## Then, we check to make sure if scope:my_foe is still around to suffer the effects. This prevents errors if they die mid-combat.
		if = {
			limit = {
				scope:my_foe = { is_alive = yes }
			}
			hidden_effect = { combat_move_hard_grit_effect = yes }
		}

		# Loc here implies stoic professionalism, so doesn't seem fair to apply stress over that.
		ai_chance = {
			base = 100
			sce_preferred_shrewd_fighter_scripted_modifier = yes
		}
	}

	#Feint & Stab
	option = {
		name = single_combat.0001.feint_and_stab
		trigger = { exists = local_var:combat_move_feint_and_stab_flag }

		#Move clarification
		custom_tooltip = single_combat.0001.tt.feint_and_stab

		#Spawn Info; use individual traits so that the unlock trait shows in the option UI.
		trait = lifestyle_hunter

		#Move effects
		## First, we show the move's effects with no guff.
		show_as_tooltip = { combat_move_feint_and_stab_effect = yes }
		## Then, we check to make sure if scope:my_foe is still around to suffer the effects. This prevents errors if they die mid-combat.
		if = {
			limit = {
				scope:my_foe = { is_alive = yes }
			}
			hidden_effect = { combat_move_feint_and_stab_effect = yes }
		}

		stress_impact = {
			deceitful = minor_stress_impact_loss
			arbitrary = minor_stress_impact_loss
			honest = minor_stress_impact_gain
			just = minor_stress_impact_gain
		}
		ai_chance = {
			base = 100
			sce_preferred_shrewd_fighter_scripted_modifier = yes
		}
	}

	#Butchery
	option = {
		name = single_combat.0001.butchery
		trigger = { exists = local_var:combat_move_butchery_flag }

		#Move clarification
		custom_tooltip = single_combat.0001.tt.butchery

		#Spawn Info
		trait = viking

		#Move effects
		## First, we show the move's effects with no guff.
		show_as_tooltip = { combat_move_butchery_effect = yes }
		## Then, we check to make sure if scope:my_foe is still around to suffer the effects. This prevents errors if they die mid-combat.
		if = {
			limit = {
				scope:my_foe = { is_alive = yes }
			}
			hidden_effect = { combat_move_butchery_effect = yes }
		}

		stress_impact = {
			callous = minor_stress_impact_loss
			sadistic = minor_stress_impact_loss
			compassionate = minor_stress_impact_gain
		}
		ai_chance = {
			base = 100
			sce_preferred_shrewd_fighter_scripted_modifier = yes
		}
	}

	#Stoic Veteran Warcraft
	#option = {
	#	name = {
	#		trigger = {
	#			NOT = {
	#				scope:my_foe = { has_trait = varangian }
	#			}
	#		}
	#		text = single_combat.0001.stoic_veteran.general
	#	}
	#	name = {
	#		trigger = {
	#			scope:my_foe = { has_trait = varangian }
	#		}
	#		text = single_combat.0001.stoic_veteran.other_varangian
	#	}
	#	trigger = { exists = local_var:combat_move_stoic_veteran_flag }
	#
	#	#Move clarification
	#	custom_tooltip = single_combat.0001.tt.stoic_veteran
	#
	#	#Spawn Info
	#	trait = varangian
	#
	#	#Move effects
	#	## First, we show the move's effects with no guff.
	#	show_as_tooltip = { combat_move_stoic_veteran_effect = yes }
	#	## Then, we check to make sure if scope:my_foe is still around to suffer the effects. This prevents errors if they die mid-combat.
	#	if = {
	#		limit = {
	#			scope:my_foe = { is_alive = yes }
	#		}
	#		hidden_effect = { combat_move_stoic_veteran_effect = yes }
	#	}
	#
	#	# Loc here implies stoic professionalism, so doesn't seem fair to apply stress over that.
	#	ai_chance = {
	#		base = 100
	#		sce_preferred_shrewd_fighter_scripted_modifier = yes
	#	}
	#}

	#Blade Dance
	option = {
		name = single_combat.0001.blade_dance
		trigger = { exists = local_var:combat_move_blade_dance_flag }

		#Move clarification
		custom_tooltip = single_combat.0001.tt.blade_dance

		#Spawn Info; use individual traits so that the unlock trait shows in the option UI.
		trait = lifestyle_blademaster

		#Move effects
		## First, we show the move's effects with no guff.
		show_as_tooltip = { combat_move_blade_dance_effect = yes }
		## Then, we check to make sure if scope:my_foe is still around to suffer the effects. This prevents errors if they die mid-combat.
		if = {
			limit = {
				scope:my_foe = { is_alive = yes }
			}
			hidden_effect = { combat_move_blade_dance_effect = yes }
		}

		# No appropriate stress loss for blade dance; arguably arrogant, as we portray them as haughty in the loc, but it's a bit mean to both hit the player verbally and mechanically for something that's up for interpretation.
		ai_chance = {
			base = 100
			sce_preferred_shrewd_fighter_scripted_modifier = yes
		}
	}

	#Wrath of [HighGod]
	option = {
		name = single_combat.0001.wrath_of_highgod
		trigger = { exists = local_var:combat_move_wrath_of_highgod_flag }

		#Move clarification
		custom_tooltip = single_combat.0001.tt.wrath_of_highgod

		#Spawn Info
		trait = zealous

		#Move effects
		## First, we show the move's effects with no guff.
		show_as_tooltip = { combat_move_wrath_of_highgod_effect = yes }
		## Then, we check to make sure if scope:my_foe is still around to suffer the effects. This prevents errors if they die mid-combat.
		if = {
			limit = {
				scope:my_foe = { is_alive = yes }
			}
			hidden_effect = { combat_move_wrath_of_highgod_effect = yes }
		}

		stress_impact = {
			# Takes a bold human to stop fighting entirely and pray, however loudly, in the middle of a duel.
			craven = miniscule_stress_impact_loss
			brave = miniscule_stress_impact_gain
		}
		ai_chance = {
			base = 100
			sce_enjoys_arrogant_speeches_scripted_modifier = yes
		}
	}

	#Hurt Me Better
	option = {
		name = single_combat.0001.hurt_me_better
		trigger = { exists = local_var:combat_move_hurt_me_better_flag }

		#Move clarification
		custom_tooltip = single_combat.0001.tt.hurt_me_better

		#Spawn Info
		trait = deviant

		#Move effects
		## First, we show the move's effects with no guff.
		show_as_tooltip = { combat_move_hurt_me_better_effect = yes }
		## Then, we check to make sure if scope:my_foe is still around to suffer the effects. This prevents errors if they die mid-combat.
		if = {
			limit = {
				scope:my_foe = { is_alive = yes }
			}
			hidden_effect = { combat_move_hurt_me_better_effect = yes }
		}

		# We draw the line at stress loss/gain for lustful/chaste: we're already being a bit mean to deviant characters here, no need to ramp up the Hellraiser vibes *that* much.
		ai_chance = {
			base = 100
			sce_shrewd_fighter_scripted_modifier = yes
		}
	}

	#Special Fallback: kick 'em in the shin
	option = {
		name = single_combat.0001.special_fallback
		trigger = { exists = local_var:combat_move_special_fallback_flag }

		#Move clarification
		custom_tooltip = single_combat.0001.tt.special_fallback

		#Move effects
		## First, we show the move's effects with no guff.
		show_as_tooltip = { combat_move_special_fallback_effect = yes }
		## Then, we check to make sure if scope:my_foe is still around to suffer the effects. This prevents errors if they die mid-combat.
		if = {
			limit = {
				scope:my_foe = { is_alive = yes }
			}
			hidden_effect = { combat_move_special_fallback_effect = yes }
		}

		# Shins, and the kicking thereof, have no particularly stressful effects on the human psyche.
		ai_chance = {
			base = 100
			# Errr... I can't even begin to imagine how you'd set AI preferences for this.
		}
	}

	#Something to Hide
	option = {
		name = single_combat.0001.something_to_hide
		trigger = { exists = local_var:combat_move_something_to_hide_flag }

		#Move clarification
		custom_tooltip = single_combat.0001.tt.something_to_hide

		#Move effects
		## First, we show the move's effects with no guff.
		show_as_tooltip = { combat_move_something_to_hide_effect = yes }
		## Then, we check to make sure if scope:my_foe is still around to suffer the effects. This prevents errors if they die mid-combat.
		if = {
			limit = {
				scope:my_foe = { is_alive = yes }
			}
			hidden_effect = { combat_move_something_to_hide_effect = yes }
		}

		stress_impact = {
			deceitful = miniscule_stress_impact_loss
			arbitrary = miniscule_stress_impact_loss
			honest = miniscule_stress_impact_gain
			just = miniscule_stress_impact_gain
		}
		ai_chance = {
			base = 100
			sce_enjoys_arrogant_speeches_scripted_modifier = yes
			# Weight up relevant traits: schemer
			modifier = {
				add = sce_ai_mod_trait_weight_light
				has_trait = schemer
			}
		}
	}

	#Work out the post-event effects.
	after = {
		# First, see if the next round is still valid.
		if = {
			limit = {
				OR = {
					scope:sc_attacker = { is_alive = no }
					scope:sc_defender = { is_alive = no }
				}
			}
			# First, clean up assorted things around the duels.
			hidden_effect = { remove_single_combat_info_effect = yes }
			# Then manually clear the duelling flag.
			scope:sc_defender = {
				if = {
					# Restrict to live characters to prevent errors.
					limit = { is_alive = yes }
					remove_variable = engaged_in_single_combat 
				}
			}
			scope:sc_attacker = {
				if = {
					# Restrict to live characters to prevent errors.
					limit = { is_alive = yes }
					remove_variable = engaged_in_single_combat 
				}
			}
			# Finally, fire the invalidation cleanup event.
			scope:sc_attacker = {
				#trigger_event = { saved_event_id = scope:invalidation_event }
				trigger_event = single_combat.1006
			}
		}
		# Otherwise, we can go through the usual flow.
		else = {
			#If either character has had an edge modifier added, update character skills to account for duel edge stuff.
			scope:sc_attacker = {
				if = {
					limit = { has_character_flag = sce_needs_forced_recalc_flag }
					force_character_skill_recalculation = yes
					remove_character_flag = sce_needs_forced_recalc_flag
				}
			}
			scope:sc_defender = {
				if = {
					limit = { has_character_flag = sce_needs_forced_recalc_flag }
					force_character_skill_recalculation = yes
					remove_character_flag = sce_needs_forced_recalc_flag
				}
			}
			#Calculate injury risks for descs.
			calculate_injury_risks_effect = yes
			#And success chances.
			calculate_success_chances_effect = yes
			#If we're scope:sc_defender, send scope:sc_attacker their instance of the event.
			if = {
				limit = { this = scope:sc_defender }
				scope:sc_attacker = { trigger_event = single_combat.0001 }
			}
			#Otherwise we're scope:sc_attacker, so end the round.
			else = { trigger_event = single_combat.0021 }
		}
	}
}

##################################################
# Round End Events
# by Ewan Cowhig Croft
# 0021 - 0030
##################################################

#	Standard round end event.
single_combat.0021 = {
	hidden = yes

	immediate = {
		# Check what round we're at, and reduce the threshold variables as appropriate if we're in a late enough round.
		## Reduce injury thresholds for both characters.
		if = {
			limit = { scope:sc_defender.var:current_round = round_injury_bonus_lower }
			debug_log = "single combat variable error-check: round_injury_bonus_lower"
			debug_log_scopes = yes
			change_variable = {
				name = sc_attacker_injury_bonus
				add = round_injury_adjustment_lower
			}
			scope:sc_defender = {
				change_variable = {
					name = sc_defender_injury_bonus
					add = round_injury_adjustment_lower
				}
			}
		}
		if = {
			limit = { scope:sc_defender.var:current_round = round_injury_bonus_lowest }
			debug_log = "single combat variable error-check: round_injury_bonus_lowest"
			debug_log_scopes = yes
			change_variable = {
				name = sc_attacker_injury_bonus
				add = round_injury_adjustment_lowest
			}
			scope:sc_defender = {
				change_variable = {
					name = sc_defender_injury_bonus
					add = round_injury_adjustment_lowest
				}
			}
		}
		## Reduce success threshold.
		if = {
			limit = { scope:sc_defender.var:current_round = round_success_threshold_lower }
			debug_log = "single combat variable error-check: round_success_threshold_lower"
			debug_log_scopes = yes
			scope:sc_defender = {
				change_variable = {
					name = success_threshold
					add = round_success_adjustment_lower
				}
			}
		}
		if = {
			limit = { scope:sc_defender.var:current_round = round_success_threshold_lowest }
			debug_log = "single combat variable error-check: round_success_threshold_lowest"
			debug_log_scopes = yes
			scope:sc_defender = {
				change_variable = {
					name = success_threshold
					add = round_success_adjustment_lowest
				}
			}
		}
		# Check to see if either character has achieved a suitable success score.
		calculate_success_chances_effect = yes
		## Check scope:sc_attacker first, seeing if they have more success chance than the minimum threshold for victory.
		if = {
			limit = {
				scope:sc_attacker.var:sc_attacker_success_check >= scope:sc_defender.var:success_threshold
			}
			save_scope_value_as = {
				name = sc_finished
				value = yes
			}
			scope:sc_attacker = { save_scope_as = sc_victor }
			scope:sc_defender = { save_scope_as = sc_loser }
			save_scope_value_as = {
				name = victory_type
				value = flag:skill
			}
		}
		## Then check scope:sc_defender, performing the same calculation in reverse.
		if = {
			limit = {
				scope:sc_defender.var:sc_defender_success_check >= scope:sc_defender.var:success_threshold
			}
			save_scope_value_as = {
				name = sc_finished
				value = yes
			}
			scope:sc_defender = { save_scope_as = sc_victor }
			scope:sc_attacker = { save_scope_as = sc_loser }
			save_scope_value_as = {
				name = victory_type
				value = flag:skill
			}
		}
		# If we have no victor yet, and we're past the first round, look at injuries.
		## Set up injury risks for this round; we do this regardless, since we look at these to work out injury chances for the desc block.
		calculate_injury_risks_effect = yes
		if = {
			limit = {
				NOT = { exists = scope:sc_finished }
				scope:sc_defender.var:current_round > 1
			}
			# Check scope:sc_attacker to see if they can injure themselves due to having more risk than success.
			if = {
				limit = {
					scope:sc_attacker.var:sc_attacker_injury_risk_check >= scope:sc_attacker.var:sc_attacker_duel_success_score
				}
				random = {
					chance = {
						value = 0
						add = scope:sc_attacker.var:sc_attacker_injury_risk_check
						subtract = scope:sc_attacker.var:sc_attacker_duel_success_score
					}
					save_scope_value_as = {
						name = sc_finished
						value = yes
					}
					scope:sc_defender = { save_scope_as = sc_victor }
					scope:sc_attacker = { save_scope_as = sc_loser }
					save_scope_value_as = {
						name = victory_type
						value = flag:mistake
					}
				}
			}
			# Then check scope:sc_defender in the same fashion.
			if = {
				limit = {
					scope:sc_defender.var:sc_defender_injury_risk_check >= scope:sc_defender.var:sc_defender_duel_success_score
				}
				random = {
					chance = {
						value = 0
						add = scope:sc_defender.var:sc_defender_injury_risk_check
						subtract = scope:sc_defender.var:sc_defender_duel_success_score
					}
					save_scope_value_as = {
						name = sc_finished
						value = yes
					}
					scope:sc_attacker = { save_scope_as = sc_victor }
					scope:sc_defender = { save_scope_as = sc_loser }
					save_scope_value_as = {
						name = victory_type
						value = flag:mistake
					}
				}
			}
		}
		# If we now have a victor, work out the cleanup.
		if = {
			limit = { exists = scope:sc_finished }
			finalise_combat_results_effect = yes
		}
		# If we don't, and this round is at or over the round_cap_limit, enter into sudden death.
		else_if = {
			limit = { scope:sc_defender.var:current_round >= round_cap_limit }
			# If scope:sc_attacker has the highest prowess, then they win.
			if = {
				limit = { scope:sc_attacker.prowess > scope:sc_defender.prowess }
				save_scope_value_as = {
					name = sc_finished
					value = yes
				}
				scope:sc_attacker = { save_scope_as = sc_victor }
				scope:sc_defender = { save_scope_as = sc_loser }
				save_scope_value_as = {
					name = victory_type
					value = flag:sudden_death
				}
			}
			# If scope:sc_defender has the highest prowess, then *they* win.
			else_if = {
				limit = { scope:sc_defender.prowess > scope:sc_attacker.prowess }
				save_scope_value_as = {
					name = sc_finished
					value = yes
				}
				scope:sc_defender = { save_scope_as = sc_victor }
				scope:sc_attacker = { save_scope_as = sc_loser }
				save_scope_value_as = {
					name = victory_type
					value = flag:sudden_death
				}
			}
			# Otherwise, their prowess must be even, so we do a toss-up.
			else = {
				random_list = {
					#Scope:sc_attacker wins.
					50 = {
						save_scope_value_as = {
							name = sc_finished
							value = yes
						}
						scope:sc_attacker = { save_scope_as = sc_victor }
						scope:sc_defender = { save_scope_as = sc_loser }
						save_scope_value_as = {
							name = victory_type
							value = flag:sudden_death
						}
					}
					#Scope:sc_defender wins.
					50 = {
						save_scope_value_as = {
							name = sc_finished
							value = yes
						}
						scope:sc_defender = { save_scope_as = sc_victor }
						scope:sc_attacker = { save_scope_as = sc_loser }
						save_scope_value_as = {
							name = victory_type
							value = flag:sudden_death
						}
					}
				}
			}
			#Sort the end of combat.
			finalise_combat_results_effect = yes
		}
		# If we don't, and we've not yet hit the round_cap_limit, increment the round_number & fire off the next round.
		else = {
			scope:sc_defender = {
				# We change the round number right at the end, so that it doesn't mess up any calculations elsewhere.
				change_variable = {
					name = current_round
					add = 1
				}
				trigger_event = single_combat.0001
			}
		}
	}
}

##################################################
# Results Events
# by Ewan Cowhig Croft
# 0031 - 0050
##################################################

scripted_effect sce_loser_end_result_tooltip_effect = {
	#Clarify the results.
	if = {
		limit = { scope:victory_type = flag:skill }
		custom_tooltip = single_combat.0031.desc.result.skill
	}
	else_if = {
		limit = { scope:victory_type = flag:mistake }
		custom_tooltip = single_combat.0031.desc.result.mistake
	}
	else_if = {
		limit = { scope:victory_type = flag:sudden_death }
		custom_tooltip = single_combat.0031.desc.result.sudden_death
	}
}

scripted_effect sce_victor_end_result_tooltip_effect = {
	#Clarify the results.
	if = {
		limit = { scope:victory_type = flag:skill }
		custom_tooltip = single_combat.0041.desc.result.skill
	}
	else_if = {
		limit = { scope:victory_type = flag:mistake }
		custom_tooltip = single_combat.0041.desc.result.mistake
	}
	else_if = {
		limit = { scope:victory_type = flag:sudden_death }
		custom_tooltip = single_combat.0041.desc.result.sudden_death
	}
}

#	scope:sc_loser's confirmation event.
single_combat.0031 = {
	type = character_event
	window = duel_event
	title = single_combat.0031.t
	desc = {
		first_valid = {
			# Are we in scope:sc_defender's POV?
			triggered_desc = {
				trigger = { this = scope:sc_defender }
				desc = {
					# Our POV tells us that we did X.
					triggered_desc = {
						#This trigger should always exist, but the desc structure is required for code reasons.
						trigger = { always = yes }
						desc = {
							first_valid = {
								triggered_desc = {
									trigger = { scope:sc_defender_last_move = flag:wait_and_hope }
									desc = single_combat.0031.desc.sc_defender.wait_and_hope
								}
								triggered_desc = {
									trigger = { scope:sc_defender_last_move = flag:unsure_attack }
									desc = single_combat.0031.desc.sc_defender.unsure_attack
								}
								triggered_desc = {
									trigger = { scope:sc_defender_last_move = flag:enthusiastic_onslaught }
									desc = single_combat.0031.desc.sc_defender.enthusiastic_onslaught
								}
								triggered_desc = {
									trigger = { scope:sc_defender_last_move = flag:hail_mary }
									desc = single_combat.0031.desc.sc_defender.hail_mary
								}
								triggered_desc = {
									trigger = { scope:sc_defender_last_move = flag:pocket_sand }
									desc = single_combat.0031.desc.sc_defender.pocket_sand
								}
								triggered_desc = {
									trigger = { scope:sc_defender_last_move = flag:nut_em }
									desc = single_combat.0031.desc.sc_defender.nut_em
								}
								triggered_desc = {
									trigger = { scope:sc_defender_last_move = flag:guard }
									desc = single_combat.0031.desc.sc_defender.guard
								}
								triggered_desc = {
									trigger = { scope:sc_defender_last_move = flag:probing_attack }
									desc = single_combat.0031.desc.sc_defender.probing_attack
								}
								triggered_desc = {
									trigger = { scope:sc_defender_last_move = flag:onslaught }
									desc = single_combat.0031.desc.sc_defender.onslaught
								}
								triggered_desc = {
									trigger = { scope:sc_defender_last_move = flag:surprise_attack }
									desc = single_combat.0031.desc.sc_defender.surprise_attack
								}
								triggered_desc = {
									trigger = { scope:sc_defender_last_move = flag:taunt }
									desc = single_combat.0031.desc.sc_defender.taunt
								}
								triggered_desc = {
									trigger = { scope:sc_defender_last_move = flag:put_the_boot_in }
									desc = single_combat.0031.desc.sc_defender.put_the_boot_in
								}
								triggered_desc = {
									trigger = { scope:sc_defender_last_move = flag:strict_guard }
									desc = single_combat.0031.desc.sc_defender.strict_guard
								}
								triggered_desc = {
									trigger = { scope:sc_defender_last_move = flag:confident_attack }
									desc = single_combat.0031.desc.sc_defender.confident_attack
								}
								triggered_desc = {
									trigger = { scope:sc_defender_last_move = flag:expert_onslaught }
									desc = single_combat.0031.desc.sc_defender.expert_onslaught
								}
								triggered_desc = {
									trigger = { scope:sc_defender_last_move = flag:attempt_disarm }
									desc = single_combat.0031.desc.sc_defender.attempt_disarm
								}
								triggered_desc = {
									trigger = { scope:sc_defender_last_move = flag:tire_opponent }
									desc = single_combat.0031.desc.sc_defender.tire_opponent
								}
								triggered_desc = {
									trigger = { scope:sc_defender_last_move = flag:reason_you_suck_speech }
									desc = single_combat.0031.desc.sc_defender.reason_you_suck_speech
								}
								triggered_desc = {
									trigger = { scope:sc_defender_last_move = flag:technique_from_legend }
									desc = single_combat.0031.desc.sc_defender.technique_from_legend
								}
								triggered_desc = {
									trigger = { scope:sc_defender_last_move = flag:like_a_viper }
									desc = single_combat.0031.desc.sc_defender.like_a_viper
								}
								triggered_desc = {
									trigger = { scope:sc_defender_last_move = flag:pocket_silver }
									desc = single_combat.0031.desc.sc_defender.pocket_silver
								}
								triggered_desc = {
									trigger = { scope:sc_defender_last_move = flag:martial_voice }
									desc = single_combat.0031.desc.sc_defender.martial_voice
								}
								triggered_desc = {
									trigger = { scope:sc_defender_last_move = flag:mocking_boast }
									desc = single_combat.0031.desc.sc_defender.mocking_boast
								}
								triggered_desc = {
									trigger = { scope:sc_defender_last_move = flag:is_that_a_crocodile }
									desc = single_combat.0031.desc.sc_defender.is_that_a_crocodile
								}
								triggered_desc = {
									trigger = { scope:sc_defender_last_move = flag:desert_warrior }
									desc = single_combat.0031.desc.sc_defender.desert_warrior
								}
								triggered_desc = {
									trigger = { scope:sc_defender_last_move = flag:jungle_stalker }
									desc = single_combat.0031.desc.sc_defender.jungle_stalker
								}
								triggered_desc = {
									trigger = { scope:sc_defender_last_move = flag:open_terrain_expert }
									desc = single_combat.0031.desc.sc_defender.open_terrain_expert
								}
								triggered_desc = {
									trigger = { scope:sc_defender_last_move = flag:rough_terrain_expert }
									desc = single_combat.0031.desc.sc_defender.rough_terrain_expert
								}
								triggered_desc = {
									trigger = { scope:sc_defender_last_move = flag:forest_fighter }
									desc = single_combat.0031.desc.sc_defender.forest_fighter
								}
								triggered_desc = {
									trigger = { scope:sc_defender_last_move = flag:raaargh }
									desc = single_combat.0031.desc.sc_defender.raaargh
								}
								triggered_desc = {
									trigger = { scope:sc_defender_last_move = flag:hard_grit }
									desc = single_combat.0031.desc.sc_defender.hard_grit
								}
								triggered_desc = {
									trigger = { scope:sc_defender_last_move = flag:feint_and_stab }
									desc = single_combat.0031.desc.sc_defender.feint_and_stab
								}
								triggered_desc = {
									trigger = { scope:sc_defender_last_move = flag:butchery }
									desc = single_combat.0031.desc.sc_defender.butchery
								}
								triggered_desc = {
									trigger = { scope:sc_defender_last_move = flag:stoic_veteran }
									desc = single_combat.0031.desc.sc_defender.stoic_veteran
								}
								triggered_desc = {
									trigger = { scope:sc_defender_last_move = flag:blade_dance }
									desc = single_combat.0031.desc.sc_defender.blade_dance
								}
								triggered_desc = {
									trigger = { scope:sc_defender_last_move = flag:wrath_of_highgod }
									desc = single_combat.0031.desc.sc_defender.wrath_of_highgod
								}
								triggered_desc = {
									trigger = { scope:sc_defender_last_move = flag:hurt_me_better }
									desc = single_combat.0031.desc.sc_defender.hurt_me_better
								}
								triggered_desc = {
									trigger = { scope:sc_defender_last_move = flag:special_fallback }
									desc = single_combat.0031.desc.sc_defender.special_fallback
								}
								triggered_desc = {
									trigger = { scope:sc_defender_last_move = flag:something_to_hide }
									desc = single_combat.0031.desc.sc_defender.something_to_hide
								}
							}
						}
					}
					# And scope:sc_attacker successfully countered with Y.
					triggered_desc = {
						#This trigger should always exist, but the desc structure is required for code reasons.
						trigger = { always = yes }
						desc = {
							first_valid = {
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:wait_and_hope }
									desc = single_combat.0031.desc.opponent_response.wait_and_hope
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:unsure_attack }
									desc = single_combat.0031.desc.opponent_response.unsure_attack
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:enthusiastic_onslaught }
									desc = single_combat.0031.desc.opponent_response.enthusiastic_onslaught
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:hail_mary }
									desc = single_combat.0031.desc.opponent_response.hail_mary
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:pocket_sand }
									desc = single_combat.0031.desc.opponent_response.pocket_sand
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:nut_em }
									desc = single_combat.0031.desc.opponent_response.nut_em
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:guard }
									desc = single_combat.0031.desc.opponent_response.guard
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:probing_attack }
									desc = single_combat.0031.desc.opponent_response.probing_attack
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:onslaught }
									desc = single_combat.0031.desc.opponent_response.onslaught
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:surprise_attack }
									desc = single_combat.0031.desc.opponent_response.surprise_attack
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:taunt }
									desc = single_combat.0031.desc.opponent_response.taunt
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:put_the_boot_in }
									desc = single_combat.0031.desc.opponent_response.put_the_boot_in
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:strict_guard }
									desc = single_combat.0031.desc.opponent_response.strict_guard
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:confident_attack }
									desc = single_combat.0031.desc.opponent_response.confident_attack
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:expert_onslaught }
									desc = single_combat.0031.desc.opponent_response.expert_onslaught
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:attempt_disarm }
									desc = single_combat.0031.desc.opponent_response.attempt_disarm
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:tire_opponent }
									desc = single_combat.0031.desc.opponent_response.tire_opponent
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:reason_you_suck_speech }
									desc = single_combat.0031.desc.opponent_response.reason_you_suck_speech
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:technique_from_legend }
									desc = single_combat.0031.desc.opponent_response.technique_from_legend
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:like_a_viper }
									desc = single_combat.0031.desc.opponent_response.like_a_viper
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:pocket_silver }
									desc = single_combat.0031.desc.opponent_response.pocket_silver
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:martial_voice }
									desc = single_combat.0031.desc.opponent_response.martial_voice
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:mocking_boast }
									desc = single_combat.0031.desc.opponent_response.mocking_boast
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:is_that_a_crocodile }
									desc = single_combat.0031.desc.opponent_response.is_that_a_crocodile
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:desert_warrior }
									desc = single_combat.0031.desc.opponent_response.desert_warrior
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:jungle_stalker }
									desc = single_combat.0031.desc.opponent_response.jungle_stalker
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:open_terrain_expert }
									desc = single_combat.0031.desc.opponent_response.open_terrain_expert
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:rough_terrain_expert }
									desc = single_combat.0031.desc.opponent_response.rough_terrain_expert
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:forest_fighter }
									desc = single_combat.0031.desc.opponent_response.forest_fighter
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:raaargh }
									desc = single_combat.0031.desc.opponent_response.raaargh
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:hard_grit }
									desc = single_combat.0031.desc.opponent_response.hard_grit
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:feint_and_stab }
									desc = single_combat.0031.desc.opponent_response.feint_and_stab
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:butchery }
									desc = single_combat.0031.desc.opponent_response.butchery
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:stoic_veteran }
									desc = single_combat.0031.desc.opponent_response.stoic_veteran
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:blade_dance }
									desc = single_combat.0031.desc.opponent_response.blade_dance
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:wrath_of_highgod }
									desc = single_combat.0031.desc.opponent_response.wrath_of_highgod
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:hurt_me_better }
									desc = single_combat.0031.desc.opponent_response.hurt_me_better
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:special_fallback }
									desc = single_combat.0031.desc.opponent_response.special_fallback
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:something_to_hide }
									desc = single_combat.0031.desc.opponent_response.something_to_hide
								}
							}
						}
					}
					# Leading to Z-1: injury.
					triggered_desc = {
						trigger = { duel_will_end_in_my_death_trigger = no }
						desc = {
							first_valid = {
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:wait_and_hope }
									desc = single_combat.0031.desc.opponent_response.wait_and_hope.injury
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:unsure_attack }
									desc = single_combat.0031.desc.opponent_response.unsure_attack.injury
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:enthusiastic_onslaught }
									desc = single_combat.0031.desc.opponent_response.enthusiastic_onslaught.injury
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:hail_mary }
									desc = single_combat.0031.desc.opponent_response.hail_mary.injury
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:pocket_sand }
									desc = single_combat.0031.desc.opponent_response.pocket_sand.injury
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:nut_em }
									desc = single_combat.0031.desc.opponent_response.nut_em.injury
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:guard }
									desc = single_combat.0031.desc.opponent_response.guard.injury
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:probing_attack }
									desc = single_combat.0031.desc.opponent_response.probing_attack.injury
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:onslaught }
									desc = single_combat.0031.desc.opponent_response.onslaught.injury
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:surprise_attack }
									desc = single_combat.0031.desc.opponent_response.surprise_attack.injury
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:taunt }
									desc = single_combat.0031.desc.opponent_response.taunt.injury
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:put_the_boot_in }
									desc = single_combat.0031.desc.opponent_response.put_the_boot_in.injury
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:strict_guard }
									desc = single_combat.0031.desc.opponent_response.strict_guard.injury
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:confident_attack }
									desc = single_combat.0031.desc.opponent_response.confident_attack.injury
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:expert_onslaught }
									desc = single_combat.0031.desc.opponent_response.expert_onslaught.injury
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:attempt_disarm }
									desc = single_combat.0031.desc.opponent_response.attempt_disarm.injury
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:tire_opponent }
									desc = single_combat.0031.desc.opponent_response.tire_opponent.injury
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:reason_you_suck_speech }
									desc = single_combat.0031.desc.opponent_response.reason_you_suck_speech.injury
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:technique_from_legend }
									desc = single_combat.0031.desc.opponent_response.technique_from_legend.injury
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:like_a_viper }
									desc = single_combat.0031.desc.opponent_response.like_a_viper.injury
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:pocket_silver }
									desc = single_combat.0031.desc.opponent_response.pocket_silver.injury
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:martial_voice }
									desc = single_combat.0031.desc.opponent_response.martial_voice.injury
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:mocking_boast }
									desc = single_combat.0031.desc.opponent_response.mocking_boast.injury
								}
								# No need for an is_that_a_crocodile, as it's never just an injury.
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:desert_warrior }
									desc = single_combat.0031.desc.opponent_response.desert_warrior.injury
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:jungle_stalker }
									desc = single_combat.0031.desc.opponent_response.jungle_stalker.injury
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:open_terrain_expert }
									desc = single_combat.0031.desc.opponent_response.open_terrain_expert.injury
								}
								triggered_desc = {
									trigger = {
										scope:sc_attacker_last_move = flag:rough_terrain_expert
										scope:sc_defender.location = { rocky_locale_trigger = yes }
									}
									desc = single_combat.0031.desc.opponent_response.rough_terrain_expert.injury.rocky
								}
								triggered_desc = {
									trigger = {
										scope:sc_attacker_last_move = flag:rough_terrain_expert
										scope:sc_defender.location = { terrain = wetlands }
									}
									desc = single_combat.0031.desc.opponent_response.rough_terrain_expert.injury.boggy
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:forest_fighter }
									desc = single_combat.0031.desc.opponent_response.forest_fighter.injury
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:raaargh }
									desc = single_combat.0031.desc.opponent_response.raaargh.injury
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:hard_grit }
									desc = single_combat.0031.desc.opponent_response.hard_grit.injury
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:feint_and_stab }
									desc = single_combat.0031.desc.opponent_response.feint_and_stab.injury
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:butchery }
									desc = single_combat.0031.desc.opponent_response.butchery.injury
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:stoic_veteran }
									desc = single_combat.0031.desc.opponent_response.stoic_veteran.injury
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:blade_dance }
									desc = single_combat.0031.desc.opponent_response.blade_dance.injury
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:wrath_of_highgod }
									desc = single_combat.0031.desc.opponent_response.wrath_of_highgod.injury
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:hurt_me_better }
									desc = single_combat.0031.desc.opponent_response.hurt_me_better.injury
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:special_fallback }
									desc = single_combat.0031.desc.opponent_response.special_fallback.injury
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:something_to_hide }
									desc = single_combat.0031.desc.opponent_response.something_to_hide.injury
								}
							}
						}
					}
					# Or Z-2: death.
					triggered_desc = {
						trigger = { duel_will_end_in_my_death_trigger = yes }
						desc = {
							first_valid = {
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:wait_and_hope }
									desc = single_combat.0031.desc.opponent_response.wait_and_hope.fatality
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:unsure_attack }
									desc = single_combat.0031.desc.opponent_response.unsure_attack.fatality
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:enthusiastic_onslaught }
									desc = single_combat.0031.desc.opponent_response.enthusiastic_onslaught.fatality
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:hail_mary }
									desc = single_combat.0031.desc.opponent_response.hail_mary.fatality
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:pocket_sand }
									desc = single_combat.0031.desc.opponent_response.pocket_sand.fatality
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:nut_em }
									desc = single_combat.0031.desc.opponent_response.nut_em.fatality
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:guard }
									desc = single_combat.0031.desc.opponent_response.guard.fatality
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:probing_attack }
									desc = single_combat.0031.desc.opponent_response.probing_attack.fatality
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:onslaught }
									desc = single_combat.0031.desc.opponent_response.onslaught.fatality
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:surprise_attack }
									desc = single_combat.0031.desc.opponent_response.surprise_attack.fatality
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:taunt }
									desc = single_combat.0031.desc.opponent_response.taunt.fatality
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:put_the_boot_in }
									desc = single_combat.0031.desc.opponent_response.put_the_boot_in.fatality
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:strict_guard }
									desc = single_combat.0031.desc.opponent_response.strict_guard.fatality
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:confident_attack }
									desc = single_combat.0031.desc.opponent_response.confident_attack.fatality
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:expert_onslaught }
									desc = single_combat.0031.desc.opponent_response.expert_onslaught.fatality
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:attempt_disarm }
									desc = single_combat.0031.desc.opponent_response.attempt_disarm.fatality
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:tire_opponent }
									desc = single_combat.0031.desc.opponent_response.tire_opponent.fatality
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:reason_you_suck_speech }
									desc = single_combat.0031.desc.opponent_response.reason_you_suck_speech.fatality
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:technique_from_legend }
									desc = single_combat.0031.desc.opponent_response.technique_from_legend.fatality
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:like_a_viper }
									desc = single_combat.0031.desc.opponent_response.like_a_viper.fatality
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:pocket_silver }
									desc = single_combat.0031.desc.opponent_response.pocket_silver.fatality
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:martial_voice }
									desc = single_combat.0031.desc.opponent_response.martial_voice.fatality
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:mocking_boast }
									desc = single_combat.0031.desc.opponent_response.mocking_boast.fatality
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:is_that_a_crocodile }
									desc = single_combat.0031.desc.opponent_response.is_that_a_crocodile.fatality
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:desert_warrior }
									desc = single_combat.0031.desc.opponent_response.desert_warrior.fatality
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:jungle_stalker }
									desc = single_combat.0031.desc.opponent_response.jungle_stalker.fatality
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:open_terrain_expert }
									desc = single_combat.0031.desc.opponent_response.open_terrain_expert.fatality
								}
								triggered_desc = {
									trigger = {
										scope:sc_attacker_last_move = flag:rough_terrain_expert
										scope:sc_defender.location = { rocky_locale_trigger = yes }
									}
									desc = single_combat.0031.desc.opponent_response.rough_terrain_expert.fatality.rocky
								}
								triggered_desc = {
									trigger = {
										scope:sc_attacker_last_move = flag:rough_terrain_expert
										scope:sc_defender.location = { terrain = wetlands }
									}
									desc = single_combat.0031.desc.opponent_response.rough_terrain_expert.fatality.boggy
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:forest_fighter }
									desc = single_combat.0031.desc.opponent_response.forest_fighter.fatality
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:raaargh }
									desc = single_combat.0031.desc.opponent_response.raaargh.fatality
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:hard_grit }
									desc = single_combat.0031.desc.opponent_response.hard_grit.fatality
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:feint_and_stab }
									desc = single_combat.0031.desc.opponent_response.feint_and_stab.fatality
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:butchery }
									desc = single_combat.0031.desc.opponent_response.butchery.fatality
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:stoic_veteran }
									desc = single_combat.0031.desc.opponent_response.stoic_veteran.fatality
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:blade_dance }
									desc = single_combat.0031.desc.opponent_response.blade_dance.fatality
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:wrath_of_highgod }
									desc = single_combat.0031.desc.opponent_response.wrath_of_highgod.fatality
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:hurt_me_better }
									desc = single_combat.0031.desc.opponent_response.hurt_me_better.fatality
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:special_fallback }
									desc = single_combat.0031.desc.opponent_response.special_fallback.fatality
								}
								# No need for a something_to_hide, as it's never fatal.
							}
						}
					}
				}
			}
			# Or scope:sc_attacker's?
			triggered_desc = {
				trigger = { this = scope:sc_attacker }
				desc = {
					# Our POV tells us that we went straight in with Y.
					triggered_desc = {
						#This trigger should always exist, but the desc structure is required for code reasons.
						trigger = { always = yes }
						desc = {
							first_valid = {
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:wait_and_hope }
									desc = single_combat.0031.desc.sc_attacker.wait_and_hope
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:unsure_attack }
									desc = single_combat.0031.desc.sc_attacker.unsure_attack
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:enthusiastic_onslaught }
									desc = single_combat.0031.desc.sc_attacker.enthusiastic_onslaught
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:hail_mary }
									desc = single_combat.0031.desc.sc_attacker.hail_mary
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:pocket_sand }
									desc = single_combat.0031.desc.sc_attacker.pocket_sand
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:nut_em }
									desc = single_combat.0031.desc.sc_attacker.nut_em
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:guard }
									desc = single_combat.0031.desc.sc_attacker.guard
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:probing_attack }
									desc = single_combat.0031.desc.sc_attacker.probing_attack
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:onslaught }
									desc = single_combat.0031.desc.sc_attacker.onslaught
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:surprise_attack }
									desc = single_combat.0031.desc.sc_attacker.surprise_attack
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:taunt }
									desc = single_combat.0031.desc.sc_attacker.taunt
								}
								triggered_desc = {
									trigger = {
										scope:sc_attacker_last_move = flag:put_the_boot_in
										has_trait = one_legged
									}
									desc = single_combat.0031.desc.sc_attacker.put_the_boot_in.peg_leg
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:put_the_boot_in }
									desc = single_combat.0031.desc.sc_attacker.put_the_boot_in.fallback
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:strict_guard }
									desc = single_combat.0031.desc.sc_attacker.strict_guard
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:confident_attack }
									desc = single_combat.0031.desc.sc_attacker.confident_attack
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:expert_onslaught }
									desc = single_combat.0031.desc.sc_attacker.expert_onslaught
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:attempt_disarm }
									desc = single_combat.0031.desc.sc_attacker.attempt_disarm
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:tire_opponent }
									desc = single_combat.0031.desc.sc_attacker.tire_opponent
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:reason_you_suck_speech }
									desc = single_combat.0031.desc.sc_attacker.reason_you_suck_speech
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:technique_from_legend }
									desc = single_combat.0031.desc.sc_attacker.technique_from_legend
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:like_a_viper }
									desc = single_combat.0031.desc.sc_attacker.like_a_viper
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:pocket_silver }
									desc = single_combat.0031.desc.sc_attacker.pocket_silver
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:martial_voice }
									desc = single_combat.0031.desc.sc_attacker.martial_voice
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:mocking_boast }
									desc = single_combat.0031.desc.sc_attacker.mocking_boast
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:is_that_a_crocodile }
									desc = single_combat.0031.desc.sc_attacker.is_that_a_crocodile
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:desert_warrior }
									desc = single_combat.0031.desc.sc_attacker.desert_warrior
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:jungle_stalker }
									desc = single_combat.0031.desc.sc_attacker.jungle_stalker
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:open_terrain_expert }
									desc = single_combat.0031.desc.sc_attacker.open_terrain_expert
								}
								triggered_desc = {
									trigger = {
										scope:sc_attacker_last_move = flag:rough_terrain_expert
										scope:sc_defender.location = { rocky_locale_trigger = yes }
									}
									desc = single_combat.0031.desc.sc_attacker.rough_terrain_expert.rocky
								}
								triggered_desc = {
									trigger = {
										scope:sc_attacker_last_move = flag:rough_terrain_expert
										scope:sc_defender.location = { terrain = wetlands }
									}
									desc = single_combat.0031.desc.sc_attacker.rough_terrain_expert.boggy
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:forest_fighter }
									desc = single_combat.0031.desc.sc_attacker.forest_fighter
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:raaargh }
									desc = single_combat.0031.desc.sc_attacker.raaargh
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:hard_grit }
									desc = single_combat.0031.desc.sc_attacker.hard_grit
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:feint_and_stab }
									desc = single_combat.0031.desc.sc_attacker.feint_and_stab
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:butchery }
									desc = single_combat.0031.desc.sc_attacker.butchery
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:stoic_veteran }
									desc = single_combat.0031.desc.sc_attacker.stoic_veteran
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:blade_dance }
									desc = single_combat.0031.desc.sc_attacker.blade_dance
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:wrath_of_highgod }
									desc = single_combat.0031.desc.sc_attacker.wrath_of_highgod
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:hurt_me_better }
									desc = single_combat.0031.desc.sc_attacker.hurt_me_better
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:special_fallback }
									desc = single_combat.0031.desc.sc_attacker.special_fallback
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:something_to_hide }
									desc = single_combat.0031.desc.sc_attacker.something_to_hide
								}
							}
						}
					}
					# Leading to Z-1: injury.
					triggered_desc = {
						trigger = { duel_will_end_in_my_death_trigger = no }
						desc = {
							first_valid = {
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:wait_and_hope }
									desc = single_combat.0031.desc.sc_attacker.wait_and_hope.injury
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:unsure_attack }
									desc = single_combat.0031.desc.sc_attacker.unsure_attack.injury
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:enthusiastic_onslaught }
									desc = single_combat.0031.desc.sc_attacker.enthusiastic_onslaught.injury
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:hail_mary }
									desc = single_combat.0031.desc.sc_attacker.hail_mary.injury
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:pocket_sand }
									desc = single_combat.0031.desc.sc_attacker.pocket_sand.injury
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:nut_em }
									desc = single_combat.0031.desc.sc_attacker.nut_em.injury
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:guard }
									desc = single_combat.0031.desc.sc_attacker.guard.injury
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:probing_attack }
									desc = single_combat.0031.desc.sc_attacker.probing_attack.injury
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:onslaught }
									desc = single_combat.0031.desc.sc_attacker.onslaught.injury
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:surprise_attack }
									desc = single_combat.0031.desc.sc_attacker.surprise_attack.injury
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:taunt }
									desc = single_combat.0031.desc.sc_attacker.taunt.injury
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:put_the_boot_in }
									desc = single_combat.0031.desc.sc_attacker.put_the_boot_in.injury
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:strict_guard }
									desc = single_combat.0031.desc.sc_attacker.strict_guard.injury
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:confident_attack }
									desc = single_combat.0031.desc.sc_attacker.confident_attack.injury
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:expert_onslaught }
									desc = single_combat.0031.desc.sc_attacker.expert_onslaught.injury
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:attempt_disarm }
									desc = single_combat.0031.desc.sc_attacker.attempt_disarm.injury
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:tire_opponent }
									desc = single_combat.0031.desc.sc_attacker.tire_opponent.injury
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:reason_you_suck_speech }
									desc = single_combat.0031.desc.sc_attacker.reason_you_suck_speech.injury
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:technique_from_legend }
									desc = single_combat.0031.desc.sc_attacker.technique_from_legend.injury
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:like_a_viper }
									desc = single_combat.0031.desc.sc_attacker.like_a_viper.injury
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:pocket_silver }
									desc = single_combat.0031.desc.sc_attacker.pocket_silver.injury
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:martial_voice }
									desc = single_combat.0031.desc.sc_attacker.martial_voice.injury
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:mocking_boast }
									desc = single_combat.0031.desc.sc_attacker.mocking_boast.injury
								}
								# No need for an is_that_a_crocodile, as it's never just an injury.
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:desert_warrior }
									desc = single_combat.0031.desc.sc_attacker.desert_warrior.injury
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:jungle_stalker }
									desc = single_combat.0031.desc.sc_attacker.jungle_stalker.injury
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:open_terrain_expert }
									desc = single_combat.0031.desc.sc_attacker.open_terrain_expert.injury
								}
								triggered_desc = {
									trigger = {
										scope:sc_attacker_last_move = flag:rough_terrain_expert
										scope:sc_defender.location = { rocky_locale_trigger = yes }
									}
									desc = single_combat.0031.desc.sc_attacker.rough_terrain_expert.injury.rocky
								}
								triggered_desc = {
									trigger = {
										scope:sc_attacker_last_move = flag:rough_terrain_expert
										scope:sc_defender.location = { terrain = wetlands }
									}
									desc = single_combat.0031.desc.sc_attacker.rough_terrain_expert.injury.boggy
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:forest_fighter }
									desc = single_combat.0031.desc.sc_attacker.forest_fighter.injury
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:raaargh }
									desc = single_combat.0031.desc.sc_attacker.raaargh.injury
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:hard_grit }
									desc = single_combat.0031.desc.sc_attacker.hard_grit.injury
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:feint_and_stab }
									desc = single_combat.0031.desc.sc_attacker.feint_and_stab.injury
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:butchery }
									desc = single_combat.0031.desc.sc_attacker.butchery.injury
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:stoic_veteran }
									desc = single_combat.0031.desc.sc_attacker.stoic_veteran.injury
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:blade_dance }
									desc = single_combat.0031.desc.sc_attacker.blade_dance.injury
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:wrath_of_highgod }
									desc = single_combat.0031.desc.sc_attacker.wrath_of_highgod.injury
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:hurt_me_better }
									desc = single_combat.0031.desc.sc_attacker.hurt_me_better.injury
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:special_fallback }
									desc = single_combat.0031.desc.sc_attacker.special_fallback.injury
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:something_to_hide }
									desc = single_combat.0031.desc.sc_attacker.something_to_hide.injury
								}
							}
						}
					}
					# Or Z-2: death.
					triggered_desc = {
						trigger = { duel_will_end_in_my_death_trigger = yes }
						desc = {
							first_valid = {
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:wait_and_hope }
									desc = single_combat.0031.desc.sc_attacker.wait_and_hope.fatality
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:unsure_attack }
									desc = single_combat.0031.desc.sc_attacker.unsure_attack.fatality
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:enthusiastic_onslaught }
									desc = single_combat.0031.desc.sc_attacker.enthusiastic_onslaught.fatality
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:hail_mary }
									desc = single_combat.0031.desc.sc_attacker.hail_mary.fatality
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:pocket_sand }
									desc = single_combat.0031.desc.sc_attacker.pocket_sand.fatality
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:nut_em }
									desc = single_combat.0031.desc.sc_attacker.nut_em.fatality
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:guard }
									desc = single_combat.0031.desc.sc_attacker.guard.fatality
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:probing_attack }
									desc = single_combat.0031.desc.sc_attacker.probing_attack.fatality
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:onslaught }
									desc = single_combat.0031.desc.sc_attacker.onslaught.fatality
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:surprise_attack }
									desc = single_combat.0031.desc.sc_attacker.surprise_attack.fatality
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:taunt }
									desc = single_combat.0031.desc.sc_attacker.taunt.fatality
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:put_the_boot_in }
									desc = single_combat.0031.desc.sc_attacker.put_the_boot_in.fatality
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:strict_guard }
									desc = single_combat.0031.desc.sc_attacker.strict_guard.fatality
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:confident_attack }
									desc = single_combat.0031.desc.sc_attacker.confident_attack.fatality
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:expert_onslaught }
									desc = single_combat.0031.desc.sc_attacker.expert_onslaught.fatality
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:attempt_disarm }
									desc = single_combat.0031.desc.sc_attacker.attempt_disarm.fatality
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:tire_opponent }
									desc = single_combat.0031.desc.sc_attacker.tire_opponent.fatality
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:reason_you_suck_speech }
									desc = single_combat.0031.desc.sc_attacker.reason_you_suck_speech.fatality
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:technique_from_legend }
									desc = single_combat.0031.desc.sc_attacker.technique_from_legend.fatality
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:like_a_viper }
									desc = single_combat.0031.desc.sc_attacker.like_a_viper.fatality
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:pocket_silver }
									desc = single_combat.0031.desc.sc_attacker.pocket_silver.fatality
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:martial_voice }
									desc = single_combat.0031.desc.sc_attacker.martial_voice.fatality
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:mocking_boast }
									desc = single_combat.0031.desc.sc_attacker.mocking_boast.fatality
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:is_that_a_crocodile }
									desc = single_combat.0031.desc.sc_attacker.is_that_a_crocodile.fatality
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:desert_warrior }
									desc = single_combat.0031.desc.sc_attacker.desert_warrior.fatality
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:jungle_stalker }
									desc = single_combat.0031.desc.sc_attacker.jungle_stalker.fatality
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:open_terrain_expert }
									desc = single_combat.0031.desc.sc_attacker.open_terrain_expert.fatality
								}
								triggered_desc = {
									trigger = {
										scope:sc_attacker_last_move = flag:rough_terrain_expert
										scope:sc_defender.location = { rocky_locale_trigger = yes }
									}
									desc = single_combat.0031.desc.sc_attacker.rough_terrain_expert.fatality.rocky
								}
								triggered_desc = {
									trigger = {
										scope:sc_attacker_last_move = flag:rough_terrain_expert
										scope:sc_defender.location = { terrain = wetlands }
									}
									desc = single_combat.0031.desc.sc_attacker.rough_terrain_expert.fatality.boggy
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:forest_fighter }
									desc = single_combat.0031.desc.sc_attacker.forest_fighter.fatality
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:raaargh }
									desc = single_combat.0031.desc.sc_attacker.raaargh.fatality
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:hard_grit }
									desc = single_combat.0031.desc.sc_attacker.hard_grit.fatality
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:feint_and_stab }
									desc = single_combat.0031.desc.sc_attacker.feint_and_stab.fatality
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:butchery }
									desc = single_combat.0031.desc.sc_attacker.butchery.fatality
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:stoic_veteran }
									desc = single_combat.0031.desc.sc_attacker.stoic_veteran.fatality
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:blade_dance }
									desc = single_combat.0031.desc.sc_attacker.blade_dance.fatality
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:wrath_of_highgod }
									desc = single_combat.0031.desc.sc_attacker.wrath_of_highgod.fatality
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:hurt_me_better }
									desc = single_combat.0031.desc.sc_attacker.hurt_me_better.fatality
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:special_fallback }
									desc = single_combat.0031.desc.sc_attacker.special_fallback.fatality
								}
								# No need for a something_to_hide, as it's never fatal.
							}
						}
					}
				}
			}
		}
	}
	theme = skull
	left_portrait = {
		character = scope:sc_loser
		animation = fear
	}
	right_portrait = {
		character = scope:sc_victor
		scripted_animation = duel_celebrate
	}
	# Background Logic
	override_background = {
		trigger = { scope:locale = flag:terrain_scope }
		reference = terrain_scope
	}
	override_background = {
		trigger = { scope:locale = flag:battlefield }
		reference = battlefield
	}
	override_background = {
		trigger = { scope:locale = flag:alley_night }
		reference = alley_night
	}
	override_background = {
		trigger = { scope:locale = flag:alley_day }
		reference = alley_day
	}
	override_background = {
		trigger = { scope:locale = flag:temple }
		reference = temple
	}
	override_background = {
		trigger = { scope:locale = flag:corridor_night }
		reference = corridor_night
	}
	override_background = {
		trigger = { scope:locale = flag:corridor_day }
		reference = corridor_day
	}
	override_background = {
		trigger = { scope:locale = flag:courtyard }
		reference = courtyard
	}
	override_background = {
		trigger = { scope:locale = flag:dungeon }
		reference = dungeon
	}
	override_background = {
		trigger = { scope:locale = flag:docks }
		reference = docks
	}
	override_background = {
		trigger = { scope:locale = flag:feast }
		reference = feast
	}
	override_background = {
		trigger = { scope:locale = flag:market }
		reference = market
	}
	override_background = {
		trigger = { scope:locale = flag:tavern }
		reference = tavern
	}
	override_background = {
		trigger = { scope:locale = flag:throne_room }
		reference = throne_room
	}
	override_background = {
		trigger = { scope:locale = flag:army_camp }
		reference = army_camp
	}

	immediate = {
		#Death/wounding enacted elsewhere.
		if = {
			limit = { duel_will_end_in_my_death_trigger = yes }
			show_as_tooltip = {
				single_combat_death_effect = yes
			}
		}
		else_if = {
			limit = { scope:fatality = flag:practice }
			# If we're only practicing, there's no harm done.
			custom_tooltip = single_combat.result.tt.practice_no_wounds
		}
		else = {
			show_as_tooltip = {
				increase_wounds_no_death_effect = { REASON = duel }
			}
		}
		# Add Tournament Trait XP
		if = {
			limit = { has_trait = tourney_participant }
			add_trait_xp = {
				trait = tourney_participant
				track = foot
				value = { 1 3 }
			}
		}
		#Acknowledge loss of temporary combat modifiers.
		custom_tooltip = single_combat.result.tt.temporary_modifiers_removed
		# Damage equipped artifacts for loser
		may_damage_artifact_effect = {
			TYPE = primary_armament
			CHANCE = 66 # 33% chance of no damage
			PERCENT = 15 # 5-15 percent of max durability lost
		}
		may_damage_artifact_effect = {
			TYPE = armor
			CHANCE = 66 # 33% chance of no damage
			PERCENT = 15 # 5-15 percent of max durability lost
		}
	}

	# I die!
	option = {
		# Standard death-scream.
		name = {
			trigger = { scope:death_rattle = flag:scream }
			text = single_combat.0031.a.scream
		}
		# Wordless death.
		name = {
			trigger = { scope:death_rattle = flag:wordless }
			text = single_combat.0031.a.wordless
		}
		# Muffled death.
		name = {
			trigger = { scope:death_rattle = flag:muffled }
			text = single_combat.0031.a.muffled
		}
		# Choking death.
		name = {
			trigger = { scope:death_rattle = flag:choking }
			text = single_combat.0031.a.choking
		}
		# Pleading death.
		name = {
			trigger = { scope:death_rattle = flag:pleading_screams }
			text = single_combat.0031.a.pleading
		}
		# Soulmate death.
		name = {
			trigger = { scope:death_rattle = flag:soulmate }
			text = single_combat.0031.a.soulmate
		}
		# Sinner death.
		name = {
			trigger = { scope:death_rattle = flag:sinner }
			text = single_combat.0031.a.sinner
		}
		# Saint death.
		name = {
			trigger = { scope:death_rattle = flag:saint }
			text = single_combat.0031.a.saint
		}
		# Legend death.
		name = {
			trigger = { scope:death_rattle = flag:legend }
			text = single_combat.0031.a.legend
		}
		# Valhalla death.
		name = {
			trigger = { scope:death_rattle = flag:valhalla }
			text = single_combat.0031.a.valhalla
		}
		# Best Friend death.
		name = {
			trigger = { scope:death_rattle = flag:best_friend }
			text = single_combat.0031.a.best_friend
		}
		# Killed by rival death.
		name = {
			trigger = { scope:death_rattle = flag:killed_by_rival }
			text = single_combat.0031.a.killed_by_rival
		}
		# Killed by nemesis death.
		name = {
			trigger = { scope:death_rattle = flag:killed_by_nemesis }
			text = single_combat.0031.a.killed_by_nemesis
		}
		# Killed by spouse death.
		name = {
			trigger = { scope:death_rattle = flag:killed_by_spouse }
			text = single_combat.0031.a.killed_by_spouse
		}
		# Killed by your HoF death.
		name = {
			trigger = { scope:death_rattle = flag:killed_by_your_head_of_faith }
			text = single_combat.0031.a.killed_by_your_head_of_faith
		}
		# Killed by another HoF death.
		name = {
			trigger = { scope:death_rattle = flag:killed_by_another_head_of_faith }
			text = single_combat.0031.a.killed_by_another_head_of_faith
		}
		# Killed by cultural head death.
		name = {
			trigger = { scope:death_rattle = flag:killed_by_cultural_head }
			text = single_combat.0031.a.killed_by_cultural_head
		}
		# Killed by house head death.
		name = {
			trigger = { scope:death_rattle = flag:killed_by_house_head }
			text = single_combat.0031.a.killed_by_house_head
		}
		# Killed by dynasty head death.
		name = {
			trigger = { scope:death_rattle = flag:killed_by_dynasty_head }
			text = single_combat.0031.a.killed_by_dynasty_head
		}
		# Killed by close or extended family death.
		name = {
			trigger = { scope:death_rattle = flag:killed_by_close_or_extended_family }
			text = single_combat.0031.a.killed_by_close_or_extended_family
		}
		# Killed by friend or lover.
		name = {
			trigger = { scope:death_rattle = flag:killed_by_friend_or_lover }
			text = single_combat.0031.a.killed_by_friend_or_lover
		}
		# Killed by soulmate.
		name = {
			trigger = { scope:death_rattle = flag:killed_by_soulmate }
			text = single_combat.0031.a.killed_by_soulmate
		}
		# Killed by best friend.
		name = {
			trigger = { scope:death_rattle = flag:killed_by_best_friend }
			text = single_combat.0031.a.killed_by_best_friend
		}
		trigger = { duel_will_end_in_my_death_trigger = yes }

		#Confirmation of the duel ending & explanation.
		sce_loser_end_result_tooltip_effect = yes
		
		#No stress for single-option events.
		#No AI chance needed for single-option events.
	}

	# Yield! Yield!
	option = {
		name = single_combat.0031.b
		trigger = { duel_will_end_in_my_death_trigger = no }

		#Confirmation of the duel ending & explanation.
		sce_loser_end_result_tooltip_effect = yes

		#No stress involved, as we don't want to force rivalries out of every duel.
		ai_chance = {
			base = 100
			ai_value_modifier = {
				ai_vengefulness = -0.75
				ai_energy = -0.25
			}
		}
	}

	# You will rue the day you messed with scope:sc_loser!
	option = {
		name = single_combat.0031.c
		trigger = { duel_will_end_in_my_death_trigger = no }

		#Confirmation of the duel ending & explanation.
		sce_loser_end_result_tooltip_effect = yes
		#Aaaaand set-up some rivalry.
		if = {
			limit = {
				NOT = { has_relation_rival = scope:sc_victor }
			}
			progress_towards_rival_effect = {
				REASON = rival_lost_duel
				CHARACTER = scope:sc_victor
				OPINION = 0
			}
		}
		# Consolation prize for being a sore loser to a rival.
		else = { add_stress = minor_stress_loss }

		stress_impact = {
			arrogant = minor_stress_impact_loss
			vengeful = medium_stress_impact_loss
			humble = minor_stress_impact_gain
			forgiving = minor_stress_impact_gain
		}
		ai_chance = {
			base = 100
			ai_value_modifier = {
				ai_vengefulness = 0.5
				ai_energy = 0.25
			}
			modifier = {	#Weight up for stress.
				add = 10
				has_trait = arrogant
			}
			modifier = {	#Weight up for stress.
				add = 20
				has_trait = vengeful
			}
			modifier = {	#Weight down for stress.
				add = -10
				has_trait = humble
			}
			modifier = {	#Weight down for stress.
				add = -20
				has_trait = forgiving
			}
		}
	}

	after = {
		if = { #If dueled an AI, clear everything
			limit = {
				scope:sc_victor = { is_ai = yes }
			}
			single_combat_clean_shirtlessness_effect = {
				ATTACKER = scope:sc_loser
				DEFENDER = scope:sc_victor
			}
		}
		else_if = { #If both players, clear own only
			limit = { is_ai = no }
			if = {
				limit = { has_character_flag = single_combat_stripped_to_waist }
				remove_character_flag = single_combat_stripped_to_waist
			}
			else_if = { # If a player who dueled a player, clear only own flags
				limit = { has_character_flag = single_combat_duel_armor }
				remove_character_flag = single_combat_duel_armor
			}
		}		
		if = { #If dueled an AI, clear everything
			limit = {
				scope:sc_victor = { is_ai = yes }
			}
			single_combat_clean_temp_weapon_effect = {
				ATTACKER = scope:sc_loser
				DEFENDER = scope:sc_victor
			}
		}
		else_if = { #If both players, clear own only
			limit = { is_ai = no }
			if = { #check for variables set up in set_temporary_signature_weapon
				limit = {
					OR = {
						has_variable = og_signature_weapon
						has_variable = temporary_signature_weapon
					}
				}
				if = { #remove the signature_weapon variable if the character didn't have anything before
					limit = {
						var:og_signature_weapon = flag:no_signature_weapon_yet
					}
					remove_variable = signature_weapon
				}
				else = { #restore the original signature_weapon
					set_variable = {
						name = signature_weapon
						value = var:og_signature_weapon 
					}
				}
				#remove all variables set up in set_temporary_signature_weapon
				remove_variable = temporary_signature_weapon
				remove_variable = og_signature_weapon
			}
		}
	}
}

#	scope:sc_victor's confirmation event.
single_combat.0041 = {
	type = character_event
	window = duel_event
	title = single_combat.0041.t
	desc = {
		first_valid = {
			# Are we in scope:sc_defender's POV?
			triggered_desc = {
				trigger = { this = scope:sc_defender }
				desc = {
					# Our POV tells us that we did X.
					triggered_desc = {
						#This trigger should always exist, but the desc structure is required for code reasons.
						trigger = { always = yes }
						desc = {
							first_valid = {
								triggered_desc = {
									trigger = { scope:sc_defender_last_move = flag:wait_and_hope }
									desc = single_combat.0041.desc.sc_defender.wait_and_hope
								}
								triggered_desc = {
									trigger = { scope:sc_defender_last_move = flag:unsure_attack }
									desc = single_combat.0041.desc.sc_defender.unsure_attack
								}
								triggered_desc = {
									trigger = { scope:sc_defender_last_move = flag:enthusiastic_onslaught }
									desc = single_combat.0041.desc.sc_defender.enthusiastic_onslaught
								}
								triggered_desc = {
									trigger = { scope:sc_defender_last_move = flag:hail_mary }
									desc = single_combat.0041.desc.sc_defender.hail_mary
								}
								triggered_desc = {
									trigger = { scope:sc_defender_last_move = flag:pocket_sand }
									desc = single_combat.0041.desc.sc_defender.pocket_sand
								}
								triggered_desc = {
									trigger = { scope:sc_defender_last_move = flag:nut_em }
									desc = single_combat.0041.desc.sc_defender.nut_em
								}
								triggered_desc = {
									trigger = { scope:sc_defender_last_move = flag:guard }
									desc = single_combat.0041.desc.sc_defender.guard
								}
								triggered_desc = {
									trigger = { scope:sc_defender_last_move = flag:probing_attack }
									desc = single_combat.0041.desc.sc_defender.probing_attack
								}
								triggered_desc = {
									trigger = { scope:sc_defender_last_move = flag:onslaught }
									desc = single_combat.0041.desc.sc_defender.onslaught
								}
								triggered_desc = {
									trigger = { scope:sc_defender_last_move = flag:surprise_attack }
									desc = single_combat.0041.desc.sc_defender.surprise_attack
								}
								triggered_desc = {
									trigger = { scope:sc_defender_last_move = flag:taunt }
									desc = single_combat.0041.desc.sc_defender.taunt
								}
								triggered_desc = {
									trigger = { scope:sc_defender_last_move = flag:put_the_boot_in }
									desc = single_combat.0041.desc.sc_defender.put_the_boot_in
								}
								triggered_desc = {
									trigger = { scope:sc_defender_last_move = flag:strict_guard }
									desc = single_combat.0041.desc.sc_defender.strict_guard
								}
								triggered_desc = {
									trigger = { scope:sc_defender_last_move = flag:confident_attack }
									desc = single_combat.0041.desc.sc_defender.confident_attack
								}
								triggered_desc = {
									trigger = { scope:sc_defender_last_move = flag:expert_onslaught }
									desc = single_combat.0041.desc.sc_defender.expert_onslaught
								}
								triggered_desc = {
									trigger = { scope:sc_defender_last_move = flag:attempt_disarm }
									desc = single_combat.0041.desc.sc_defender.attempt_disarm
								}
								triggered_desc = {
									trigger = { scope:sc_defender_last_move = flag:tire_opponent }
									desc = single_combat.0041.desc.sc_defender.tire_opponent
								}
								triggered_desc = {
									trigger = { scope:sc_defender_last_move = flag:reason_you_suck_speech }
									desc = single_combat.0041.desc.sc_defender.reason_you_suck_speech
								}
								triggered_desc = {
									trigger = { scope:sc_defender_last_move = flag:technique_from_legend }
									desc = single_combat.0041.desc.sc_defender.technique_from_legend
								}
								triggered_desc = {
									trigger = { scope:sc_defender_last_move = flag:like_a_viper }
									desc = single_combat.0041.desc.sc_defender.like_a_viper
								}
								triggered_desc = {
									trigger = { scope:sc_defender_last_move = flag:pocket_silver }
									desc = single_combat.0041.desc.sc_defender.pocket_silver
								}
								triggered_desc = {
									trigger = { scope:sc_defender_last_move = flag:martial_voice }
									desc = single_combat.0041.desc.sc_defender.martial_voice
								}
								triggered_desc = {
									trigger = { scope:sc_defender_last_move = flag:mocking_boast }
									desc = single_combat.0041.desc.sc_defender.mocking_boast
								}
								triggered_desc = {
									trigger = { scope:sc_defender_last_move = flag:is_that_a_crocodile }
									desc = single_combat.0041.desc.sc_defender.is_that_a_crocodile
								}
								triggered_desc = {
									trigger = { scope:sc_defender_last_move = flag:desert_warrior }
									desc = single_combat.0041.desc.sc_defender.desert_warrior
								}
								triggered_desc = {
									trigger = { scope:sc_defender_last_move = flag:jungle_stalker }
									desc = single_combat.0041.desc.sc_defender.jungle_stalker
								}
								triggered_desc = {
									trigger = { scope:sc_defender_last_move = flag:open_terrain_expert }
									desc = single_combat.0041.desc.sc_defender.open_terrain_expert
								}
								triggered_desc = {
									trigger = { scope:sc_defender_last_move = flag:rough_terrain_expert }
									desc = single_combat.0041.desc.sc_defender.rough_terrain_expert
								}
								triggered_desc = {
									trigger = { scope:sc_defender_last_move = flag:forest_fighter }
									desc = single_combat.0041.desc.sc_defender.forest_fighter
								}
								triggered_desc = {
									trigger = { scope:sc_defender_last_move = flag:raaargh }
									desc = single_combat.0041.desc.sc_defender.raaargh
								}
								triggered_desc = {
									trigger = { scope:sc_defender_last_move = flag:hard_grit }
									desc = single_combat.0041.desc.sc_defender.hard_grit
								}
								triggered_desc = {
									trigger = { scope:sc_defender_last_move = flag:feint_and_stab }
									desc = single_combat.0041.desc.sc_defender.feint_and_stab
								}
								triggered_desc = {
									trigger = { scope:sc_defender_last_move = flag:butchery }
									desc = single_combat.0041.desc.sc_defender.butchery
								}
								triggered_desc = {
									trigger = { scope:sc_defender_last_move = flag:stoic_veteran }
									desc = single_combat.0041.desc.sc_defender.stoic_veteran
								}
								triggered_desc = {
									trigger = { scope:sc_defender_last_move = flag:blade_dance }
									desc = single_combat.0041.desc.sc_defender.blade_dance
								}
								triggered_desc = {
									trigger = { scope:sc_defender_last_move = flag:wrath_of_highgod }
									desc = single_combat.0041.desc.sc_defender.wrath_of_highgod
								}
								triggered_desc = {
									trigger = { scope:sc_defender_last_move = flag:hurt_me_better }
									desc = single_combat.0041.desc.sc_defender.hurt_me_better
								}
								triggered_desc = {
									trigger = { scope:sc_defender_last_move = flag:special_fallback }
									desc = single_combat.0041.desc.sc_defender.special_fallback
								}
								triggered_desc = {
									trigger = { scope:sc_defender_last_move = flag:something_to_hide }
									desc = single_combat.0041.desc.sc_defender.something_to_hide
								}
							}
						}
					}
					# And scope:sc_attacker failed to counter with Y.
					triggered_desc = {
						#This trigger should always exist, but the desc structure is required for code reasons.
						trigger = { always = yes }
						desc = {
							first_valid = {
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:wait_and_hope }
									desc = single_combat.0041.desc.opponent_response.wait_and_hope
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:unsure_attack }
									desc = single_combat.0041.desc.opponent_response.unsure_attack
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:enthusiastic_onslaught }
									desc = single_combat.0041.desc.opponent_response.enthusiastic_onslaught
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:hail_mary }
									desc = single_combat.0041.desc.opponent_response.hail_mary
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:pocket_sand }
									desc = single_combat.0041.desc.opponent_response.pocket_sand
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:nut_em }
									desc = single_combat.0041.desc.opponent_response.nut_em
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:guard }
									desc = single_combat.0041.desc.opponent_response.guard
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:probing_attack }
									desc = single_combat.0041.desc.opponent_response.probing_attack
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:onslaught }
									desc = single_combat.0041.desc.opponent_response.onslaught
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:surprise_attack }
									desc = single_combat.0041.desc.opponent_response.surprise_attack
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:taunt }
									desc = single_combat.0041.desc.opponent_response.taunt
								}
								triggered_desc = {
									trigger = {
										scope:sc_attacker_last_move = flag:put_the_boot_in
										has_trait = one_legged
									}
									desc = single_combat.0041.desc.opponent_response.put_the_boot_in.peg_leg
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:put_the_boot_in }
									desc = single_combat.0041.desc.opponent_response.put_the_boot_in.fallback
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:strict_guard }
									desc = single_combat.0041.desc.opponent_response.strict_guard
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:confident_attack }
									desc = single_combat.0041.desc.opponent_response.confident_attack
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:expert_onslaught }
									desc = single_combat.0041.desc.opponent_response.expert_onslaught
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:attempt_disarm }
									desc = single_combat.0041.desc.opponent_response.attempt_disarm
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:tire_opponent }
									desc = single_combat.0041.desc.opponent_response.tire_opponent
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:reason_you_suck_speech }
									desc = single_combat.0041.desc.opponent_response.reason_you_suck_speech
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:technique_from_legend }
									desc = single_combat.0041.desc.opponent_response.technique_from_legend
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:like_a_viper }
									desc = single_combat.0041.desc.opponent_response.like_a_viper
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:pocket_silver }
									desc = single_combat.0041.desc.opponent_response.pocket_silver
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:martial_voice }
									desc = single_combat.0041.desc.opponent_response.martial_voice
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:mocking_boast }
									desc = single_combat.0041.desc.opponent_response.mocking_boast
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:is_that_a_crocodile }
									desc = single_combat.0041.desc.opponent_response.is_that_a_crocodile
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:desert_warrior }
									desc = single_combat.0041.desc.opponent_response.desert_warrior
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:jungle_stalker }
									desc = single_combat.0041.desc.opponent_response.jungle_stalker
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:open_terrain_expert }
									desc = single_combat.0041.desc.opponent_response.open_terrain_expert
								}
								triggered_desc = {
									trigger = {
										scope:sc_attacker_last_move = flag:rough_terrain_expert
										scope:sc_defender.location = { rocky_locale_trigger = yes }
									}
									desc = single_combat.0041.desc.opponent_response.rough_terrain_expert.rocky
								}
								triggered_desc = {
									trigger = {
										scope:sc_attacker_last_move = flag:rough_terrain_expert
										scope:sc_defender.location = { terrain = wetlands }
									}
									desc = single_combat.0041.desc.opponent_response.rough_terrain_expert.boggy
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:forest_fighter }
									desc = single_combat.0041.desc.opponent_response.forest_fighter
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:raaargh }
									desc = single_combat.0041.desc.opponent_response.raaargh
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:hard_grit }
									desc = single_combat.0041.desc.opponent_response.hard_grit
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:feint_and_stab }
									desc = single_combat.0041.desc.opponent_response.feint_and_stab
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:butchery }
									desc = single_combat.0041.desc.opponent_response.butchery
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:stoic_veteran }
									desc = single_combat.0041.desc.opponent_response.stoic_veteran
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:blade_dance }
									desc = single_combat.0041.desc.opponent_response.blade_dance
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:wrath_of_highgod }
									desc = single_combat.0041.desc.opponent_response.wrath_of_highgod
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:hurt_me_better }
									desc = single_combat.0041.desc.opponent_response.hurt_me_better
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:special_fallback }
									desc = single_combat.0041.desc.opponent_response.special_fallback
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:something_to_hide }
									desc = single_combat.0041.desc.opponent_response.something_to_hide
								}
							}
						}
					}
					# Leading to Z-1: injury.
					triggered_desc = {
						trigger = { duel_will_end_in_opponent_death_trigger = no }
						desc = {
							first_valid = {
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:wait_and_hope }
									desc = single_combat.0041.desc.opponent_response.wait_and_hope.injury
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:unsure_attack }
									desc = single_combat.0041.desc.opponent_response.unsure_attack.injury
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:enthusiastic_onslaught }
									desc = single_combat.0041.desc.opponent_response.enthusiastic_onslaught.injury
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:hail_mary }
									desc = single_combat.0041.desc.opponent_response.hail_mary.injury
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:pocket_sand }
									desc = single_combat.0041.desc.opponent_response.pocket_sand.injury
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:nut_em }
									desc = single_combat.0041.desc.opponent_response.nut_em.injury
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:guard }
									desc = single_combat.0041.desc.opponent_response.guard.injury
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:probing_attack }
									desc = single_combat.0041.desc.opponent_response.probing_attack.injury
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:onslaught }
									desc = single_combat.0041.desc.opponent_response.onslaught.injury
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:surprise_attack }
									desc = single_combat.0041.desc.opponent_response.surprise_attack.injury
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:taunt }
									desc = single_combat.0041.desc.opponent_response.taunt.injury
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:put_the_boot_in }
									desc = single_combat.0041.desc.opponent_response.put_the_boot_in.injury
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:strict_guard }
									desc = single_combat.0041.desc.opponent_response.strict_guard.injury
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:confident_attack }
									desc = single_combat.0041.desc.opponent_response.confident_attack.injury
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:expert_onslaught }
									desc = single_combat.0041.desc.opponent_response.expert_onslaught.injury
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:attempt_disarm }
									desc = single_combat.0041.desc.opponent_response.attempt_disarm.injury
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:tire_opponent }
									desc = single_combat.0041.desc.opponent_response.tire_opponent.injury
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:reason_you_suck_speech }
									desc = single_combat.0041.desc.opponent_response.reason_you_suck_speech.injury
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:technique_from_legend }
									desc = single_combat.0041.desc.opponent_response.technique_from_legend.injury
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:like_a_viper }
									desc = single_combat.0041.desc.opponent_response.like_a_viper.injury
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:pocket_silver }
									desc = single_combat.0041.desc.opponent_response.pocket_silver.injury
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:martial_voice }
									desc = single_combat.0041.desc.opponent_response.martial_voice.injury
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:mocking_boast }
									desc = single_combat.0041.desc.opponent_response.mocking_boast.injury
								}
								# No need for an is_that_a_crocodile, as it's never just an injury.
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:desert_warrior }
									desc = single_combat.0041.desc.opponent_response.desert_warrior.injury
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:jungle_stalker }
									desc = single_combat.0041.desc.opponent_response.jungle_stalker.injury
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:open_terrain_expert }
									desc = single_combat.0041.desc.opponent_response.open_terrain_expert.injury
								}
								triggered_desc = {
									trigger = {
										scope:sc_attacker_last_move = flag:rough_terrain_expert
										scope:sc_defender.location = { rocky_locale_trigger = yes }
									}
									desc = single_combat.0041.desc.opponent_response.rough_terrain_expert.injury.rocky
								}
								triggered_desc = {
									trigger = {
										scope:sc_attacker_last_move = flag:rough_terrain_expert
										scope:sc_defender.location = { terrain = wetlands }
									}
									desc = single_combat.0041.desc.opponent_response.rough_terrain_expert.injury.boggy
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:forest_fighter }
									desc = single_combat.0041.desc.opponent_response.forest_fighter.injury
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:raaargh }
									desc = single_combat.0041.desc.opponent_response.raaargh.injury
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:hard_grit }
									desc = single_combat.0041.desc.opponent_response.hard_grit.injury
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:feint_and_stab }
									desc = single_combat.0041.desc.opponent_response.feint_and_stab.injury
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:butchery }
									desc = single_combat.0041.desc.opponent_response.butchery.injury
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:stoic_veteran }
									desc = single_combat.0041.desc.opponent_response.stoic_veteran.injury
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:blade_dance }
									desc = single_combat.0041.desc.opponent_response.blade_dance.injury
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:wrath_of_highgod }
									desc = single_combat.0041.desc.opponent_response.wrath_of_highgod.injury
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:hurt_me_better }
									desc = single_combat.0041.desc.opponent_response.hurt_me_better.injury
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:special_fallback }
									desc = single_combat.0041.desc.opponent_response.special_fallback.injury
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:something_to_hide }
									desc = single_combat.0041.desc.opponent_response.something_to_hide.injury
								}
							}
						}
					}
					# Or Z-2: death.
					triggered_desc = {
						trigger = { duel_will_end_in_opponent_death_trigger = yes }
						desc = {
							first_valid = {
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:wait_and_hope }
									desc = single_combat.0041.desc.opponent_response.wait_and_hope.fatality
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:unsure_attack }
									desc = single_combat.0041.desc.opponent_response.unsure_attack.fatality
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:enthusiastic_onslaught }
									desc = single_combat.0041.desc.opponent_response.enthusiastic_onslaught.fatality
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:hail_mary }
									desc = single_combat.0041.desc.opponent_response.hail_mary.fatality
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:pocket_sand }
									desc = single_combat.0041.desc.opponent_response.pocket_sand.fatality
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:nut_em }
									desc = single_combat.0041.desc.opponent_response.nut_em.fatality
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:guard }
									desc = single_combat.0041.desc.opponent_response.guard.fatality
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:probing_attack }
									desc = single_combat.0041.desc.opponent_response.probing_attack.fatality
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:onslaught }
									desc = single_combat.0041.desc.opponent_response.onslaught.fatality
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:surprise_attack }
									desc = single_combat.0041.desc.opponent_response.surprise_attack.fatality
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:taunt }
									desc = single_combat.0041.desc.opponent_response.taunt.fatality
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:put_the_boot_in }
									desc = single_combat.0041.desc.opponent_response.put_the_boot_in.fatality
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:strict_guard }
									desc = single_combat.0041.desc.opponent_response.strict_guard.fatality
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:confident_attack }
									desc = single_combat.0041.desc.opponent_response.confident_attack.fatality
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:expert_onslaught }
									desc = single_combat.0041.desc.opponent_response.expert_onslaught.fatality
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:attempt_disarm }
									desc = single_combat.0041.desc.opponent_response.attempt_disarm.fatality
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:tire_opponent }
									desc = single_combat.0041.desc.opponent_response.tire_opponent.fatality
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:reason_you_suck_speech }
									desc = single_combat.0041.desc.opponent_response.reason_you_suck_speech.fatality
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:technique_from_legend }
									desc = single_combat.0041.desc.opponent_response.technique_from_legend.fatality
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:like_a_viper }
									desc = single_combat.0041.desc.opponent_response.like_a_viper.fatality
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:pocket_silver }
									desc = single_combat.0041.desc.opponent_response.pocket_silver.fatality
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:martial_voice }
									desc = single_combat.0041.desc.opponent_response.martial_voice.fatality
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:mocking_boast }
									desc = single_combat.0041.desc.opponent_response.mocking_boast.fatality
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:is_that_a_crocodile }
									desc = single_combat.0041.desc.opponent_response.is_that_a_crocodile.fatality
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:desert_warrior }
									desc = single_combat.0041.desc.opponent_response.desert_warrior.fatality
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:jungle_stalker }
									desc = single_combat.0041.desc.opponent_response.jungle_stalker.fatality
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:open_terrain_expert }
									desc = single_combat.0041.desc.opponent_response.open_terrain_expert.fatality
								}
								triggered_desc = {
									trigger = {
										scope:sc_attacker_last_move = flag:rough_terrain_expert
										scope:sc_defender.location = { rocky_locale_trigger = yes }
									}
									desc = single_combat.0041.desc.opponent_response.rough_terrain_expert.fatality.rocky
								}
								triggered_desc = {
									trigger = {
										scope:sc_attacker_last_move = flag:rough_terrain_expert
										scope:sc_defender.location = { terrain = wetlands }
									}
									desc = single_combat.0041.desc.opponent_response.rough_terrain_expert.fatality.boggy
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:forest_fighter }
									desc = single_combat.0041.desc.opponent_response.forest_fighter.fatality
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:raaargh }
									desc = single_combat.0041.desc.opponent_response.raaargh.fatality
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:hard_grit }
									desc = single_combat.0041.desc.opponent_response.hard_grit.fatality
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:feint_and_stab }
									desc = single_combat.0041.desc.opponent_response.feint_and_stab.fatality
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:butchery }
									desc = single_combat.0041.desc.opponent_response.butchery.fatality
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:stoic_veteran }
									desc = single_combat.0041.desc.opponent_response.stoic_veteran.fatality
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:blade_dance }
									desc = single_combat.0041.desc.opponent_response.blade_dance.fatality
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:wrath_of_highgod }
									desc = single_combat.0041.desc.opponent_response.wrath_of_highgod.fatality
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:hurt_me_better }
									desc = single_combat.0041.desc.opponent_response.hurt_me_better.fatality
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:special_fallback }
									desc = single_combat.0041.desc.opponent_response.special_fallback.fatality
								}
								# No need for a something_to_hide, as it's never fatal.
							}
						}
					}
				}
			}
			# Or scope:sc_attacker's?
			triggered_desc = {
				trigger = { this = scope:sc_attacker }
				desc = {
					# Our POV tells us that we went straight in with Y.
					triggered_desc = {
						#This trigger should always exist, but the desc structure is required for code reasons.
						trigger = { always = yes }
						desc = {
							first_valid = {
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:wait_and_hope }
									desc = single_combat.0041.desc.sc_attacker.wait_and_hope
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:unsure_attack }
									desc = single_combat.0041.desc.sc_attacker.unsure_attack
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:enthusiastic_onslaught }
									desc = single_combat.0041.desc.sc_attacker.enthusiastic_onslaught
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:hail_mary }
									desc = single_combat.0041.desc.sc_attacker.hail_mary
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:pocket_sand }
									desc = single_combat.0041.desc.sc_attacker.pocket_sand
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:nut_em }
									desc = single_combat.0041.desc.sc_attacker.nut_em
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:guard }
									desc = single_combat.0041.desc.sc_attacker.guard
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:probing_attack }
									desc = single_combat.0041.desc.sc_attacker.probing_attack
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:onslaught }
									desc = single_combat.0041.desc.sc_attacker.onslaught
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:surprise_attack }
									desc = single_combat.0041.desc.sc_attacker.surprise_attack
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:taunt }
									desc = single_combat.0041.desc.sc_attacker.taunt
								}
								triggered_desc = {
									trigger = {
										scope:sc_attacker_last_move = flag:put_the_boot_in
										has_trait = one_legged
									}
									desc = single_combat.0041.desc.sc_attacker.put_the_boot_in.peg_leg
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:put_the_boot_in }
									desc = single_combat.0041.desc.sc_attacker.put_the_boot_in.fallback
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:strict_guard }
									desc = single_combat.0041.desc.sc_attacker.strict_guard
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:confident_attack }
									desc = single_combat.0041.desc.sc_attacker.confident_attack
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:expert_onslaught }
									desc = single_combat.0041.desc.sc_attacker.expert_onslaught
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:attempt_disarm }
									desc = single_combat.0041.desc.sc_attacker.attempt_disarm
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:tire_opponent }
									desc = single_combat.0041.desc.sc_attacker.tire_opponent
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:reason_you_suck_speech }
									desc = single_combat.0041.desc.sc_attacker.reason_you_suck_speech
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:technique_from_legend }
									desc = single_combat.0041.desc.sc_attacker.technique_from_legend
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:like_a_viper }
									desc = single_combat.0041.desc.sc_attacker.like_a_viper
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:pocket_silver }
									desc = single_combat.0041.desc.sc_attacker.pocket_silver
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:martial_voice }
									desc = single_combat.0041.desc.sc_attacker.martial_voice
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:mocking_boast }
									desc = single_combat.0041.desc.sc_attacker.mocking_boast
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:is_that_a_crocodile }
									desc = single_combat.0041.desc.sc_attacker.is_that_a_crocodile
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:desert_warrior }
									desc = single_combat.0041.desc.sc_attacker.desert_warrior
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:jungle_stalker }
									desc = single_combat.0041.desc.sc_attacker.jungle_stalker
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:open_terrain_expert }
									desc = single_combat.0041.desc.sc_attacker.open_terrain_expert
								}
								triggered_desc = {
									trigger = {
										scope:sc_attacker_last_move = flag:rough_terrain_expert
										scope:sc_defender.location = { rocky_locale_trigger = yes }
									}
									desc = single_combat.0041.desc.sc_attacker.rough_terrain_expert.rocky
								}
								triggered_desc = {
									trigger = {
										scope:sc_attacker_last_move = flag:rough_terrain_expert
										scope:sc_defender.location = { terrain = wetlands }
									}
									desc = single_combat.0041.desc.sc_attacker.rough_terrain_expert.boggy
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:forest_fighter }
									desc = single_combat.0041.desc.sc_attacker.forest_fighter
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:raaargh }
									desc = single_combat.0041.desc.sc_attacker.raaargh
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:hard_grit }
									desc = single_combat.0041.desc.sc_attacker.hard_grit
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:feint_and_stab }
									desc = single_combat.0041.desc.sc_attacker.feint_and_stab
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:butchery }
									desc = single_combat.0041.desc.sc_attacker.butchery
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:stoic_veteran }
									desc = single_combat.0041.desc.sc_attacker.stoic_veteran
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:blade_dance }
									desc = single_combat.0041.desc.sc_attacker.blade_dance
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:wrath_of_highgod }
									desc = single_combat.0041.desc.sc_attacker.wrath_of_highgod
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:hurt_me_better }
									desc = single_combat.0041.desc.sc_attacker.hurt_me_better
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:special_fallback }
									desc = single_combat.0041.desc.sc_attacker.special_fallback
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:something_to_hide }
									desc = single_combat.0041.desc.sc_attacker.something_to_hide
								}
							}
						}
					}
					# Leading to Z-1: injury.
					triggered_desc = {
						trigger = { duel_will_end_in_opponent_death_trigger = no }
						desc = {
							first_valid = {
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:wait_and_hope }
									desc = single_combat.0041.desc.sc_attacker.wait_and_hope.injury
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:unsure_attack }
									desc = single_combat.0041.desc.sc_attacker.unsure_attack.injury
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:enthusiastic_onslaught }
									desc = single_combat.0041.desc.sc_attacker.enthusiastic_onslaught.injury
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:hail_mary }
									desc = single_combat.0041.desc.sc_attacker.hail_mary.injury
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:pocket_sand }
									desc = single_combat.0041.desc.sc_attacker.pocket_sand.injury
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:nut_em }
									desc = single_combat.0041.desc.sc_attacker.nut_em.injury
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:guard }
									desc = single_combat.0041.desc.sc_attacker.guard.injury
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:probing_attack }
									desc = single_combat.0041.desc.sc_attacker.probing_attack.injury
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:onslaught }
									desc = single_combat.0041.desc.sc_attacker.onslaught.injury
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:surprise_attack }
									desc = single_combat.0041.desc.sc_attacker.surprise_attack.injury
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:taunt }
									desc = single_combat.0041.desc.sc_attacker.taunt.injury
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:put_the_boot_in }
									desc = single_combat.0041.desc.sc_attacker.put_the_boot_in.injury
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:strict_guard }
									desc = single_combat.0041.desc.sc_attacker.strict_guard.injury
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:confident_attack }
									desc = single_combat.0041.desc.sc_attacker.confident_attack.injury
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:expert_onslaught }
									desc = single_combat.0041.desc.sc_attacker.expert_onslaught.injury
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:attempt_disarm }
									desc = single_combat.0041.desc.sc_attacker.attempt_disarm.injury
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:tire_opponent }
									desc = single_combat.0041.desc.sc_attacker.tire_opponent.injury
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:reason_you_suck_speech }
									desc = single_combat.0041.desc.sc_attacker.reason_you_suck_speech.injury
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:technique_from_legend }
									desc = single_combat.0041.desc.sc_attacker.technique_from_legend.injury
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:like_a_viper }
									desc = single_combat.0041.desc.sc_attacker.like_a_viper.injury
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:pocket_silver }
									desc = single_combat.0041.desc.sc_attacker.pocket_silver.injury
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:martial_voice }
									desc = single_combat.0041.desc.sc_attacker.martial_voice.injury
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:mocking_boast }
									desc = single_combat.0041.desc.sc_attacker.mocking_boast.injury
								}
								# No need for an is_that_a_crocodile, as it's never just an injury.
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:desert_warrior }
									desc = single_combat.0041.desc.sc_attacker.desert_warrior.injury
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:jungle_stalker }
									desc = single_combat.0041.desc.sc_attacker.jungle_stalker.injury
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:open_terrain_expert }
									desc = single_combat.0041.desc.sc_attacker.open_terrain_expert.injury
								}
								triggered_desc = {
									trigger = {
										scope:sc_attacker_last_move = flag:rough_terrain_expert
										scope:sc_defender.location = { rocky_locale_trigger = yes }
									}
									desc = single_combat.0041.desc.sc_attacker.rough_terrain_expert.injury.rocky
								}
								triggered_desc = {
									trigger = {
										scope:sc_attacker_last_move = flag:rough_terrain_expert
										scope:sc_defender.location = { terrain = wetlands }
									}
									desc = single_combat.0041.desc.sc_attacker.rough_terrain_expert.injury.boggy
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:forest_fighter }
									desc = single_combat.0041.desc.sc_attacker.forest_fighter.injury
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:raaargh }
									desc = single_combat.0041.desc.sc_attacker.raaargh.injury
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:hard_grit }
									desc = single_combat.0041.desc.sc_attacker.hard_grit.injury
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:feint_and_stab }
									desc = single_combat.0041.desc.sc_attacker.feint_and_stab.injury
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:butchery }
									desc = single_combat.0041.desc.sc_attacker.butchery.injury
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:stoic_veteran }
									desc = single_combat.0041.desc.sc_attacker.stoic_veteran.injury
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:blade_dance }
									desc = single_combat.0041.desc.sc_attacker.blade_dance.injury
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:wrath_of_highgod }
									desc = single_combat.0041.desc.sc_attacker.wrath_of_highgod.injury
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:hurt_me_better }
									desc = single_combat.0041.desc.sc_attacker.hurt_me_better.injury
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:special_fallback }
									desc = single_combat.0041.desc.sc_attacker.special_fallback.injury
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:something_to_hide }
									desc = single_combat.0041.desc.sc_attacker.something_to_hide.injury
								}
							}
						}
					}
					# Or Z-2: death.
					triggered_desc = {
						trigger = { duel_will_end_in_opponent_death_trigger = yes }
						desc = {
							first_valid = {
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:wait_and_hope }
									desc = single_combat.0041.desc.sc_attacker.wait_and_hope.fatality
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:unsure_attack }
									desc = single_combat.0041.desc.sc_attacker.unsure_attack.fatality
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:enthusiastic_onslaught }
									desc = single_combat.0041.desc.sc_attacker.enthusiastic_onslaught.fatality
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:hail_mary }
									desc = single_combat.0041.desc.sc_attacker.hail_mary.fatality
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:pocket_sand }
									desc = single_combat.0041.desc.sc_attacker.pocket_sand.fatality
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:nut_em }
									desc = single_combat.0041.desc.sc_attacker.nut_em.fatality
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:guard }
									desc = single_combat.0041.desc.sc_attacker.guard.fatality
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:probing_attack }
									desc = single_combat.0041.desc.sc_attacker.probing_attack.fatality
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:onslaught }
									desc = single_combat.0041.desc.sc_attacker.onslaught.fatality
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:surprise_attack }
									desc = single_combat.0041.desc.sc_attacker.surprise_attack.fatality
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:taunt }
									desc = single_combat.0041.desc.sc_attacker.taunt.fatality
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:put_the_boot_in }
									desc = single_combat.0041.desc.sc_attacker.put_the_boot_in.fatality
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:strict_guard }
									desc = single_combat.0041.desc.sc_attacker.strict_guard.fatality
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:confident_attack }
									desc = single_combat.0041.desc.sc_attacker.confident_attack.fatality
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:expert_onslaught }
									desc = single_combat.0041.desc.sc_attacker.expert_onslaught.fatality
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:attempt_disarm }
									desc = single_combat.0041.desc.sc_attacker.attempt_disarm.fatality
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:tire_opponent }
									desc = single_combat.0041.desc.sc_attacker.tire_opponent.fatality
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:reason_you_suck_speech }
									desc = single_combat.0041.desc.sc_attacker.reason_you_suck_speech.fatality
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:technique_from_legend }
									desc = single_combat.0041.desc.sc_attacker.technique_from_legend.fatality
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:like_a_viper }
									desc = single_combat.0041.desc.sc_attacker.like_a_viper.fatality
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:pocket_silver }
									desc = single_combat.0041.desc.sc_attacker.pocket_silver.fatality
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:martial_voice }
									desc = single_combat.0041.desc.sc_attacker.martial_voice.fatality
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:mocking_boast }
									desc = single_combat.0041.desc.sc_attacker.mocking_boast.fatality
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:is_that_a_crocodile }
									desc = single_combat.0041.desc.sc_attacker.is_that_a_crocodile.fatality
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:desert_warrior }
									desc = single_combat.0041.desc.sc_attacker.desert_warrior.fatality
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:jungle_stalker }
									desc = single_combat.0041.desc.sc_attacker.jungle_stalker.fatality
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:open_terrain_expert }
									desc = single_combat.0041.desc.sc_attacker.open_terrain_expert.fatality
								}
								triggered_desc = {
									trigger = {
										scope:sc_attacker_last_move = flag:rough_terrain_expert
										scope:sc_defender.location = { rocky_locale_trigger = yes }
									}
									desc = single_combat.0041.desc.sc_attacker.rough_terrain_expert.fatality.rocky
								}
								triggered_desc = {
									trigger = {
										scope:sc_attacker_last_move = flag:rough_terrain_expert
										scope:sc_defender.location = { terrain = wetlands }
									}
									desc = single_combat.0041.desc.sc_attacker.rough_terrain_expert.fatality.boggy
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:forest_fighter }
									desc = single_combat.0041.desc.sc_attacker.forest_fighter.fatality
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:raaargh }
									desc = single_combat.0041.desc.sc_attacker.raaargh.fatality
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:hard_grit }
									desc = single_combat.0041.desc.sc_attacker.hard_grit.fatality
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:feint_and_stab }
									desc = single_combat.0041.desc.sc_attacker.feint_and_stab.fatality
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:butchery }
									desc = single_combat.0041.desc.sc_attacker.butchery.fatality
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:stoic_veteran }
									desc = single_combat.0041.desc.sc_attacker.stoic_veteran.fatality
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:blade_dance }
									desc = single_combat.0041.desc.sc_attacker.blade_dance.fatality
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:wrath_of_highgod }
									desc = single_combat.0041.desc.sc_attacker.wrath_of_highgod.fatality
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:hurt_me_better }
									desc = single_combat.0041.desc.sc_attacker.hurt_me_better.fatality
								}
								triggered_desc = {
									trigger = { scope:sc_attacker_last_move = flag:special_fallback }
									desc = single_combat.0041.desc.sc_attacker.special_fallback.fatality
								}
								# No need for a something_to_hide, as it's never fatal.
							}
						}
					}
				}
			}
		}
	}
	theme = skull
	left_portrait = {
		character = scope:sc_victor
		scripted_animation = duel_celebrate
	}
	right_portrait = {
		character = scope:sc_loser
		animation = fear
	}
	# Background Logic
	override_background = {
		trigger = { scope:locale = flag:terrain_scope }
		reference = terrain_scope
	}
	override_background = {
		trigger = { scope:locale = flag:battlefield }
		reference = battlefield
	}
	override_background = {
		trigger = { scope:locale = flag:alley_night }
		reference = alley_night
	}
	override_background = {
		trigger = { scope:locale = flag:alley_day }
		reference = alley_day
	}
	override_background = {
		trigger = { scope:locale = flag:temple }
		reference = temple
	}
	override_background = {
		trigger = { scope:locale = flag:corridor_night }
		reference = corridor_night
	}
	override_background = {
		trigger = { scope:locale = flag:corridor_day }
		reference = corridor_day
	}
	override_background = {
		trigger = { scope:locale = flag:courtyard }
		reference = courtyard
	}
	override_background = {
		trigger = { scope:locale = flag:dungeon }
		reference = dungeon
	}
	override_background = {
		trigger = { scope:locale = flag:docks }
		reference = docks
	}
	override_background = {
		trigger = { scope:locale = flag:feast }
		reference = feast
	}
	override_background = {
		trigger = { scope:locale = flag:market }
		reference = market
	}
	override_background = {
		trigger = { scope:locale = flag:tavern }
		reference = tavern
	}
	override_background = {
		trigger = { scope:locale = flag:throne_room }
		reference = throne_room
	}
	override_background = {
		trigger = { scope:locale = flag:army_camp }
		reference = army_camp
	}

	immediate = {
		#Death/wounding enacted elsewhere.
		if = {
			limit = {
				duel_will_end_in_opponent_death_trigger = yes
			}
			scope:sc_loser = {
				show_as_tooltip = {
					single_combat_death_effect = yes
				}
			}
		}
		else_if = {
			limit = { scope:fatality = flag:practice }
			# If we're only practicing, there's no harm done.
			custom_tooltip = single_combat.result.tt.practice_no_wounds
		}
		else = {
			scope:sc_loser = {
				show_as_tooltip = {
					increase_wounds_no_death_effect = { REASON = duel }
				}
			}
		}
		# Add Blademaster Trait XP
		if = {
			limit = { has_trait = lifestyle_blademaster }
			add_trait_xp = {
				trait = lifestyle_blademaster
				value = lifestyle_blademaster_xp_gain_minor_value
			}
		}

		# Add Tournament Trait XP
		if = {
			limit = { has_trait = tourney_participant }
			add_trait_xp = {
				trait = tourney_participant
				track = foot
				value = tournament_hastiludes_xp_gain_minor_value
			}
		}
		# Damage equipped artifacts
		may_damage_artifact_effect = {
			TYPE = primary_armament
			CHANCE = 50 # 50% chance of no damage
			PERCENT = 10 # 5-10 percent of max durability lost
		}
		may_damage_artifact_effect = {
			TYPE = armor
			CHANCE = 50 # 50% chance of no damage
			PERCENT = 10 # 5-10 percent of max durability lost
		}
		#Acknowledge loss of temporary combat modifiers.
		custom_tooltip = single_combat.result.tt.temporary_modifiers_removed
	}

	# They died!
	option = {
		name = single_combat.0041.a
		trigger = { duel_will_end_in_opponent_death_trigger = yes }

		#Confirmation of the duel ending & explanation.
		sce_victor_end_result_tooltip_effect = yes

		#No stress for single-option events.
		#No AI chance needed for single-option events.
	}

	# I am victorious!
	option = {
		name = single_combat.0041.b
		trigger = { duel_will_end_in_opponent_death_trigger = no }

		#Confirmation of the duel ending & explanation.
		sce_victor_end_result_tooltip_effect = yes

		#No stress for single-option events.
		#No AI chance needed for single-option events.
	}

	after = {
		# Everyone puts their shirts back on.
		if = { #If dueled an AI, clear everything
			limit = {
				scope:sc_loser = { is_ai = yes }
			}
			single_combat_clean_shirtlessness_effect = {
				ATTACKER = scope:sc_loser
				DEFENDER = scope:sc_victor
			}
		}
		else_if = { #If both players, clear own only
			limit = { is_ai = no }
			if = {
				limit = { has_character_flag = single_combat_stripped_to_waist }
				remove_character_flag = single_combat_stripped_to_waist
			}
			else_if = { # If a player who dueled a player, clear only own flags
				limit = { has_character_flag = single_combat_duel_armor }
				remove_character_flag = single_combat_duel_armor
			}
		}
		# Everyone puts their signature weapons back on.
		if = { #If dueled an AI, clear everything
			limit = {
				scope:sc_loser = { is_ai = yes }
			}
			single_combat_clean_temp_weapon_effect = {
				ATTACKER = scope:sc_loser
				DEFENDER = scope:sc_victor
			}
		}
		else_if = { #If both players, clear own only
			limit = { is_ai = no }
			if = { #check for variables set up in set_temporary_signature_weapon
				limit = {
					OR = {
						has_variable = og_signature_weapon
						has_variable = temporary_signature_weapon
					}
				}
				if = { #remove the signature_weapon variable if the character didn't have anything before
					limit = {
						var:og_signature_weapon = flag:no_signature_weapon_yet
					}
					remove_variable = signature_weapon
				}
				else = { #restore the original signature_weapon
					set_variable = {
						name = signature_weapon
						value = var:og_signature_weapon 
					}
				}
				#remove all variables set up in set_temporary_signature_weapon
				remove_variable = temporary_signature_weapon
				remove_variable = og_signature_weapon
			}
		}
	}
}

##################################################
# Test Events
# by Ewan Cowhig Croft
# 1001+
##################################################

#	Spawn a duel, with a random knight as defender.
single_combat.1001 = {
	hidden = yes
	orphan = yes

	immediate = {
		random_knight = {
			limit = { can_start_single_combat_trigger = yes }
			save_scope_as = fighter_mc_fighter_chap
		}
		configure_start_single_combat_effect = {
			SC_INITIATOR = root
			SC_ATTACKER = root
			SC_DEFENDER = scope:fighter_mc_fighter_chap
			FATALITY = default
			FIXED = no
			LOCALE = terrain_scope
			OUTPUT_EVENT = single_combat.1006
			INVALIDATION_EVENT = single_combat.1006	#In a real event, this would obviously be a different even to the output.
		}
	}
}

#	Spawn a duel, with a random knight as attacker.
single_combat.1002 = {
	hidden = yes
	orphan = yes

	immediate = {
		random_knight = {
			limit = { can_start_single_combat_trigger = yes }
			save_scope_as = fighter_mc_fighter_chap
		}
		configure_start_single_combat_effect = {
			SC_INITIATOR = root
			SC_ATTACKER = scope:fighter_mc_fighter_chap
			SC_DEFENDER = root
			FATALITY = no
			FIXED = no
			LOCALE = terrain_scope
			OUTPUT_EVENT = single_combat.1006
			INVALIDATION_EVENT = single_combat.1006	#In a real event, this would obviously be a different even to the output.
		}
	}
}

#	Error suppression.
single_combat.1003 = {
	hidden = yes
	orphan = yes

	immediate = {
		# Fatality flags
		hidden_effect = {
			save_scope_value_as = {
				name = fatality
				value = flag:default
			}
			save_scope_value_as = {
				name = fatality
				value = flag:possible
			}
			save_scope_value_as = {
				name = fatality
				value = flag:no
			}
			save_scope_value_as = {
				name = fatality
				value = flag:always
			}
		}
		# Background flags
		hidden_effect = {
			save_scope_value_as = {
				name = locale
				value = flag:terrain_scope
			}
			save_scope_value_as = {
				name = locale
				value = flag:battlefield
			}
			save_scope_value_as = {
				name = locale
				value = flag:alley_night
			}
			save_scope_value_as = {
				name = locale
				value = flag:alley_day
			}
			save_scope_value_as = {
				name = locale
				value = flag:temple
			}
			save_scope_value_as = {
				name = locale
				value = flag:corridor_night
			}
			save_scope_value_as = {
				name = locale
				value = flag:corridor_day
			}
			save_scope_value_as = {
				name = locale
				value = flag:courtyard
			}
			save_scope_value_as = {
				name = locale
				value = flag:dungeon
			}
			save_scope_value_as = {
				name = locale
				value = flag:docks
			}
			save_scope_value_as = {
				name = locale
				value = flag:feast
			}
			save_scope_value_as = {
				name = locale
				value = flag:market
			}
			save_scope_value_as = {
				name = locale
				value = flag:tavern
			}
			save_scope_value_as = {
				name = locale
				value = flag:throne_room
			}
			save_scope_value_as = {
				name = locale
				value = flag:army_camp
			}
		}
		# Victory type flags
		if = {
			limit = {
				scope:victory_type = flag:skill
				scope:victory_type = flag:mistake
				scope:victory_type = flag:sudden_death
			}
			#Nothing.
		}
	}
}

#	Debug event to duel a character.
single_combat.1004 = {
	type = character_event
	window = duel_event
	title = single_combat.1004.t
	desc = single_combat.1004.desc
	left_portrait = {
		character = scope:actor
		animation = anger
	}
	right_portrait = {
		character = scope:recipient
		animation = fear
	}
	theme = skull

	# You are the attacker, default
	option = {
		name = single_combat.1004.a

		configure_start_single_combat_effect = {
			SC_INITIATOR = scope:actor
			SC_ATTACKER = scope:actor
			SC_DEFENDER = scope:recipient
			FATALITY = default
			FIXED = no
			LOCALE = terrain_scope
			OUTPUT_EVENT = single_combat.1006
			INVALIDATION_EVENT = single_combat.1006	#In a real event, this would obviously be a different even to the output.
		}
	}

	# You are the defender, default
	option = {
		name = single_combat.1004.b

		configure_start_single_combat_effect = {
			SC_INITIATOR = scope:actor
			SC_ATTACKER = scope:recipient
			SC_DEFENDER = scope:actor
			FATALITY = default
			FIXED = no
			LOCALE = terrain_scope
			OUTPUT_EVENT = single_combat.1006
			INVALIDATION_EVENT = single_combat.1006	#In a real event, this would obviously be a different even to the output.
		}
	}

	# You are the attacker, fatal
	option = {
		name = single_combat.1004.c

		configure_start_single_combat_effect = {
			SC_INITIATOR = scope:actor
			SC_ATTACKER = scope:actor
			SC_DEFENDER = scope:recipient
			FATALITY = always
			FIXED = no
			LOCALE = terrain_scope
			OUTPUT_EVENT = single_combat.1006
			INVALIDATION_EVENT = single_combat.1006	#In a real event, this would obviously be a different even to the output.
		}
	}

	# You are the defender, fatal
	option = {
		name = single_combat.1004.d

		configure_start_single_combat_effect = {
			SC_INITIATOR = scope:actor
			SC_ATTACKER = scope:recipient
			SC_DEFENDER = scope:actor
			FATALITY = always
			FIXED = no
			LOCALE = terrain_scope
			OUTPUT_EVENT = single_combat.1006
			INVALIDATION_EVENT = single_combat.1006	#In a real event, this would obviously be a different even to the output.
		}
	}

	# You are the attack, non-lethal
	option = {
		name = single_combat.1004.e

		configure_start_single_combat_effect = {
			SC_INITIATOR = scope:actor
			SC_ATTACKER = scope:actor
			SC_DEFENDER = scope:recipient
			FATALITY = no
			FIXED = no
			LOCALE = terrain_scope
			OUTPUT_EVENT = single_combat.1006
			INVALIDATION_EVENT = single_combat.1006	#In a real event, this would obviously be a different even to the output.
		}
	}

	# You are the defender, non-lethal
	option = {
		name = single_combat.1004.f

		configure_start_single_combat_effect = {
			SC_INITIATOR = scope:actor
			SC_ATTACKER = scope:recipient
			SC_DEFENDER = scope:actor
			FATALITY = no
			FIXED = no
			LOCALE = terrain_scope
			OUTPUT_EVENT = single_combat.1006
			INVALIDATION_EVENT = single_combat.1006	#In a real event, this would obviously be a different even to the output.
		}
	}

	# Actually, never mind
	option = {
		name = single_combat.1004.g
	}

	after = {
		single_combat_apply_default_shirtlessness_effect = {
			ATTACKER = scope:actor
			DEFENDER = scope:recipient
		}
	}
}

#	Hidden empty event for testing purposes.
single_combat.1006 = {
	hidden = yes
}
