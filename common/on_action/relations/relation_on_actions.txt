#On actions relating to relationships between characters

####################################
# NOTE
####################################
# All relations have these autogenerated, even if they're not explicitly written out here.
# The full list is:
# [relation]_quarterly_pulse
# on_set_relation_[relation]
# on_remove_relation_[relation]
# on_death_relation_[relation]
#
# The following two on_actions are scripted, rather than being called by code, so if you want one for them then it must be created and fired from the quarterly pulse.
# [relation]_status_changes
# [relation]_relation_changes
####################################

####################################
# Lover relation on_action
####################################

#Fired from the a quarterly pulse once a year
lover_quarterly_pulse = {
	trigger = {
		scope:quarter = 1
	}
	on_actions = {
		lover_status_changes
	}
}

#Lover status changes
lover_status_changes = {
	trigger = {
		num_of_relation_lover > 0
		is_available_adult = yes
	}
	random_events = {
		chance_to_happen = 50
		100 = 0
		100 = lover.0001 #Your lover has  a low opinion of you, breaks up
	}
}

on_set_relation_lover = {
	effect = {
		send_set_relation_toast_effect = { OWNER = root TARGET = scope:target RELATION = lover }
		give_incest_secret_or_nothing_with_target_effect = { CHARACTER = scope:target }
		scope:target = { give_incest_secret_or_nothing_with_target_effect = { CHARACTER = root } }
		give_homosexual_secret_or_nothing_with_target_effect = { CHARACTER = scope:target }
		scope:target = { give_homosexual_secret_or_nothing_with_target_effect = { CHARACTER = root } }
		if = {
			limit = {
				has_relation_potential_lover = scope:target
			}
			remove_relation_potential_lover = scope:target
		}

		# Warcraft
		# Struggle Catalysts.
		# End of Warcraft

		# being lover with a child is forbidden
		if = {
			limit = {
				OR = {
					scope:target = { is_adult = no }
					is_adult = no
					# Warcraft
					NOT = {
						can_have_sexual_relation_with_trigger = { CHARACTER = scope:target }
					}
					# End of Warcraft
				}
			}
			trigger_event = {
				id = lover.0010
				days = 1
			}
		}

		create_character_memory = {
			type = became_lovers
			participants = {
				new_relation = scope:target
			}
		}
		scope:target = {
			create_character_memory = {
				type = became_lovers
				participants = {
					new_relation = root
				}
			}
		}
		
		# If we're a clan this affects unity
		if = {
			limit = { # You'll lose unity for becoming the lover with another house member's spouse (regardless of what house your lover has)
				scope:target = {
					primary_spouse ?= {
						exists = house
						exists = root.house
						house = root.house
					}
				}
			}
			add_clan_unity_interaction_effect = {
				CHARACTER = root
				TARGET = scope:target.primary_spouse
				VALUE = medium_unity_loss
				DESC = clan_unity_caused_trouble.desc
				REVERSE_NON_HOUSE_TARGET = no
			}
		}
		else_if = {
			limit = { # You'll gain some unity for becoming a lover with a member of your house (as long as they aren't married to yet ANOTHER house member)
				scope:target = {
					primary_spouse ?= {
						exists = house
						exists = root.house
						NOT = { house = root.house }
					}
				}
			}
			add_clan_unity_interaction_effect = {
				CHARACTER = root
				TARGET = scope:target
				VALUE = minor_unity_gain
				DESC = clan_unity_become_lover.desc
				REVERSE_NON_HOUSE_TARGET = no
			}
		}
	}
	#events = {
	#	lover.0010
	#}
}

on_remove_relation_lover = {
	effect = {
		lose_lover_effect = {
			LOVER = scope:target
		}

		create_character_memory = {
			type = broke_up_lovers
			participants = {
				old_lover = scope:target
			}
		}
		scope:target = {
			create_character_memory = {
				type = broke_up_lovers
				participants = {
					old_lover = root
				}
			}
		}
	}
}

####################################
# Soulmatery on actions
####################################

on_set_relation_soulmate = {
	effect = {
		send_set_relation_toast_effect = { OWNER = root TARGET = scope:target RELATION = soulmate }
		if = {
			limit = {
				has_relation_potential_lover = scope:target
			}
			remove_relation_potential_lover = scope:target
		}
		# Warcraft
		# Struggle Catalysts.
		# End of Warcraft
		create_character_memory = {
			type = became_soulmates
			participants = {
				new_soulmate = scope:target
			}
		}
		scope:target = {
			create_character_memory = {
				type = became_soulmates
				participants = {
					new_soulmate = root
				}
			}
		}

		if = {
			limit = {
				exists = root.promoted_legend
			}
			scope:target = { save_scope_as = soulmate }
			root = { trigger_event = legend_spread_events.8160 }
		}
		else_if = {
			limit = {
				exists = scope:target.promoted_legend
			}
			root = { save_scope_as = soulmate }
			scope:target = { trigger_event = legend_spread_events.8160 }
		}

		# If we're a clan this interaction affects unity
		add_clan_unity_interaction_effect = {
			CHARACTER = root
			TARGET = scope:target
			VALUE = minor_unity_gain
			DESC = clan_unity_become_soulmate.desc
			REVERSE_NON_HOUSE_TARGET = no
		}
	}
}

####################################
# Friendship on actions
####################################
friendship_quarterly_pulse = {
	trigger = {
		scope:quarter = 2
	}
	on_actions = {
		friendship_status_changes
	}
}

friendship_status_changes = {
	trigger = {
		OR = {
			num_of_relation_friend > 0
		}
		is_available_adult = yes
	}

	random_events = { # If we add updates that are time sensitive, we need to rework this so it's no longer random when/what fires
		chance_to_happen = 50
		100 = 0
		100 = friendship.0001 #Lose a friend you no longer like
		100 = friendship.0010 #Lose a best friend you no longer like
		100 = friendship.0014 #Become Rivals instead of Friends
		100 = friendship.0018 #Lose a Friend due to having so many of them
	}
}

# Gaining Friend relations
on_set_relation_friend = {
	effect = {
		send_set_relation_toast_effect = { OWNER = root TARGET = scope:target RELATION = friend }

		if = {
			limit = {
				has_relation_potential_friend = scope:target
			}
			remove_relation_potential_friend = scope:target
		}

		scope:target = {
			friendly_counsel_skill_gain_effect = yes
			update_confidants_effect = yes
		}

		friendly_counsel_skill_gain_effect = yes
		decentralized_rule_friends_modifier_effect = yes
		update_confidants_effect = yes

		create_character_memory = {
			type = became_friends
			participants = {
				new_relation = scope:target
			}
		}
		scope:target = {
			create_character_memory = {
				type = became_friends
				participants = {
					new_relation = root
				}
			}
		}

		# Warcraft
		# Struggle Parameter
		# Struggle Catalyst
		# End of Warcraft

		# If we're a clan this interaction affects unity
		add_clan_unity_interaction_effect = {
			CHARACTER = root
			TARGET = scope:target
			VALUE = miniscule_unity_gain
			DESC = clan_unity_become_friend.desc
			REVERSE_NON_HOUSE_TARGET = no
		}

		# Hostage story cycle
		if = {
			limit = {
				is_hostage = yes
				is_adult = no
				OR = { # Did they just make friends with someone important at their warden's court?
					scope:target = warden
					warden = {
						any_child = {
							this = scope:target
						}
					}
					warden = {
						any_councillor = {
							this = scope:target
						}
					}
					warden = {
						any_spouse = {
							this = scope:target
						}
					}
				}
			}
			save_scope_as = hostage
			random = {
				chance = 75
				warden = {
					trigger_event = bp2_yearly.8050
				}
			}
		}
	}
}

# Losing friend relations. Not fired on death, just relationship expiring
# root = owner of the relationship
# scope:target = target
on_remove_relation_friend = {
	effect = {
		remove_character_modifier = confidants_perk_modifier
		trigger_event = death_management.1003
		scope:target = {
			trigger_event = death_management.1003
			if = {
				limit = { has_perk = confidants_perk }
				remove_character_modifier = confidants_perk_modifier
			}
			decentralized_rule_removal_effect = yes
		}
		create_character_memory = {
			type = stopped_being_friends
			participants = {
				old_friend = scope:target
			}
		}
		scope:target = {
			create_character_memory = {
				type = stopped_being_friends
				participants = {
					old_friend = root
				}
			}
		}
	}
}

on_death_relation_friend = {
	effect = {
		remove_character_modifier = confidants_perk_modifier
		trigger_event = death_management.1003
		scope:target = {
			if = {
				limit = {
					is_alive = yes
					NOT = {
						is_close_family_of = root
					}
				}
				create_character_memory = {
					type = friend_died

					participants = {
						dead_relation = root
					}
				}
			}
			if = {
				limit = {
					root = {
						any_spouse = {
							is_ai = yes
							NOR = {
								has_trait = chaste
								has_trait = celibate
								has_trait = eunuch
							}
						}
					}
				}
				root = {
					save_scope_as = dead_friend
					random_spouse = {
						limit = {
							is_ai = yes
							NOR = {
								has_trait = chaste
								has_trait = celibate
								has_trait = eunuch
							}
						}
						save_scope_as = dead_friend_spouse
					}
				}
				trigger_event = bp1_yearly.7029
			}
			trigger_event = death_management.1003
			if = {
				limit = { has_perk = confidants_perk }
				remove_character_modifier = confidants_perk_modifier
			}
			decentralized_rule_removal_effect = yes
		}
	}
}

####################################
# Best Friendship on actions
####################################

on_set_relation_best_friend = {
	effect = {
		send_set_relation_toast_effect = { OWNER = root TARGET = scope:target RELATION = best_friend }

		if = {
			limit = {
				has_relation_potential_friend = scope:target
			}
			remove_relation_potential_friend = scope:target
		}

		if = {
			limit = {
				scope:target = {
					has_character_modifier = dead_best_friend_modifier
				}
			}
			scope:target = {
				remove_character_modifier = dead_best_friend_modifier
			}
		}

		# Set mutual strong hooks for bestest friendeds with Ritualised Friendship.
		## We don't care what hooks you had before: the real hooks were the friends we made along the way.
		### Unless you already had best_friend_hooks somehow. Those we do care about.
		if = {
			limit = {
				valid_ritualised_best_friendship_two_way_trigger = {
					ACTOR_FRIEND = root
					RECIPIENT_FRIEND = scope:target
				}
			}
			# One for root.
			if = {
				limit = {
					NOT = {
						has_hook_of_type = {
							target = scope:target
							type = ritual_best_friend_hook
						}
					}
				}
				send_interface_toast = {
					title = on_set_relation_best_friend.gain_hook.root.tt
					left_icon = scope:target
					# The hookening.
					## Due to some weird order-of-operations stuff, we enclose this in an if statement.
					if = {
						limit = {
							NOT = {
								has_hook_of_type = {
									target = scope:target
									type = ritual_best_friend_hook
								}
							}
							can_add_hook = {
								target = scope:target
								type = ritual_best_friend_hook
							}
						}
						add_hook = {
							type = ritual_best_friend_hook
							target = scope:target
						}
					}
				}
			}
			# & one for scope:target.
			scope:target = {
				if = {
					limit = {
						NOT = {
							has_hook_of_type = {
								target = root
								type = ritual_best_friend_hook
							}
						}
					}
					send_interface_toast = {
						title = on_set_relation_best_friend.gain_hook.target.tt
						left_icon = root
						# The hookening part #2.
						## Due to some weird order-of-operations stuff, we enclose this in an if statement.
						if = {
							limit = {
								NOT = {
									has_hook_of_type = {
										target = root
										type = ritual_best_friend_hook
									}
								}
								can_add_hook = {
									target = root
									type = ritual_best_friend_hook
								}
							}
							add_hook = {
								type = ritual_best_friend_hook
								target = root
							}
						}
					}
				}
			}
		}

		# Warcraft
		# Struggle Catalysts.
		# End of Warcraft

		# If we're a clan this interaction affects unity
		add_clan_unity_interaction_effect = {
			CHARACTER = root
			TARGET = scope:target
			VALUE = minor_unity_gain
			DESC = clan_unity_become_best_friend.desc
			REVERSE_NON_HOUSE_TARGET = no
		}
	}
}

# Losing best friend relations. Not fired on death, just relationship expiring
# root = owner of the relationship
# scope:target = target
on_remove_relation_best_friend = {
	effect = {
		# Destroy mutual strong hooks for bestest friendeds with Ritualised Friendship.
		if = {
			limit = {
				has_hook_of_type = {
					target = scope:target
					type = ritual_best_friend_hook
				}
			}
			send_interface_toast = {
				title = on_remove_relation_best_friend.lose_hook.root.tt
				left_icon = scope:target
				remove_hook = {
					target = scope:target
					type = ritual_best_friend_hook
				}
			}
		}
		scope:target = {
			if = {
				limit = {
					has_hook_of_type = {
						target = root
						type = ritual_best_friend_hook
					}
				}
				send_interface_toast = {
					title = on_remove_relation_best_friend.lose_hook.target.tt
					left_icon = root
					remove_hook = {
						target = root
						type = ritual_best_friend_hook
					}
				}
			}
		}
		# Likewise, if there are any synergised friendship modifiers drifting about, destroy them.
		if = {
			limit = { has_any_best_friend_synergy_bonus_modifier_trigger = yes }
			send_interface_toast = {
				title = on_remove_relation_best_friend.lose_synergy_modifiers.root.tt
				left_icon = scope:target
				remove_every_best_friend_synergy_bonus_modifier_effect = yes
			}
		}
		scope:target = {
			if = {
				limit = { has_any_best_friend_synergy_bonus_modifier_trigger = yes }
				send_interface_toast = {
					title = on_remove_relation_best_friend.lose_synergy_modifiers.target.tt
					left_icon = root
					remove_every_best_friend_synergy_bonus_modifier_effect = yes
				}
			}
		}
	}
}

on_death_relation_best_friend = {
	effect = {
		# If your best friend dies, you lose your synergy modifiers.
		if = {
			limit = { has_any_best_friend_synergy_bonus_modifier_trigger = yes }
			send_interface_toast = {
				title = on_death_relation_best_friend.lose_synergy_modifiers.root.tt
				left_icon = scope:target
				remove_every_best_friend_synergy_bonus_modifier_effect = yes
			}
		}

		if = {
			limit = {
				has_bp1_dlc_trigger = yes
			}
			save_scope_as = deceased_pal
			scope:target = {
				trigger_event = bp1_yearly.5714
			}
		}

		scope:target = {
			if = {
				limit = {
					is_alive = yes
					NOT = {
						is_close_family_of = root
					}
				}
				create_character_memory = {
					type = best_friend_died

					participants = {
						dead_relation = root
					}
				}
			}
		}
	}
}

####################################
# Rival on actions
####################################
rival_quarterly_pulse = {
	trigger = {
		scope:quarter = 3
	}
	on_actions = {
		rival_relation_changes
	}
}


rival_relation_changes = {
	trigger = {
		OR = {
			num_of_relation_rival > 0
			num_of_relation_potential_rival > 0
		}
		is_available_adult = yes
	}

	random_events = {
		chance_to_happen = 50
		100 = 0
		100 = rivalry.0001
		100 = rivalry.0003 #Nemesis becomes too pathetic
	}
}

on_set_relation_rival = {
	effect = {

		# Warcraft - removed struggle catalysts

		send_set_relation_toast_effect = { OWNER = root TARGET = scope:target RELATION = rival }
		if = {
			limit = {
				has_relation_potential_rival = scope:target
			}
			remove_relation_potential_rival = scope:target
		}
		create_character_memory = {
			type = became_rivals
			participants = {
				rival = scope:target
			}
		}
		scope:target = {
			create_character_memory = {
				type = became_rivals
				participants = {
					rival = root
				}
			}
		}

		# If we're a clan this interaction affects unity
		add_clan_unity_interaction_effect = {
			CHARACTER = root
			TARGET = scope:target
			VALUE = medium_unity_loss
			DESC = clan_unity_become_rival.desc
			REVERSE_NON_HOUSE_TARGET = no
		}
		
		# Hostage story cycle
		if = {
			limit = {
				is_hostage = yes
				is_adult = no
				OR = { # Did they just become rivals with someone important back home?
					AND = {
						scope:target = father
						NOT = { # Make sure the father is not your warden or your warden's spouse
							father = warden
							warden = {
								any_spouse = {
									this = root.father
								}
							}
						}
					}
					AND = {
						scope:target = mother
						NOT = { # Make sure the mother is not your warden or your warden's spouse
							mother = warden
							warden = {
								any_spouse = {
									this = root.mother
								}
							}
						}
					}
				}
			}
			save_scope_as = hostage
			random = {
				chance = 75
				warden = {
					trigger_event = bp2_yearly.8050
				}
			}
		}
	}
}

# Warcraft - removed struggle catalysts
on_set_relation_nemesis = {
	effect = {
		send_set_relation_toast_effect = { OWNER = root TARGET = scope:target RELATION = nemesis }
		if = {
			limit = {
				has_relation_potential_rival = scope:target
			}
			remove_relation_potential_rival = scope:target
		}

		create_character_memory = {
			type = became_nemesis
			participants = {
				nemesis = scope:target
			}
		}
		scope:target = {
			create_character_memory = {
				type = became_nemesis
				participants = {
					nemesis = root
				}
			}
		}

		# If we're a clan this interaction affects unity
		add_clan_unity_interaction_effect = {
			CHARACTER = root
			TARGET = scope:target
			VALUE = medium_unity_loss
			DESC = clan_unity_become_nemesis.desc
			REVERSE_NON_HOUSE_TARGET = no
		}
	}
}

on_remove_relation_rival = {
	#events = {
		#rivalry.9999
	#}
	effect = {
		create_character_memory = {
			type = stopped_being_rivals
			participants = {
				old_rival = scope:target
			}
		}
		scope:target = {
			create_character_memory = {
				type = stopped_being_rivals
				participants = {
					old_rival = root
				}
			}
		}
	}
}

on_death_relation_lover = {
	#Root is the dying character
	#scope:target is the lover
	effect = {
		if = {
			limit = {
				NOT = {
					has_relation_soulmate = scope:target
				}
			}
			scope:target = {
				if = {
					limit = {
						is_alive = yes
						NOT = {
							is_close_family_of = root
						}
					}
					create_character_memory = {
						type = lover_died

						participants = {
							dead_relation = root
						}
					}
				}
			}
		}
	}
}

on_death_relation_soulmate = {
	#Root is the dying character
	#scope:target is the soulmate
	effect = {
		scope:target = {
			if = {
				limit = {
					is_alive = yes
					NOT = {
						is_close_family_of = root
					}
				}
				create_character_memory = {
					type = soulmate_died

					participants = {
						dead_relation = root
					}
				}
			}
		}
	}
}

on_death_relation_rival = {
	#Root is the dying character
	#scope:target is the rival
	effect = {
		if = {
			limit = {
				NOT = {
					has_relation_nemesis = scope:target
				}
			}
			scope:target = {
				if = {
					limit = {
						is_alive = yes
						NOT = {
							is_close_family_of = root
						}
					}
					create_character_memory = {
						type = rival_died

						participants = {
							dead_relation = root
						}
					}
				}
			}
		}
	}
}

on_death_relation_nemesis = {
	#Root is the dying character
	#scope:target is the nemesis
	effect = {
		root = {
			save_scope_as = dead_nemesis
			scope:dead_nemesis = {
				random_spouse = {
					limit = {
						is_ai = yes
					}
					save_scope_as = dead_nemesis_spouse
				}
			}
		}
		scope:target = {
			if = {
				limit = {
					is_alive = yes
					NOT = {
						is_close_family_of = root
					}
				}
				create_character_memory = {
					type = nemesis_died

					participants = {
						dead_relation = root
					}
				}
			}
			trigger_event = {
				id = bp1_yearly.5601
				days = 1
			}
		}
	}
}

####################################
# Mentor/Student on actions
####################################
mentor_student_quarterly_pulse = {
	trigger = {
		scope:quarter = 4
	}
	on_actions = {
		mentor_student_relation_changes
	}
}

mentor_student_relation_changes = {
	trigger = {
		num_of_relation_intrigue_mentor > 0
		is_available_adult = yes
	}

	random_events = {
		chance_to_happen = 50
		500 = 0
		100 = mentor_student.0001
		100 = mentor_student.0002
		100 = mentor_student.0003
	}
}

####################################
# Guardian/ward
####################################

#Fired for the ward when they remove the relation with the guardian
on_set_relation_guardian = {
	effect = {
		if = {
			limit = { exists = liege }
			liege = { save_scope_as = ward_liege }


			# Warcraft
			# Struggle parameter
			#if = {
			#	limit = {
			#		scope:target = {
			#			NOT = { this = scope:ward_liege }
			#			is_landed = yes
			#			any_character_struggle = {
			#				involvement = involved
			#				has_struggle_phase_parameter = apply_truce_when_sending_ward
			#			}
			#		}
			#		scope:ward_liege = {
			#			any_character_struggle = {
			#				involvement = involved
			#				has_struggle_phase_parameter = apply_truce_when_sending_ward
			#			}
			#		}
			#	}
			#	scope:target = {
			#		add_truce_both_ways = {
			#			character = scope:ward_liege
			#			days = 3650
			#			name = TRUCE_FP2_WARD
			#		}
			#	}
			#
			#	# Struggle catalyst
			#	if = {
			#		limit = {
			#			scope:ward_liege = {
			#				any_character_struggle = {
			#					involvement = involved
			#					activate_struggle_catalyst_secondary_character_involvement_involved_trigger = {
			#						CATALYST = catalyst_sign_truce_outside_war
			#						CHAR = scope:target
			#					}
			#				}
			#			}
			#		}
			#		scope:ward_liege = {
			#			every_character_struggle = {
			#				involvement = involved
			#				limit = {
			#					activate_struggle_catalyst_secondary_character_involvement_involved_trigger = {
			#						CATALYST = catalyst_sign_truce_outside_war
			#						CHAR = scope:target
			#					}
			#				}
			#				activate_struggle_catalyst = {
			#					catalyst = catalyst_sign_truce_outside_war
			#					character = scope:ward_liege
			#				}
			#			}
			#		}
			#	}
			#}
			# End of Warcraft
		}
	}
}

on_remove_relation_guardian = {
	effect = {
		#Remove guardian opinions when guardian is removed from ward or the ward is about to die
		if = {
			limit = { exists = liege }
			liege = { save_scope_as = ward_liege }
			guardian_remove_opinion_effect = {
				WARD = root
				GUARDIAN = scope:target
				WARD_LIEGE = scope:ward_liege
			}
			#Fallback to make sure they go home
			if = {
				limit = {
					is_foreign_court_guest = yes
					NOT = { host = liege }
				}
				return_to_court = yes
			}


			# Warcraft
			# Struggle parameter
			#if = {
			#	limit = {
			#		scope:target = {
			#			NOT = { this = scope:ward_liege }
			#			any_character_struggle = {
			#				involvement = involved
			#				has_struggle_phase_parameter = apply_truce_when_sending_ward
			#			}
			#			has_truce = scope:ward_liege
			#		}
			#		scope:ward_liege = {
			#			any_character_struggle = {
			#				involvement = involved
			#				has_struggle_phase_parameter = apply_truce_when_sending_ward
			#			}
			#		}
			#	}
			#	scope:target = {
			#		cancel_truce_both_ways = scope:ward_liege
			#	}
			#}
			# End of Warcraft
		}
		# foreign ward may decide they're going to snitch when they get home
		
	}
}

#Fired for the ward when they die while having a guardian
on_death_relation_guardian = {
	effect = {
		#Remove guardian opinions when guardian is removed from ward or the ward is about to die
		if = {
			limit = { exists = liege }
			liege = { save_scope_as = ward_liege }
			guardian_remove_opinion_effect = {
				WARD = root
				GUARDIAN = scope:target
				WARD_LIEGE = scope:ward_liege
			}
			#To make sure they go home
			if = {
				limit = {
					is_foreign_court_guest = yes
					NOT = { host = liege }
				}
				return_to_court = yes
			}
		}
	}
}

#Fired for the guardian when they remove the relation with the ward
on_remove_relation_ward = {
	effect = {
		#Remove guardian opinions when ward is removed from guardian or when the guardian is about to die
		if = { #Commented out because this shouldn't be needed but if we get errors something weird might be going on
			limit = { exists = liege }
			liege = { save_scope_as = ward_liege }
			guardian_remove_opinion_effect = {
				WARD = scope:target
				GUARDIAN = root
				WARD_LIEGE = scope:ward_liege
			}

			#Fallback to make sure they go home
			if = {
				limit = {
					is_foreign_court_guest = yes
					NOR = {
						host = liege
						is_landed = yes
						any_relation = { #They're not at another ward's court
							type = ward
							is_landed = yes
							this = root.host
						}
					}
				}
				return_to_court = yes
			}
		}
	}
}

#Fired for the guardian when they die while having a ward
on_death_relation_ward = {
	effect = {
		#Remove guardian opinions when ward is removed from guardian or when the guardian is about to die
		if = { #Commented out because this shouldn't be needed but if we get errors something weird might be going on
			limit = { exists = liege }
			liege = { save_scope_as = ward_liege }
			guardian_remove_opinion_effect = {
				WARD = scope:target
				GUARDIAN = root
				WARD_LIEGE = scope:ward_liege
			}
			#To make sure they go home
			if = {
				limit = {
					is_foreign_court_guest = yes
					NOT = { host = liege }
				}
				return_to_court = yes
			}
		}
	}
}

#Become crush
on_set_relation_crush = {
	effect = {
		# Crushes are unilateral
		create_character_memory = {
			type = developed_crush
			participants = {
				new_relation = scope:target
			}
		}
	}
}

####################################
# Wet Nurse
####################################
on_death_relation_nursed_child = {
	#Root is the dying character
	#scope:target is the child
	effect = {
		scope:target = {
			#create a memory that your nurse died
			if = {
				limit = {
					is_alive = yes
				}
				create_character_memory = { 
					type = wet_nurse_died

					participants = {
						dead_relation = root
					}
				}
			}
			#if you had good realtions with the nurse trigger an event griefing her
			if = {
				limit = {
					is_alive = yes
					is_adult = no
					age >= 3
					exists = root.employer
					NOT = { root.employer = scope:target }
					OR = {
						opinion = {
							target = root
							value >= medium_positive_opinion
						}
						has_relation_friend = root
						has_relation_best_friend = root
					}
				}
				scope:target = { save_scope_as = nursed_child }
				root = { save_scope_as = former_wet_nurse }
				root.employer = {
					save_scope_as = liege
					trigger_event = {
						id = bp2_yearly.7013
						days = { 5 10 }
					}
				}
			}
		}
	}
}
