scarlet_mark_character = {
	if = {
		limit = {
			$REQUESTING_CHARACTER$.faith = $TARGET_CHARACTER$.faith
		}

		$REQUESTING_CHARACTER$ = {
			save_scope_as = requesting_character
		}
		$TARGET_CHARACTER$ = {
			save_scope_as = target_character
			faith.religious_head = {
				save_scope_as = religious_head
			}

			# If our religious head was convinced/persuaded to scarlet mark us by another ruler, we want to make that clear.
			if = {
				limit = {
					NOT = { scope:requesting_character = scope:religious_head }
				}
				add_opinion = {
					modifier = angry_opinion
					target = scope:religious_head
					opinion = -30
				}
				add_opinion = {
					modifier = hate_opinion
					target = scope:requesting_character
					opinion = -50
				}
			}
			# Though if our head independently decided to scarlet mark us, that should also be clear.
			else = {
				add_opinion = {
					modifier = angry_opinion
					target = scope:religious_head
					opinion = -50
				}
			}
			add_scarlet_mark_actual_effect = yes
			progress_towards_rival_effect = {
				CHARACTER = scope:requesting_character
				REASON = rival_requested_scarlet_mark
				OPINION = 0
			}
			set_variable = { #TO save who wanted you scarlet marked
				name = requested_my_scarlet_mark
				value = scope:requesting_character
			}

			# Regardless of why the scarlet mark happened, players should be aware whenever a character of interest is scarlet marked.
			every_player = {
				limit = {
					faith = scope:target_character.faith
					NOR = {
						this = scope:target_character # If we are the scarlet mark target, we were already send a notification in the script above this.
						this = scope:requesting_character #If we are the scarlet mark requester, we already get a diplomacy response telling us about the scarlet mark.
					}

					save_temporary_scope_as = player
					OR = {
						top_liege = scope:target_character # Our realm's top liege is a character of interest.
						top_liege = {
							any_vassal_or_below = { # Peers of the realm are also characters of interest...
								this = scope:target_character
								OR = {
									NOT = { highest_held_title_tier = 1 } #... unless they're someone else's baron (then they're too inconsequential).
									is_vassal_of = scope:player
								}
							}
						}
						any_close_family_member = {
							this = scope:target_character # Family members are characters of interest, even if not part of our realm.
						}
						any_neighboring_top_liege_realm_owner = {
							this = scope:target_character # Finally, any neighboring realm owners are characters of interest (as we get a scarlet mark war CB on them, as well as the ability to request claims).
						}
					}
				}
				save_scope_as = this_player
				send_interface_message = {
					type = scarlet_mark_other_message
					title = scarlet_mark_other_message
					desc = other_scarlet_mark_message
					left_icon = scope:target_character
					right_icon = scope:religious_head	
				}
			}
		}
	}
}

lift_character_scarlet_mark_effect = {
	$REQUESTING_CHARACTER$ = {
		hidden_effect = {
			send_interface_toast = {	
				title = lift_scarlet_mark_interaction_desc.tt
				left_icon = $TARGET_CHARACTER$
				$TARGET_CHARACTER$ = {
					show_as_tooltip = { remove_trait = scarlet_mark }
				}
			}
		}
	} 
	$TARGET_CHARACTER$ = {
		trigger_event = wc_religious_interaction.1024
		remove_trait = scarlet_mark
		add_character_modifier = {
			modifier = scarlet_mark_recently_lifted_modifier
			years = 5
		}
		add_opinion = { 
			modifier = grateful_opinion
			target = $REQUESTING_CHARACTER$
			opinion = 30
		}
		# To nudge friendship.
		hidden_effect = {
			if = {
				limit = {
					NOR = {
						has_relation_friend = $REQUESTING_CHARACTER$
						has_relation_potential_friend = $REQUESTING_CHARACTER$
					}
				}
				set_relation_potential_friend = $REQUESTING_CHARACTER$
			}
		}
	}
}

surrender_to_inquistion_effect = {
	if = {
		limit = { exists = faith.religious_head }
		imprison_character_effect = {
			IMPRISONER = faith.religious_head
			TARGET = root
		}
	}
	else = {
		imprison_character_effect = {
			IMPRISONER = liege
			TARGET = root
		}
	}
}